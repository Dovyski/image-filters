(() => {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
    var __commonJS = (cb, mod3) => function __require() {
      return mod3 || (0, cb[Object.keys(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
    };
    var __export = (target, all2) => {
      __markAsModule(target);
      for (var name in all2)
        __defProp(target, name, { get: all2[name], enumerable: true });
    };
    var __reExport = (target, module, desc) => {
      if (module && typeof module === "object" || typeof module === "function") {
        for (let key of __getOwnPropNames(module))
          if (!__hasOwnProp.call(target, key) && key !== "default")
            __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module) => {
      return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
    };
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step3(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step3(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step3 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step3((generator = generator.apply(__this, __arguments)).next());
      });
    };
  
    // ../../../tfjs/tfjs-core/node_modules/long/src/long.js
    var require_long = __commonJS({
      "../../../tfjs/tfjs-core/node_modules/long/src/long.js"(exports, module) {
        module.exports = Long2;
        var wasm = null;
        try {
          wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            13,
            2,
            96,
            0,
            1,
            127,
            96,
            4,
            127,
            127,
            127,
            127,
            1,
            127,
            3,
            7,
            6,
            0,
            1,
            1,
            1,
            1,
            1,
            6,
            6,
            1,
            127,
            1,
            65,
            0,
            11,
            7,
            50,
            6,
            3,
            109,
            117,
            108,
            0,
            1,
            5,
            100,
            105,
            118,
            95,
            115,
            0,
            2,
            5,
            100,
            105,
            118,
            95,
            117,
            0,
            3,
            5,
            114,
            101,
            109,
            95,
            115,
            0,
            4,
            5,
            114,
            101,
            109,
            95,
            117,
            0,
            5,
            8,
            103,
            101,
            116,
            95,
            104,
            105,
            103,
            104,
            0,
            0,
            10,
            191,
            1,
            6,
            4,
            0,
            35,
            0,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            126,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            127,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            128,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            129,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            130,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11
          ])), {}).exports;
        } catch (e) {
        }
        function Long2(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long2.prototype.__isLong__;
        Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
        function isLong(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        Long2.isLong = isLong;
        var INT_CACHE = {};
        var UINT_CACHE = {};
        function fromInt(value, unsigned) {
          var obj, cachedObj, cache;
          if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
              UINT_CACHE[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
              INT_CACHE[value] = obj;
            return obj;
          }
        }
        Long2.fromInt = fromInt;
        function fromNumber(value, unsigned) {
          if (isNaN(value))
            return unsigned ? UZERO : ZERO;
          if (unsigned) {
            if (value < 0)
              return UZERO;
            if (value >= TWO_PWR_64_DBL)
              return MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL)
              return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
              return MAX_VALUE;
          }
          if (value < 0)
            return fromNumber(-value, unsigned).neg();
          return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
        }
        Long2.fromNumber = fromNumber;
        function fromBits(lowBits, highBits, unsigned) {
          return new Long2(lowBits, highBits, unsigned);
        }
        Long2.fromBits = fromBits;
        var pow_dbl = Math.pow;
        function fromString(str, unsigned, radix) {
          if (str.length === 0)
            throw Error("empty string");
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p;
          if ((p = str.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber(pow_dbl(radix, 8));
          var result2 = ZERO;
          for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result2 = result2.mul(power).add(fromNumber(value));
            } else {
              result2 = result2.mul(radixToPower);
              result2 = result2.add(fromNumber(value));
            }
          }
          result2.unsigned = unsigned;
          return result2;
        }
        Long2.fromString = fromString;
        function fromValue(val, unsigned) {
          if (typeof val === "number")
            return fromNumber(val, unsigned);
          if (typeof val === "string")
            return fromString(val, unsigned);
          return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
        }
        Long2.fromValue = fromValue;
        var TWO_PWR_16_DBL = 1 << 16;
        var TWO_PWR_24_DBL = 1 << 24;
        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
        var ZERO = fromInt(0);
        Long2.ZERO = ZERO;
        var UZERO = fromInt(0, true);
        Long2.UZERO = UZERO;
        var ONE = fromInt(1);
        Long2.ONE = ONE;
        var UONE = fromInt(1, true);
        Long2.UONE = UONE;
        var NEG_ONE = fromInt(-1);
        Long2.NEG_ONE = NEG_ONE;
        var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
        Long2.MAX_VALUE = MAX_VALUE;
        var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
        Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
        var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
        Long2.MIN_VALUE = MIN_VALUE;
        var LongPrototype = Long2.prototype;
        LongPrototype.toInt = function toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype.toNumber = function toNumber() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };
        LongPrototype.toString = function toString(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE)) {
              var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
              return div2.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
          var result2 = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
              return digits + result2;
            else {
              while (digits.length < 6)
                digits = "0" + digits;
              result2 = "" + digits + result2;
            }
          }
        };
        LongPrototype.getHighBits = function getHighBits() {
          return this.high;
        };
        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
          return this.high >>> 0;
        };
        LongPrototype.getLowBits = function getLowBits() {
          return this.low;
        };
        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
          return this.low >>> 0;
        };
        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
          if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          var val = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--)
            if ((val & 1 << bit) != 0)
              break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype.isZero = function isZero() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype.eqz = LongPrototype.isZero;
        LongPrototype.isNegative = function isNegative() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype.isPositive = function isPositive() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype.isOdd = function isOdd() {
          return (this.low & 1) === 1;
        };
        LongPrototype.isEven = function isEven2() {
          return (this.low & 1) === 0;
        };
        LongPrototype.equals = function equals(other) {
          if (!isLong(other))
            other = fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype.eq = LongPrototype.equals;
        LongPrototype.notEquals = function notEquals(other) {
          return !this.eq(other);
        };
        LongPrototype.neq = LongPrototype.notEquals;
        LongPrototype.ne = LongPrototype.notEquals;
        LongPrototype.lessThan = function lessThan(other) {
          return this.comp(other) < 0;
        };
        LongPrototype.lt = LongPrototype.lessThan;
        LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
          return this.comp(other) <= 0;
        };
        LongPrototype.lte = LongPrototype.lessThanOrEqual;
        LongPrototype.le = LongPrototype.lessThanOrEqual;
        LongPrototype.greaterThan = function greaterThan(other) {
          return this.comp(other) > 0;
        };
        LongPrototype.gt = LongPrototype.greaterThan;
        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
          return this.comp(other) >= 0;
        };
        LongPrototype.gte = LongPrototype.greaterThanOrEqual;
        LongPrototype.ge = LongPrototype.greaterThanOrEqual;
        LongPrototype.compare = function compare(other) {
          if (!isLong(other))
            other = fromValue(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype.comp = LongPrototype.compare;
        LongPrototype.negate = function negate() {
          if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
          return this.not().add(ONE);
        };
        LongPrototype.neg = LongPrototype.negate;
        LongPrototype.add = function add5(addend) {
          if (!isLong(addend))
            addend = fromValue(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.subtract = function subtract(subtrahend) {
          if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype.sub = LongPrototype.subtract;
        LongPrototype.multiply = function multiply3(multiplier) {
          if (this.isZero())
            return ZERO;
          if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
          if (wasm) {
            var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }
          if (multiplier.isZero())
            return ZERO;
          if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
          if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype.mul = LongPrototype.multiply;
        LongPrototype.divide = function divide(divisor) {
          if (!isLong(divisor))
            divisor = fromValue(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (wasm) {
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
              return this;
            }
            var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;
              else if (divisor.eq(MIN_VALUE))
                return ONE;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                  return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE))
              return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = ZERO;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return UZERO;
            if (divisor.gt(this.shru(1)))
              return UONE;
            res = UZERO;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype.div = LongPrototype.divide;
        LongPrototype.modulo = function modulo(divisor) {
          if (!isLong(divisor))
            divisor = fromValue(divisor);
          if (wasm) {
            var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype.mod = LongPrototype.modulo;
        LongPrototype.rem = LongPrototype.modulo;
        LongPrototype.not = function not() {
          return fromBits(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype.and = function and(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        };
        LongPrototype.or = function or(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        };
        LongPrototype.xor = function xor(other) {
          if (!isLong(other))
            other = fromValue(other);
          return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        LongPrototype.shiftLeft = function shiftLeft(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return fromBits(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype.shl = LongPrototype.shiftLeft;
        LongPrototype.shiftRight = function shiftRight(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        LongPrototype.shr = LongPrototype.shiftRight;
        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
          if (isLong(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return fromBits(high, 0, this.unsigned);
            else
              return fromBits(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        LongPrototype.shru = LongPrototype.shiftRightUnsigned;
        LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
        LongPrototype.toSigned = function toSigned() {
          if (!this.unsigned)
            return this;
          return fromBits(this.low, this.high, false);
        };
        LongPrototype.toUnsigned = function toUnsigned() {
          if (this.unsigned)
            return this;
          return fromBits(this.low, this.high, true);
        };
        LongPrototype.toBytes = function toBytes(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype.toBytesLE = function toBytesLE() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
          ];
        };
        LongPrototype.toBytesBE = function toBytesBE() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
          return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
        };
        Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
          return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
        };
        Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
          return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
        };
      }
    });
  
    // (disabled):../../../tfjs/tfjs-core/node_modules/node-fetch/browser.js
    var require_browser = __commonJS({
      "(disabled):../../../tfjs/tfjs-core/node_modules/node-fetch/browser.js"() {
      }
    });
  
    // (disabled):../../../tfjs/tfjs-core/node_modules/util/util.js
    var require_util = __commonJS({
      "(disabled):../../../tfjs/tfjs-core/node_modules/util/util.js"() {
      }
    });
  
    // (disabled):node_modules/node-fetch/browser.js
    var require_browser2 = __commonJS({
      "(disabled):node_modules/node-fetch/browser.js"() {
      }
    });
  
    // (disabled):node_modules/util/util.js
    var require_util2 = __commonJS({
      "(disabled):node_modules/util/util.js"() {
      }
    });
  
    // (disabled):crypto
    var require_crypto = __commonJS({
      "(disabled):crypto"() {
      }
    });
  
    // node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js
    var require_tf_core_node = __commonJS({
      "node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (b2.hasOwnProperty(p))
                d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        function __extends2(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        function __awaiter2(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step4((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator2(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op3) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op3[0] & 2 ? y["return"] : op3[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op3[1])).done)
                  return t;
                if (y = 0, t)
                  op3 = [op3[0] & 2, t.value];
                switch (op3[0]) {
                  case 0:
                  case 1:
                    t = op3;
                    break;
                  case 4:
                    _.label++;
                    return { value: op3[1], done: false };
                  case 5:
                    _.label++;
                    y = op3[1];
                    op3 = [0];
                    continue;
                  case 7:
                    op3 = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op3[0] === 6 || op3[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op3[0] === 3 && (!t || op3[1] > t[0] && op3[1] < t[3])) {
                      _.label = op3[1];
                      break;
                    }
                    if (op3[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op3;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op3);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op3 = body.call(thisArg, _);
              } catch (e) {
                op3 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op3[0] & 5)
              throw op3[1];
            return { value: op3[0] ? op3[1] : void 0, done: true };
          }
        }
        var EPSILON_FLOAT323 = 1e-7;
        var EPSILON_FLOAT163 = 1e-4;
        var DataStorage2 = function() {
          function DataStorage3(backend2, dataMover) {
            this.backend = backend2;
            this.dataMover = dataMover;
            this.data = new WeakMap();
            this.dataIdsCount = 0;
          }
          DataStorage3.prototype.get = function(dataId) {
            if (!this.data.has(dataId)) {
              this.dataMover.moveData(this.backend, dataId);
            }
            return this.data.get(dataId);
          };
          DataStorage3.prototype.set = function(dataId, value) {
            this.dataIdsCount++;
            this.data.set(dataId, value);
          };
          DataStorage3.prototype.has = function(dataId) {
            return this.data.has(dataId);
          };
          DataStorage3.prototype.delete = function(dataId) {
            this.dataIdsCount--;
            return this.data.delete(dataId);
          };
          DataStorage3.prototype.numDataIds = function() {
            return this.dataIdsCount;
          };
          return DataStorage3;
        }();
        var KernelBackend2 = function() {
          function KernelBackend3() {
          }
          KernelBackend3.prototype.refCount = function(dataId) {
            return notYetImplemented2("refCount");
          };
          KernelBackend3.prototype.incRef = function(dataId) {
            return notYetImplemented2("incRef");
          };
          KernelBackend3.prototype.timerAvailable = function() {
            return true;
          };
          KernelBackend3.prototype.time = function(f) {
            return notYetImplemented2("time");
          };
          KernelBackend3.prototype.read = function(dataId) {
            return notYetImplemented2("read");
          };
          KernelBackend3.prototype.readSync = function(dataId) {
            return notYetImplemented2("readSync");
          };
          KernelBackend3.prototype.numDataIds = function() {
            return notYetImplemented2("numDataIds");
          };
          KernelBackend3.prototype.disposeData = function(dataId, force) {
            return notYetImplemented2("disposeData");
          };
          KernelBackend3.prototype.write = function(values, shape, dtype) {
            return notYetImplemented2("write");
          };
          KernelBackend3.prototype.move = function(dataId, values, shape, dtype, refCount) {
            return notYetImplemented2("move");
          };
          KernelBackend3.prototype.memory = function() {
            return notYetImplemented2("memory");
          };
          KernelBackend3.prototype.floatPrecision = function() {
            return notYetImplemented2("floatPrecision");
          };
          KernelBackend3.prototype.epsilon = function() {
            return this.floatPrecision() === 32 ? EPSILON_FLOAT323 : EPSILON_FLOAT163;
          };
          KernelBackend3.prototype.dispose = function() {
            return notYetImplemented2("dispose");
          };
          return KernelBackend3;
        }();
        function notYetImplemented2(kernelName) {
          throw new Error("'" + kernelName + "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen");
        }
        function shuffle2(array) {
          var counter = array.length;
          var temp = 0;
          var index2 = 0;
          while (counter > 0) {
            index2 = Math.random() * counter | 0;
            counter--;
            temp = array[counter];
            array[counter] = array[index2];
            array[index2] = temp;
          }
        }
        function shuffleCombo2(array, array2) {
          if (array.length !== array2.length) {
            throw new Error("Array sizes must match to be shuffled together " + ("First array length was " + array.length) + ("Second array length was " + array2.length));
          }
          var counter = array.length;
          var temp, temp2;
          var index2 = 0;
          while (counter > 0) {
            index2 = Math.random() * counter | 0;
            counter--;
            temp = array[counter];
            temp2 = array2[counter];
            array[counter] = array[index2];
            array2[counter] = array2[index2];
            array[index2] = temp;
            array2[index2] = temp2;
          }
        }
        function clamp3(min3, x, max3) {
          return Math.max(min3, Math.min(x, max3));
        }
        function nearestLargerEven2(val) {
          return val % 2 === 0 ? val : val + 1;
        }
        function sum4(arr) {
          var sum5 = 0;
          for (var i = 0; i < arr.length; i++) {
            sum5 += arr[i];
          }
          return sum5;
        }
        function randUniform2(a, b) {
          var r = Math.random();
          return b * r + (1 - r) * a;
        }
        function distSquared2(a, b) {
          var result2 = 0;
          for (var i = 0; i < a.length; i++) {
            var diff = Number(a[i]) - Number(b[i]);
            result2 += diff * diff;
          }
          return result2;
        }
        function assert2(expr, msg) {
          if (!expr) {
            throw new Error(typeof msg === "string" ? msg : msg());
          }
        }
        function assertShapesMatch2(shapeA, shapeB, errorMessagePrefix) {
          if (errorMessagePrefix === void 0) {
            errorMessagePrefix = "";
          }
          assert2(arraysEqual2(shapeA, shapeB), function() {
            return errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match");
          });
        }
        function assertNonNull2(a) {
          assert2(a != null, function() {
            return "The input to the tensor constructor must be a non-null value.";
          });
        }
        function flatten2(arr, result2, skipTypedArray) {
          if (result2 === void 0) {
            result2 = [];
          }
          if (skipTypedArray === void 0) {
            skipTypedArray = false;
          }
          if (result2 == null) {
            result2 = [];
          }
          if (Array.isArray(arr) || isTypedArray2(arr) && !skipTypedArray) {
            for (var i = 0; i < arr.length; ++i) {
              flatten2(arr[i], result2, skipTypedArray);
            }
          } else {
            result2.push(arr);
          }
          return result2;
        }
        function sizeFromShape2(shape) {
          if (shape.length === 0) {
            return 1;
          }
          var size = shape[0];
          for (var i = 1; i < shape.length; i++) {
            size *= shape[i];
          }
          return size;
        }
        function isScalarShape2(shape) {
          return shape.length === 0;
        }
        function arraysEqual2(n1, n2) {
          if (n1 === n2) {
            return true;
          }
          if (n1 == null || n2 == null) {
            return false;
          }
          if (n1.length !== n2.length) {
            return false;
          }
          for (var i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
              return false;
            }
          }
          return true;
        }
        function isInt2(a) {
          return a % 1 === 0;
        }
        function tanh3(x) {
          if (Math.tanh != null) {
            return Math.tanh(x);
          }
          if (x === Infinity) {
            return 1;
          } else if (x === -Infinity) {
            return -1;
          } else {
            var e2x = Math.exp(2 * x);
            return (e2x - 1) / (e2x + 1);
          }
        }
        function sizeToSquarishShape2(size) {
          var width = Math.ceil(Math.sqrt(size));
          return [width, Math.ceil(size / width)];
        }
        function createShuffledIndices2(n) {
          var shuffledIndices = new Uint32Array(n);
          for (var i = 0; i < n; ++i) {
            shuffledIndices[i] = i;
          }
          shuffle2(shuffledIndices);
          return shuffledIndices;
        }
        function rightPad2(a, size) {
          if (size <= a.length) {
            return a;
          }
          return a + " ".repeat(size - a.length);
        }
        function repeatedTry2(checkFn, delayFn, maxCounter) {
          if (delayFn === void 0) {
            delayFn = function(counter) {
              return 0;
            };
          }
          return new Promise(function(resolve, reject) {
            var tryCount = 0;
            var tryFn = function() {
              if (checkFn()) {
                resolve();
                return;
              }
              tryCount++;
              var nextBackoff = delayFn(tryCount);
              if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
              }
              setTimeout(tryFn, nextBackoff);
            };
            tryFn();
          });
        }
        function inferFromImplicitShape2(shape, size) {
          var shapeProd = 1;
          var implicitIdx = -1;
          for (var i = 0; i < shape.length; ++i) {
            if (shape[i] >= 0) {
              shapeProd *= shape[i];
            } else if (shape[i] === -1) {
              if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " + ("Found -1 at dim " + implicitIdx + " and dim " + i));
              }
              implicitIdx = i;
            } else if (shape[i] < 0) {
              throw Error("Shapes can not be < 0. Found " + shape[i] + " at dim " + i);
            }
          }
          if (implicitIdx === -1) {
            if (size > 0 && size !== shapeProd) {
              throw Error("Size(" + size + ") must match the product of shape " + shape);
            }
            return shape;
          }
          if (shapeProd === 0) {
            throw Error("Cannot infer the missing size in [" + shape + "] when there are 0 elements");
          }
          if (size % shapeProd !== 0) {
            throw Error("The implicit shape can't be a fractional number. " + ("Got " + size + " / " + shapeProd));
          }
          var newShape = shape.slice();
          newShape[implicitIdx] = size / shapeProd;
          return newShape;
        }
        function parseAxisParam2(axis, shape) {
          var rank = shape.length;
          axis = axis == null ? shape.map(function(s, i) {
            return i;
          }) : [].concat(axis);
          assert2(axis.every(function(ax) {
            return ax >= -rank && ax < rank;
          }), function() {
            return "All values in axis param must be in range [-" + rank + ", " + rank + ") but " + ("got axis " + axis);
          });
          assert2(axis.every(function(ax) {
            return isInt2(ax);
          }), function() {
            return "All values in axis param must be integers but " + ("got axis " + axis);
          });
          return axis.map(function(a) {
            return a < 0 ? rank + a : a;
          });
        }
        function squeezeShape2(shape, axis) {
          var newShape = [];
          var keptDims = [];
          var isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
          var axes = axis == null || isEmptyArray ? null : parseAxisParam2(axis, shape).sort();
          var j = 0;
          for (var i = 0; i < shape.length; ++i) {
            if (axes != null) {
              if (axes[j] === i && shape[i] !== 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
              }
              if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
              }
              if (axes[j] <= i) {
                j++;
              }
            }
            if (shape[i] !== 1) {
              newShape.push(shape[i]);
              keptDims.push(i);
            }
          }
          return { newShape, keptDims };
        }
        function getTypedArrayFromDType2(dtype, size) {
          var values = null;
          if (dtype == null || dtype === "float32") {
            values = new Float32Array(size);
          } else if (dtype === "int32") {
            values = new Int32Array(size);
          } else if (dtype === "bool") {
            values = new Uint8Array(size);
          } else {
            throw new Error("Unknown data type " + dtype);
          }
          return values;
        }
        function getArrayFromDType2(dtype, size) {
          var values = null;
          if (dtype == null || dtype === "float32") {
            values = new Float32Array(size);
          } else if (dtype === "int32") {
            values = new Int32Array(size);
          } else if (dtype === "bool") {
            values = new Uint8Array(size);
          } else if (dtype === "string") {
            values = new Array(size);
          } else {
            throw new Error("Unknown data type " + dtype);
          }
          return values;
        }
        function checkConversionForErrors2(vals, dtype) {
          for (var i = 0; i < vals.length; i++) {
            var num = vals[i];
            if (isNaN(num) || !isFinite(num)) {
              throw Error("A tensor of type " + dtype + " being uploaded contains " + num + ".");
            }
          }
        }
        function isValidDtype2(dtype) {
          return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
        }
        function hasEncodingLoss2(oldType, newType) {
          if (newType === "complex64") {
            return false;
          }
          if (newType === "float32" && oldType !== "complex64") {
            return false;
          }
          if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
            return false;
          }
          if (newType === "bool" && oldType === "bool") {
            return false;
          }
          return true;
        }
        function isTypedArray2(a) {
          return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;
        }
        function bytesPerElement2(dtype) {
          if (dtype === "float32" || dtype === "int32") {
            return 4;
          } else if (dtype === "complex64") {
            return 8;
          } else if (dtype === "bool") {
            return 1;
          } else {
            throw new Error("Unknown dtype " + dtype);
          }
        }
        function bytesFromStringArray2(arr) {
          if (arr == null) {
            return 0;
          }
          var bytes = 0;
          arr.forEach(function(x) {
            return bytes += x.length;
          });
          return bytes;
        }
        function isString3(value) {
          return typeof value === "string" || value instanceof String;
        }
        function isBoolean3(value) {
          return typeof value === "boolean";
        }
        function isNumber3(value) {
          return typeof value === "number";
        }
        function inferDtype2(values) {
          if (Array.isArray(values)) {
            return inferDtype2(values[0]);
          }
          if (values instanceof Float32Array) {
            return "float32";
          } else if (values instanceof Int32Array || values instanceof Uint8Array) {
            return "int32";
          } else if (isNumber3(values)) {
            return "float32";
          } else if (isString3(values)) {
            return "string";
          } else if (isBoolean3(values)) {
            return "bool";
          }
          return "float32";
        }
        function isFunction3(f) {
          return !!(f && f.constructor && f.call && f.apply);
        }
        function nearestDivisor2(size, start) {
          for (var i = start; i < size; ++i) {
            if (size % i === 0) {
              return i;
            }
          }
          return size;
        }
        function computeStrides2(shape) {
          var rank = shape.length;
          if (rank < 2) {
            return [];
          }
          var strides = new Array(rank - 1);
          strides[rank - 2] = shape[rank - 1];
          for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
          }
          return strides;
        }
        function createNestedArray2(offset, shape, a, isComplex) {
          if (isComplex === void 0) {
            isComplex = false;
          }
          var ret = new Array();
          if (shape.length === 1) {
            var d = shape[0] * (isComplex ? 2 : 1);
            for (var i = 0; i < d; i++) {
              ret[i] = a[offset + i];
            }
          } else {
            var d = shape[0];
            var rest = shape.slice(1);
            var len = rest.reduce(function(acc, c) {
              return acc * c;
            }) * (isComplex ? 2 : 1);
            for (var i = 0; i < d; i++) {
              ret[i] = createNestedArray2(offset + i * len, rest, a, isComplex);
            }
          }
          return ret;
        }
        function toNestedArray2(shape, a, isComplex) {
          if (isComplex === void 0) {
            isComplex = false;
          }
          if (shape.length === 0) {
            return a[0];
          }
          var size = shape.reduce(function(acc, c) {
            return acc * c;
          }) * (isComplex ? 2 : 1);
          if (size === 0) {
            return [];
          }
          if (size !== a.length) {
            throw new Error("[" + shape + "] does not match the input size " + a.length + (isComplex ? " for a complex tensor" : "") + ".");
          }
          return createNestedArray2(0, shape, a, isComplex);
        }
        function makeOnesTypedArray2(size, dtype) {
          var array = makeZerosTypedArray2(size, dtype);
          for (var i = 0; i < array.length; i++) {
            array[i] = 1;
          }
          return array;
        }
        function makeZerosTypedArray2(size, dtype) {
          if (dtype == null || dtype === "float32" || dtype === "complex64") {
            return new Float32Array(size);
          } else if (dtype === "int32") {
            return new Int32Array(size);
          } else if (dtype === "bool") {
            return new Uint8Array(size);
          } else {
            throw new Error("Unknown data type " + dtype);
          }
        }
        function makeZerosNestedTypedArray2(shape, dtype) {
          var size = shape.reduce(function(prev, curr) {
            return prev * curr;
          }, 1);
          if (dtype == null || dtype === "float32") {
            return toNestedArray2(shape, new Float32Array(size));
          } else if (dtype === "int32") {
            return toNestedArray2(shape, new Int32Array(size));
          } else if (dtype === "bool") {
            return toNestedArray2(shape, new Uint8Array(size));
          } else {
            throw new Error("Unknown data type " + dtype);
          }
        }
        function assertNonNegativeIntegerDimensions2(shape) {
          shape.forEach(function(dimSize) {
            assert2(Number.isInteger(dimSize) && dimSize >= 0, function() {
              return "Tensor must have a shape comprised of positive integers but got " + ("shape [" + shape + "].");
            });
          });
        }
        function locToIndex2(locs, rank, strides) {
          if (rank === 0) {
            return 0;
          } else if (rank === 1) {
            return locs[0];
          }
          var index2 = locs[locs.length - 1];
          for (var i = 0; i < locs.length - 1; ++i) {
            index2 += strides[i] * locs[i];
          }
          return index2;
        }
        function indexToLoc2(index2, rank, strides) {
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [index2];
          }
          var locs = new Array(rank);
          for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index2 / strides[i]);
            index2 -= locs[i] * strides[i];
          }
          locs[locs.length - 1] = index2;
          return locs;
        }
        function isPromise2(object) {
          return object && object.then && typeof object.then === "function";
        }
        var TENSORFLOWJS_FLAGS_PREFIX2 = "tfjsflags";
        var Environment2 = function() {
          function Environment3(global2) {
            this.global = global2;
            this.flags = {};
            this.flagRegistry = {};
            this.urlFlags = {};
            this.getQueryParams = getQueryParams2;
            this.populateURLFlags();
          }
          Environment3.prototype.setPlatform = function(platformName, platform) {
            if (this.platform != null) {
              console.warn("Platform " + this.platformName + " has already been set. " + ("Overwriting the platform with " + platform + "."));
            }
            this.platformName = platformName;
            this.platform = platform;
          };
          Environment3.prototype.registerFlag = function(flagName, evaluationFn, setHook) {
            this.flagRegistry[flagName] = { evaluationFn, setHook };
            if (this.urlFlags[flagName] != null) {
              var flagValue = this.urlFlags[flagName];
              console.warn("Setting feature override from URL " + flagName + ": " + flagValue + ".");
              this.set(flagName, flagValue);
            }
          };
          Environment3.prototype.getAsync = function(flagName) {
            return __awaiter2(this, void 0, void 0, function() {
              var _a, _b;
              return __generator2(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (flagName in this.flags) {
                      return [2, this.flags[flagName]];
                    }
                    _a = this.flags;
                    _b = flagName;
                    return [4, this.evaluateFlag(flagName)];
                  case 1:
                    _a[_b] = _c.sent();
                    return [2, this.flags[flagName]];
                }
              });
            });
          };
          Environment3.prototype.get = function(flagName) {
            if (flagName in this.flags) {
              return this.flags[flagName];
            }
            var flagValue = this.evaluateFlag(flagName);
            if (isPromise2(flagValue)) {
              throw new Error("Flag " + flagName + " cannot be synchronously evaluated. Please use getAsync() instead.");
            }
            this.flags[flagName] = flagValue;
            return this.flags[flagName];
          };
          Environment3.prototype.getNumber = function(flagName) {
            return this.get(flagName);
          };
          Environment3.prototype.getBool = function(flagName) {
            return this.get(flagName);
          };
          Environment3.prototype.getFlags = function() {
            return this.flags;
          };
          Object.defineProperty(Environment3.prototype, "features", {
            get: function() {
              return this.flags;
            },
            enumerable: true,
            configurable: true
          });
          Environment3.prototype.set = function(flagName, value) {
            if (this.flagRegistry[flagName] == null) {
              throw new Error("Cannot set flag " + flagName + " as it has not been registered.");
            }
            this.flags[flagName] = value;
            if (this.flagRegistry[flagName].setHook != null) {
              this.flagRegistry[flagName].setHook(value);
            }
          };
          Environment3.prototype.evaluateFlag = function(flagName) {
            if (this.flagRegistry[flagName] == null) {
              throw new Error("Cannot evaluate flag '" + flagName + "': no evaluation function found.");
            }
            return this.flagRegistry[flagName].evaluationFn();
          };
          Environment3.prototype.setFlags = function(flags) {
            this.flags = Object.assign({}, flags);
          };
          Environment3.prototype.reset = function() {
            this.flags = {};
            this.urlFlags = {};
            this.populateURLFlags();
          };
          Environment3.prototype.populateURLFlags = function() {
            var _this = this;
            if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
              return;
            }
            var urlParams = this.getQueryParams(this.global.location.search);
            if (TENSORFLOWJS_FLAGS_PREFIX2 in urlParams) {
              var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX2].split(",");
              keyValues.forEach(function(keyValue) {
                var _a = keyValue.split(":"), key = _a[0], value = _a[1];
                _this.urlFlags[key] = parseValue2(key, value);
              });
            }
          };
          return Environment3;
        }();
        function getQueryParams2(queryString) {
          var params = {};
          queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(s) {
            var t = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              t[_i - 1] = arguments[_i];
            }
            decodeParam2(params, t[0], t[1]);
            return t.join("=");
          });
          return params;
        }
        function decodeParam2(params, name, value) {
          params[decodeURIComponent(name)] = decodeURIComponent(value || "");
        }
        function parseValue2(flagName, value) {
          value = value.toLowerCase();
          if (value === "true" || value === "false") {
            return value === "true";
          } else if ("" + +value === value) {
            return +value;
          }
          throw new Error("Could not parse value flag value " + value + " for flag " + flagName + ".");
        }
        function env2() {
          return exports.ENV;
        }
        exports.ENV = null;
        function setEnvironmentGlobal2(environment) {
          exports.ENV = environment;
        }
        var globalNameSpace2;
        function getGlobalNamespace2() {
          if (globalNameSpace2 == null) {
            var ns = void 0;
            if (typeof window !== "undefined") {
              ns = window;
            } else if (typeof global !== "undefined") {
              ns = global;
            } else if (typeof process !== "undefined") {
              ns = process;
            } else if (typeof self !== "undefined") {
              ns = self;
            } else {
              throw new Error("Could not find a global object");
            }
            globalNameSpace2 = ns;
          }
          return globalNameSpace2;
        }
        function getGlobalMap2() {
          var ns = getGlobalNamespace2();
          if (ns._tfGlobals == null) {
            ns._tfGlobals = new Map();
          }
          return ns._tfGlobals;
        }
        function getGlobal2(key, init) {
          var globalMap = getGlobalMap2();
          if (globalMap.has(key)) {
            return globalMap.get(key);
          } else {
            var singleton = init();
            globalMap.set(key, singleton);
            return globalMap.get(key);
          }
        }
        var Abs2 = "Abs";
        var Acos2 = "Acos";
        var Acosh2 = "Acosh";
        var Add2 = "Add";
        var AddN2 = "AddN";
        var All2 = "All";
        var Any2 = "Any";
        var ArgMax2 = "ArgMax";
        var ArgMin2 = "ArgMin";
        var Asin2 = "Asin";
        var Asinh2 = "Asinh";
        var Atan3 = "Atan";
        var Atanh2 = "Atanh";
        var Atan22 = "Atan2";
        var AvgPool2 = "AvgPool";
        var AvgPoolGrad2 = "AvgPoolGrad";
        var AvgPool3D2 = "AvgPool3D";
        var AvgPool3DGrad2 = "AvgPool3DGrad";
        var BatchMatMul2 = "BatchMatMul";
        var BatchToSpaceND2 = "BatchToSpaceND";
        var Bincount2 = "Bincount";
        var BroadcastTo = "BroadcastTo";
        var Cast2 = "Cast";
        var Ceil2 = "Ceil";
        var ClipByValue2 = "ClipByValue";
        var Complex2 = "Complex";
        var ComplexAbs2 = "ComplexAbs";
        var Concat2 = "Concat";
        var Conv2D2 = "Conv2D";
        var Conv2DBackpropFilter2 = "Conv2DBackpropFilter";
        var Conv2DBackpropInput2 = "Conv2DBackpropInput";
        var Conv3D2 = "Conv3D";
        var Conv3DBackpropFilterV22 = "Conv3DBackpropFilterV2";
        var Conv3DBackpropInputV22 = "Conv3DBackpropInputV2";
        var Cos2 = "Cos";
        var Cosh2 = "Cosh";
        var Cumsum2 = "Cumsum";
        var CropAndResize2 = "CropAndResize";
        var DenseBincount2 = "DenseBincount";
        var DepthToSpace2 = "DepthToSpace";
        var DepthwiseConv2dNative2 = "DepthwiseConv2dNative";
        var DepthwiseConv2dNativeBackpropFilter2 = "DepthwiseConv2dNativeBackpropFilter";
        var DepthwiseConv2dNativeBackpropInput2 = "DepthwiseConv2dNativeBackpropInput";
        var Diag2 = "Diag";
        var Dilation2D2 = "Dilation2D";
        var Dilation2DBackpropInput = "Dilation2DBackpropInput";
        var Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
        var RealDiv2 = "RealDiv";
        var Einsum2 = "Einsum";
        var Elu2 = "Elu";
        var EluGrad2 = "EluGrad";
        var Erf2 = "Erf";
        var Equal2 = "Equal";
        var Exp2 = "Exp";
        var ExpandDims2 = "ExpandDims";
        var Expm12 = "Expm1";
        var FFT2 = "FFT";
        var Fill2 = "Fill";
        var FlipLeftRight2 = "FlipLeftRight";
        var Floor2 = "Floor";
        var FloorDiv2 = "FloorDiv";
        var FusedBatchNorm2 = "FusedBatchNorm";
        var GatherV22 = "GatherV2";
        var GatherNd2 = "GatherNd";
        var Greater2 = "Greater";
        var GreaterEqual2 = "GreaterEqual";
        var Identity2 = "Identity";
        var IFFT2 = "IFFT";
        var Imag2 = "Imag";
        var IsFinite2 = "IsFinite";
        var IsInf2 = "IsInf";
        var IsNan2 = "IsNan";
        var LeakyRelu2 = "LeakyRelu";
        var Less2 = "Less";
        var LessEqual2 = "LessEqual";
        var LinSpace2 = "LinSpace";
        var Log2 = "Log";
        var Log1p2 = "Log1p";
        var LogicalAnd2 = "LogicalAnd";
        var LogicalNot2 = "LogicalNot";
        var LogicalOr2 = "LogicalOr";
        var LogSoftmax = "LogSoftmax";
        var LRN2 = "LRN";
        var LRNGrad2 = "LRNGrad";
        var Max2 = "Max";
        var Maximum2 = "Maximum";
        var MaxPool2 = "MaxPool";
        var MaxPoolGrad2 = "MaxPoolGrad";
        var MaxPool3D2 = "MaxPool3D";
        var MaxPool3DGrad2 = "MaxPool3DGrad";
        var MaxPoolWithArgmax2 = "MaxPoolWithArgmax";
        var Mean2 = "Mean";
        var Min2 = "Min";
        var Minimum2 = "Minimum";
        var MirrorPad2 = "MirrorPad";
        var Mod2 = "Mod";
        var Multinomial2 = "Multinomial";
        var Multiply2 = "Multiply";
        var Neg2 = "Neg";
        var NotEqual2 = "NotEqual";
        var NonMaxSuppressionV32 = "NonMaxSuppressionV3";
        var NonMaxSuppressionV42 = "NonMaxSuppressionV4";
        var NonMaxSuppressionV52 = "NonMaxSuppressionV5";
        var OnesLike2 = "OnesLike";
        var OneHot2 = "OneHot";
        var Pack2 = "Pack";
        var PadV22 = "PadV2";
        var Pool = "Pool";
        var Pow2 = "Pow";
        var Prelu2 = "Prelu";
        var Prod2 = "Prod";
        var Range2 = "Range";
        var Real2 = "Real";
        var Reciprocal2 = "Reciprocal";
        var Relu2 = "Relu";
        var Reshape2 = "Reshape";
        var ResizeNearestNeighbor2 = "ResizeNearestNeighbor";
        var ResizeNearestNeighborGrad2 = "ResizeNearestNeighborGrad";
        var ResizeBilinear2 = "ResizeBilinear";
        var ResizeBilinearGrad2 = "ResizeBilinearGrad";
        var Relu62 = "Relu6";
        var Reverse2 = "Reverse";
        var Round2 = "Round";
        var Rsqrt2 = "Rsqrt";
        var ScatterNd2 = "ScatterNd";
        var Select2 = "Select";
        var Selu2 = "Selu";
        var Slice2 = "Slice";
        var Sin2 = "Sin";
        var Sinh2 = "Sinh";
        var Sign2 = "Sign";
        var Sigmoid2 = "Sigmoid";
        var Softplus2 = "Softplus";
        var Sqrt2 = "Sqrt";
        var Sum2 = "Sum";
        var SpaceToBatchND2 = "SpaceToBatchND";
        var SplitV2 = "SplitV";
        var Softmax2 = "Softmax";
        var SparseFillEmptyRows2 = "SparseFillEmptyRows";
        var SparseReshape2 = "SparseReshape";
        var SparseToDense2 = "SparseToDense";
        var SquaredDifference2 = "SquaredDifference";
        var Square2 = "Square";
        var StridedSlice2 = "StridedSlice";
        var Sub2 = "Sub";
        var Tan2 = "Tan";
        var Tanh2 = "Tanh";
        var Tile2 = "Tile";
        var TopK2 = "TopK";
        var Transform2 = "Transform";
        var Transpose2 = "Transpose";
        var Unique2 = "Unique";
        var Unpack2 = "Unpack";
        var UnsortedSegmentSum2 = "UnsortedSegmentSum";
        var ZerosLike2 = "ZerosLike";
        var Step2 = "Step";
        var FromPixels2 = "FromPixels";
        var RotateWithOffset2 = "RotateWithOffset";
        var _FusedMatMul2 = "_FusedMatMul";
        var FusedConv2D2 = "FusedConv2D";
        var FusedDepthwiseConv2D2 = "FusedDepthwiseConv2D";
        var kernelRegistry2 = getGlobal2("kernelRegistry", function() {
          return new Map();
        });
        var gradRegistry2 = getGlobal2("gradRegistry", function() {
          return new Map();
        });
        function getKernel2(kernelName, backendName) {
          var key = makeKey2(kernelName, backendName);
          return kernelRegistry2.get(key);
        }
        function getGradient2(kernelName) {
          return gradRegistry2.get(kernelName);
        }
        function getKernelsForBackend2(backendName) {
          var it = kernelRegistry2.entries();
          var result2 = [];
          while (true) {
            var _a = it.next(), done = _a.done, value = _a.value;
            if (done) {
              break;
            }
            var key = value[0], config = value[1];
            var backend2 = key.split("_")[0];
            if (backend2 === backendName) {
              result2.push(config);
            }
          }
          return result2;
        }
        function registerKernel2(config) {
          var kernelName = config.kernelName, backendName = config.backendName;
          var key = makeKey2(kernelName, backendName);
          if (kernelRegistry2.has(key)) {
            console.warn("The kernel '" + kernelName + "' for backend " + ("'" + backendName + "' is already registered"));
          }
          kernelRegistry2.set(key, config);
        }
        function registerGradient(config) {
          var kernelName = config.kernelName;
          if (gradRegistry2.has(kernelName)) {
            if (env2().getBool("DEBUG")) {
              console.warn("Overriding the gradient for '" + kernelName + "'");
            }
          }
          gradRegistry2.set(kernelName, config);
        }
        function unregisterKernel(kernelName, backendName) {
          var key = makeKey2(kernelName, backendName);
          if (!kernelRegistry2.has(key)) {
            throw new Error("The kernel '" + kernelName + "' for backend " + ("'" + backendName + "' is not registered"));
          }
          kernelRegistry2.delete(key);
        }
        function unregisterGradient(kernelName) {
          if (!gradRegistry2.has(kernelName)) {
            throw new Error("The gradient '" + kernelName + "' for backend is not registered");
          }
          gradRegistry2.delete(kernelName);
        }
        function copyRegisteredKernels(registeredBackendName, newBackendName) {
          var kernels = getKernelsForBackend2(registeredBackendName);
          kernels.forEach(function(kernelConfig) {
            var newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });
            registerKernel2(newKernelConfig);
          });
        }
        function makeKey2(kernelName, backendName) {
          return backendName + "_" + kernelName;
        }
        function createScalarValue2(value, dtype) {
          if (dtype === "string") {
            return encodeString2(value);
          }
          return toTypedArray2([value], dtype);
        }
        function noConversionNeeded2(a, dtype) {
          return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
        }
        function toTypedArray2(a, dtype) {
          if (dtype === "string") {
            throw new Error("Cannot convert a string[] to a TypedArray");
          }
          if (Array.isArray(a)) {
            a = flatten2(a);
          }
          if (env2().getBool("DEBUG")) {
            checkConversionForErrors2(a, dtype);
          }
          if (noConversionNeeded2(a, dtype)) {
            return a;
          }
          if (dtype == null || dtype === "float32" || dtype === "complex64") {
            return new Float32Array(a);
          } else if (dtype === "int32") {
            return new Int32Array(a);
          } else if (dtype === "bool") {
            var bool = new Uint8Array(a.length);
            for (var i = 0; i < bool.length; ++i) {
              if (Math.round(a[i]) !== 0) {
                bool[i] = 1;
              }
            }
            return bool;
          } else {
            throw new Error("Unknown data type " + dtype);
          }
        }
        function now2() {
          return env2().platform.now();
        }
        function fetch$1(path, requestInits) {
          return env2().platform.fetch(path, requestInits);
        }
        function encodeString2(s, encoding) {
          if (encoding === void 0) {
            encoding = "utf-8";
          }
          encoding = encoding || "utf-8";
          return env2().platform.encode(s, encoding);
        }
        function decodeString2(bytes, encoding) {
          if (encoding === void 0) {
            encoding = "utf-8";
          }
          encoding = encoding || "utf-8";
          return env2().platform.decode(bytes, encoding);
        }
        var util12 = {
          __proto__: null,
          createScalarValue: createScalarValue2,
          toTypedArray: toTypedArray2,
          now: now2,
          fetch: fetch$1,
          encodeString: encodeString2,
          decodeString: decodeString2,
          shuffle: shuffle2,
          shuffleCombo: shuffleCombo2,
          clamp: clamp3,
          nearestLargerEven: nearestLargerEven2,
          sum: sum4,
          randUniform: randUniform2,
          distSquared: distSquared2,
          assert: assert2,
          assertShapesMatch: assertShapesMatch2,
          assertNonNull: assertNonNull2,
          flatten: flatten2,
          sizeFromShape: sizeFromShape2,
          isScalarShape: isScalarShape2,
          arraysEqual: arraysEqual2,
          isInt: isInt2,
          tanh: tanh3,
          sizeToSquarishShape: sizeToSquarishShape2,
          createShuffledIndices: createShuffledIndices2,
          rightPad: rightPad2,
          repeatedTry: repeatedTry2,
          inferFromImplicitShape: inferFromImplicitShape2,
          parseAxisParam: parseAxisParam2,
          squeezeShape: squeezeShape2,
          getTypedArrayFromDType: getTypedArrayFromDType2,
          getArrayFromDType: getArrayFromDType2,
          checkConversionForErrors: checkConversionForErrors2,
          isValidDtype: isValidDtype2,
          hasEncodingLoss: hasEncodingLoss2,
          isTypedArray: isTypedArray2,
          bytesPerElement: bytesPerElement2,
          bytesFromStringArray: bytesFromStringArray2,
          isString: isString3,
          isBoolean: isBoolean3,
          isNumber: isNumber3,
          inferDtype: inferDtype2,
          isFunction: isFunction3,
          nearestDivisor: nearestDivisor2,
          computeStrides: computeStrides2,
          toNestedArray: toNestedArray2,
          makeOnesTypedArray: makeOnesTypedArray2,
          makeZerosTypedArray: makeZerosTypedArray2,
          makeZerosNestedTypedArray: makeZerosNestedTypedArray2,
          assertNonNegativeIntegerDimensions: assertNonNegativeIntegerDimensions2,
          locToIndex: locToIndex2,
          indexToLoc: indexToLoc2,
          isPromise: isPromise2
        };
        var Profiler2 = function() {
          function Profiler3(backendTimer, logger) {
            this.backendTimer = backendTimer;
            this.logger = logger;
            if (logger == null) {
              this.logger = new Logger2();
            }
          }
          Profiler3.prototype.profileKernel = function(kernelName, inputs, f) {
            var outputs;
            var holdResultWrapperFn = function() {
              outputs = f();
            };
            var timer;
            var start = now2();
            if (this.backendTimer.timerAvailable()) {
              timer = this.backendTimer.time(holdResultWrapperFn);
            } else {
              holdResultWrapperFn();
              for (var _i = 0, outputs_1 = outputs; _i < outputs_1.length; _i++) {
                var output = outputs_1[_i];
                output.dataSync();
              }
              timer = Promise.resolve({ kernelMs: now2() - start });
            }
            if (env2().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
              var _loop_1 = function(i2) {
                var output2 = outputs[i2];
                output2.data().then(function(tensorVals) {
                  checkComputationForErrors2(tensorVals, output2.dtype, kernelName);
                });
              };
              for (var i = 0; i < outputs.length; i++) {
                _loop_1(i);
              }
            }
            var kernelProfile = {
              kernelName,
              outputs,
              inputs,
              timeMs: timer.then(function(timing) {
                return timing.kernelMs;
              }),
              extraInfo: timer.then(function(timing) {
                return timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "";
              })
            };
            return kernelProfile;
          };
          Profiler3.prototype.logKernelProfile = function(kernelProfile) {
            var _this = this;
            var kernelName = kernelProfile.kernelName, outputs = kernelProfile.outputs, timeMs = kernelProfile.timeMs, inputs = kernelProfile.inputs, extraInfo = kernelProfile.extraInfo;
            outputs.forEach(function(result2) {
              Promise.all([result2.data(), timeMs, extraInfo]).then(function(valueContainer) {
                _this.logger.logKernelProfile(kernelName, result2, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
              });
            });
          };
          return Profiler3;
        }();
        function checkComputationForErrors2(vals, dtype, kernelName) {
          if (dtype !== "float32") {
            return false;
          }
          for (var i = 0; i < vals.length; i++) {
            var num = vals[i];
            if (isNaN(num) || !isFinite(num)) {
              console.warn("Found " + num + " in the result of '" + kernelName + "'");
              return true;
            }
          }
          return false;
        }
        var Logger2 = function() {
          function Logger3() {
          }
          Logger3.prototype.logKernelProfile = function(name, result2, vals, timeMs, inputs, extraInfo) {
            var time2 = typeof timeMs === "number" ? rightPad2(timeMs + "ms", 9) : timeMs["error"];
            var paddedName = rightPad2(name, 25);
            var rank = result2.rank;
            var size = result2.size;
            var shape = rightPad2(result2.shape.toString(), 14);
            var inputShapesDescription = "";
            for (var name_1 in inputs) {
              var input = inputs[name_1];
              if (input != null) {
                var inputShape = input.shape || result2.shape;
                var inputRank = inputShape.length;
                inputShapesDescription += name_1 + ": " + inputRank + "D " + (inputRank > 0 ? inputShape : "") + " ";
              }
            }
            console.log("%c" + paddedName + "	%c" + time2 + "	%c" + rank + "D " + shape + "	%c" + size + "	%c" + inputShapesDescription + "	%c" + extraInfo, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
          };
          return Logger3;
        }();
        function getFilteredNodesXToY2(tape, xs, y) {
          var tensorsFromX = {};
          var nodesFromX = {};
          for (var i = 0; i < xs.length; i++) {
            tensorsFromX[xs[i].id] = true;
          }
          for (var i = 0; i < tape.length; i++) {
            var node = tape[i];
            var nodeInputs = node.inputs;
            for (var inputName in nodeInputs) {
              var input = nodeInputs[inputName];
              var anyInputFromX = false;
              for (var j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                  node.outputs.forEach(function(output) {
                    return tensorsFromX[output.id] = true;
                  });
                  anyInputFromX = true;
                  nodesFromX[node.id] = true;
                  break;
                }
              }
              if (anyInputFromX) {
                break;
              }
            }
          }
          var tensorsLeadToY = {};
          tensorsLeadToY[y.id] = true;
          var nodesToY = {};
          for (var i = tape.length - 1; i >= 0; i--) {
            var node = tape[i];
            var nodeInputs = node.inputs;
            for (var j = 0; j < node.outputs.length; j++) {
              if (tensorsLeadToY[node.outputs[j].id]) {
                for (var inputName in nodeInputs) {
                  tensorsLeadToY[nodeInputs[inputName].id] = true;
                  nodesToY[node.id] = true;
                }
                break;
              }
            }
          }
          var filteredTape = [];
          for (var i = 0; i < tape.length; i++) {
            var node = tape[i];
            if (nodesFromX[node.id] && nodesToY[node.id]) {
              var prunedInputs = {};
              for (var inputName in node.inputs) {
                var nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                  prunedInputs[inputName] = nodeInput;
                }
              }
              var prunedNode = Object.assign({}, node);
              prunedNode.inputs = prunedInputs;
              prunedNode.outputs = node.outputs;
              filteredTape.push(prunedNode);
            }
          }
          return filteredTape;
        }
        function backpropagateGradients2(tensorAccumulatedGradientMap, filteredTape, tidy4, add6) {
          var _loop_1 = function(i2) {
            var node = filteredTape[i2];
            var dys = [];
            node.outputs.forEach(function(o) {
              var gradTensor = tensorAccumulatedGradientMap[o.id];
              if (gradTensor != null) {
                dys.push(gradTensor);
              } else {
                dys.push(null);
              }
            });
            if (node.gradient == null) {
              throw new Error("Cannot compute gradient: gradient function not found " + ("for " + node.kernelName + "."));
            }
            var inputGradients = node.gradient(dys);
            var _loop_2 = function(inputName2) {
              if (!(inputName2 in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName2 + ". " + ("Available gradients found: " + Object.keys(inputGradients) + "."));
              }
              var dx = tidy4(function() {
                return inputGradients[inputName2]();
              });
              if (dx.dtype !== "float32") {
                throw new Error("Error in gradient for op " + node.kernelName + ". The gradient of input " + (inputName2 + " must have 'float32' dtype, but has '" + dx.dtype + "'"));
              }
              var x = node.inputs[inputName2];
              if (!arraysEqual2(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.kernelName + ". The gradient of input " + ("'" + inputName2 + "' has shape '" + dx.shape + "', which does not match ") + ("the shape of the input '" + x.shape + "'"));
              }
              if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
              } else {
                var curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = add6(curGradient, dx);
                curGradient.dispose();
              }
            };
            for (var inputName in node.inputs) {
              _loop_2(inputName);
            }
          };
          for (var i = filteredTape.length - 1; i >= 0; i--) {
            _loop_1(i);
          }
        }
        var FORMAT_LIMIT_NUM_VALS2 = 20;
        var FORMAT_NUM_FIRST_LAST_VALS2 = 3;
        var FORMAT_NUM_SIG_DIGITS2 = 7;
        function tensorToString2(vals, shape, dtype, verbose) {
          var strides = computeStrides2(shape);
          var padPerCol = computeMaxSizePerColumn2(vals, shape, dtype, strides);
          var rank = shape.length;
          var valsLines = subTensorToString2(vals, shape, dtype, strides, padPerCol);
          var lines = ["Tensor"];
          if (verbose) {
            lines.push("  dtype: " + dtype);
            lines.push("  rank: " + rank);
            lines.push("  shape: [" + shape + "]");
            lines.push("  values:");
          }
          lines.push(valsLines.map(function(l) {
            return "    " + l;
          }).join("\n"));
          return lines.join("\n");
        }
        function computeMaxSizePerColumn2(vals, shape, dtype, strides) {
          var n = sizeFromShape2(shape);
          var numCols = strides[strides.length - 1];
          var padPerCol = new Array(numCols).fill(0);
          var rank = shape.length;
          var valuesOrTuples = dtype === "complex64" ? createComplexTuples2(vals) : vals;
          if (rank > 1) {
            for (var row = 0; row < n / numCols; row++) {
              var offset = row * numCols;
              for (var j = 0; j < numCols; j++) {
                padPerCol[j] = Math.max(padPerCol[j], valToString2(valuesOrTuples[offset + j], 0, dtype).length);
              }
            }
          }
          return padPerCol;
        }
        function valToString2(val, pad2, dtype) {
          var valStr;
          if (Array.isArray(val)) {
            valStr = parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS2)) + " + " + (parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS2)) + "j");
          } else if (isString3(val)) {
            valStr = "'" + val + "'";
          } else if (dtype === "bool") {
            valStr = boolNumToString2(val);
          } else {
            valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS2)).toString();
          }
          return rightPad2(valStr, pad2);
        }
        function boolNumToString2(v) {
          return v === 0 ? "false" : "true";
        }
        function subTensorToString2(vals, shape, dtype, strides, padPerCol, isLast) {
          if (isLast === void 0) {
            isLast = true;
          }
          var storagePerElement = dtype === "complex64" ? 2 : 1;
          var size = shape[0];
          var rank = shape.length;
          if (rank === 0) {
            if (dtype === "complex64") {
              var complexTuple = createComplexTuples2(vals);
              return [valToString2(complexTuple[0], 0, dtype)];
            }
            if (dtype === "bool") {
              return [boolNumToString2(vals[0])];
            }
            return [vals[0].toString()];
          }
          if (rank === 1) {
            if (size > FORMAT_LIMIT_NUM_VALS2) {
              var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS2 * storagePerElement;
              var firstVals = Array.from(vals.slice(0, firstValsSize));
              var lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS2) * storagePerElement, size * storagePerElement));
              if (dtype === "complex64") {
                firstVals = createComplexTuples2(firstVals);
                lastVals = createComplexTuples2(lastVals);
              }
              return [
                "[" + firstVals.map(function(x, i2) {
                  return valToString2(x, padPerCol[i2], dtype);
                }).join(", ") + ", ..., " + lastVals.map(function(x, i2) {
                  return valToString2(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS2 + i2], dtype);
                }).join(", ") + "]"
              ];
            }
            var displayVals = dtype === "complex64" ? createComplexTuples2(vals) : Array.from(vals);
            return [
              "[" + displayVals.map(function(x, i2) {
                return valToString2(x, padPerCol[i2], dtype);
              }).join(", ") + "]"
            ];
          }
          var subshape = shape.slice(1);
          var substrides = strides.slice(1);
          var stride = strides[0] * storagePerElement;
          var lines = [];
          if (size > FORMAT_LIMIT_NUM_VALS2) {
            for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS2; i++) {
              var start = i * stride;
              var end = start + stride;
              lines.push.apply(lines, subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
            }
            lines.push("...");
            for (var i = size - FORMAT_NUM_FIRST_LAST_VALS2; i < size; i++) {
              var start = i * stride;
              var end = start + stride;
              lines.push.apply(lines, subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
            }
          } else {
            for (var i = 0; i < size; i++) {
              var start = i * stride;
              var end = start + stride;
              lines.push.apply(lines, subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
            }
          }
          var sep = rank === 2 ? "," : "";
          lines[0] = "[" + lines[0] + sep;
          for (var i = 1; i < lines.length - 1; i++) {
            lines[i] = " " + lines[i] + sep;
          }
          var newLineSep = ",\n";
          for (var i = 2; i < rank; i++) {
            newLineSep += "\n";
          }
          lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
          return lines;
        }
        function createComplexTuples2(vals) {
          var complexTuples = [];
          for (var i = 0; i < vals.length; i += 2) {
            complexTuples.push([vals[i], vals[i + 1]]);
          }
          return complexTuples;
        }
        var TensorBuffer2 = function() {
          function TensorBuffer3(shape, dtype, values) {
            var _this = this;
            this.dtype = dtype;
            this.shape = shape.slice();
            this.size = sizeFromShape2(shape);
            if (values != null) {
              var n_1 = values.length;
              assert2(n_1 === this.size, function() {
                return "Length of values '" + n_1 + "' does not match the size " + ("inferred by the shape '" + _this.size + "'.");
              });
            }
            if (dtype === "complex64") {
              throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
            }
            this.values = values || getArrayFromDType2(dtype, this.size);
            this.strides = computeStrides2(shape);
          }
          TensorBuffer3.prototype.set = function(value) {
            var _this = this;
            var locs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              locs[_i - 1] = arguments[_i];
            }
            if (locs.length === 0) {
              locs = [0];
            }
            assert2(locs.length === this.rank, function() {
              return "The number of provided coordinates (" + locs.length + ") must " + ("match the rank (" + _this.rank + ")");
            });
            var index2 = this.locToIndex(locs);
            this.values[index2] = value;
          };
          TensorBuffer3.prototype.get = function() {
            var locs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              locs[_i] = arguments[_i];
            }
            if (locs.length === 0) {
              locs = [0];
            }
            var i = 0;
            for (var _a = 0, locs_1 = locs; _a < locs_1.length; _a++) {
              var loc = locs_1[_a];
              if (loc < 0 || loc >= this.shape[i]) {
                var msg = "Requested out of range element at " + locs + ". " + ("  Buffer shape=" + this.shape);
                throw new Error(msg);
              }
              i++;
            }
            var index2 = locs[locs.length - 1];
            for (var i_1 = 0; i_1 < locs.length - 1; ++i_1) {
              index2 += this.strides[i_1] * locs[i_1];
            }
            return this.values[index2];
          };
          TensorBuffer3.prototype.locToIndex = function(locs) {
            if (this.rank === 0) {
              return 0;
            } else if (this.rank === 1) {
              return locs[0];
            }
            var index2 = locs[locs.length - 1];
            for (var i = 0; i < locs.length - 1; ++i) {
              index2 += this.strides[i] * locs[i];
            }
            return index2;
          };
          TensorBuffer3.prototype.indexToLoc = function(index2) {
            if (this.rank === 0) {
              return [];
            } else if (this.rank === 1) {
              return [index2];
            }
            var locs = new Array(this.shape.length);
            for (var i = 0; i < locs.length - 1; ++i) {
              locs[i] = Math.floor(index2 / this.strides[i]);
              index2 -= locs[i] * this.strides[i];
            }
            locs[locs.length - 1] = index2;
            return locs;
          };
          Object.defineProperty(TensorBuffer3.prototype, "rank", {
            get: function() {
              return this.shape.length;
            },
            enumerable: true,
            configurable: true
          });
          TensorBuffer3.prototype.toTensor = function() {
            return trackerFn2().makeTensor(this.values, this.shape, this.dtype);
          };
          return TensorBuffer3;
        }();
        var trackerFn2 = null;
        var opHandler3 = null;
        function setTensorTracker2(fn) {
          trackerFn2 = fn;
        }
        function setOpHandler2(handler) {
          opHandler3 = handler;
        }
        var Tensor3 = function() {
          function Tensor4(shape, dtype, dataId, id) {
            this.kept = false;
            this.isDisposedInternal = false;
            this.shape = shape.slice();
            this.dtype = dtype || "float32";
            this.size = sizeFromShape2(shape);
            this.strides = computeStrides2(shape);
            this.dataId = dataId;
            this.id = id;
            this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
          }
          Object.defineProperty(Tensor4.prototype, "rank", {
            get: function() {
              return this.shape.length;
            },
            enumerable: true,
            configurable: true
          });
          Tensor4.prototype.buffer = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var vals;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.data()];
                  case 1:
                    vals = _a.sent();
                    return [2, opHandler3.buffer(this.shape, this.dtype, vals)];
                }
              });
            });
          };
          Tensor4.prototype.bufferSync = function() {
            return opHandler3.buffer(this.shape, this.dtype, this.dataSync());
          };
          Tensor4.prototype.array = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var vals;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.data()];
                  case 1:
                    vals = _a.sent();
                    return [2, toNestedArray2(this.shape, vals, this.dtype === "complex64")];
                }
              });
            });
          };
          Tensor4.prototype.arraySync = function() {
            return toNestedArray2(this.shape, this.dataSync(), this.dtype === "complex64");
          };
          Tensor4.prototype.data = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var data, bytes;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.throwIfDisposed();
                    data = trackerFn2().read(this.dataId);
                    if (!(this.dtype === "string"))
                      return [3, 2];
                    return [4, data];
                  case 1:
                    bytes = _a.sent();
                    try {
                      return [2, bytes.map(function(b) {
                        return decodeString2(b);
                      })];
                    } catch (_b) {
                      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                    }
                    _a.label = 2;
                  case 2:
                    return [2, data];
                }
              });
            });
          };
          Tensor4.prototype.dataSync = function() {
            this.throwIfDisposed();
            var data = trackerFn2().readSync(this.dataId);
            if (this.dtype === "string") {
              try {
                return data.map(function(b) {
                  return decodeString2(b);
                });
              } catch (_a) {
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
              }
            }
            return data;
          };
          Tensor4.prototype.bytes = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var data;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.throwIfDisposed();
                    return [4, trackerFn2().read(this.dataId)];
                  case 1:
                    data = _a.sent();
                    if (this.dtype === "string") {
                      return [2, data];
                    } else {
                      return [2, new Uint8Array(data.buffer)];
                    }
                }
              });
            });
          };
          Tensor4.prototype.dispose = function() {
            if (this.isDisposed) {
              return;
            }
            trackerFn2().disposeTensor(this);
            this.isDisposedInternal = true;
          };
          Object.defineProperty(Tensor4.prototype, "isDisposed", {
            get: function() {
              return this.isDisposedInternal;
            },
            enumerable: true,
            configurable: true
          });
          Tensor4.prototype.throwIfDisposed = function() {
            if (this.isDisposed) {
              throw new Error("Tensor is disposed.");
            }
          };
          Tensor4.prototype.print = function(verbose) {
            if (verbose === void 0) {
              verbose = false;
            }
            return opHandler3.print(this, verbose);
          };
          Tensor4.prototype.clone = function() {
            this.throwIfDisposed();
            return opHandler3.clone(this);
          };
          Tensor4.prototype.toString = function(verbose) {
            if (verbose === void 0) {
              verbose = false;
            }
            var vals = this.dataSync();
            return tensorToString2(vals, this.shape, this.dtype, verbose);
          };
          Tensor4.prototype.cast = function(dtype) {
            this.throwIfDisposed();
            return opHandler3.cast(this, dtype);
          };
          Tensor4.prototype.variable = function(trainable, name, dtype) {
            if (trainable === void 0) {
              trainable = true;
            }
            this.throwIfDisposed();
            return trackerFn2().makeVariable(this, trainable, name, dtype);
          };
          return Tensor4;
        }();
        Object.defineProperty(Tensor3, Symbol.hasInstance, {
          value: function(instance) {
            return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
          }
        });
        function getGlobalTensorClass2() {
          return getGlobal2("Tensor", function() {
            return Tensor3;
          });
        }
        getGlobalTensorClass2();
        var Variable2 = function(_super) {
          __extends2(Variable3, _super);
          function Variable3(initialValue, trainable, name, tensorId) {
            var _this = _super.call(this, initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId) || this;
            _this.trainable = trainable;
            _this.name = name;
            return _this;
          }
          Variable3.prototype.assign = function(newValue) {
            if (newValue.dtype !== this.dtype) {
              throw new Error("dtype of the new value (" + newValue.dtype + ") and " + ("previous value (" + this.dtype + ") must match"));
            }
            if (!arraysEqual2(newValue.shape, this.shape)) {
              throw new Error("shape of the new value (" + newValue.shape + ") and " + ("previous value (" + this.shape + ") must match"));
            }
            trackerFn2().disposeTensor(this);
            this.dataId = newValue.dataId;
            trackerFn2().incRef(this, null);
          };
          Variable3.prototype.dispose = function() {
            trackerFn2().disposeVariable(this);
            this.isDisposedInternal = true;
          };
          return Variable3;
        }(Tensor3);
        Object.defineProperty(Variable2, Symbol.hasInstance, {
          value: function(instance) {
            return instance instanceof Tensor3 && instance.assign != null && instance.assign instanceof Function;
          }
        });
        (function(Rank2) {
          Rank2["R0"] = "R0";
          Rank2["R1"] = "R1";
          Rank2["R2"] = "R2";
          Rank2["R3"] = "R3";
          Rank2["R4"] = "R4";
          Rank2["R5"] = "R5";
          Rank2["R6"] = "R6";
        })(exports.Rank || (exports.Rank = {}));
        var UpcastInt32AndMap2;
        (function(UpcastInt32AndMap3) {
          UpcastInt32AndMap3["float32"] = "float32";
          UpcastInt32AndMap3["int32"] = "int32";
          UpcastInt32AndMap3["bool"] = "int32";
          UpcastInt32AndMap3["complex64"] = "complex64";
        })(UpcastInt32AndMap2 || (UpcastInt32AndMap2 = {}));
        var UpcastBoolAndMap2;
        (function(UpcastBoolAndMap3) {
          UpcastBoolAndMap3["float32"] = "float32";
          UpcastBoolAndMap3["int32"] = "int32";
          UpcastBoolAndMap3["bool"] = "bool";
          UpcastBoolAndMap3["complex64"] = "complex64";
        })(UpcastBoolAndMap2 || (UpcastBoolAndMap2 = {}));
        var UpcastFloat32AndMap2;
        (function(UpcastFloat32AndMap3) {
          UpcastFloat32AndMap3["float32"] = "float32";
          UpcastFloat32AndMap3["int32"] = "float32";
          UpcastFloat32AndMap3["bool"] = "float32";
          UpcastFloat32AndMap3["complex64"] = "complex64";
        })(UpcastFloat32AndMap2 || (UpcastFloat32AndMap2 = {}));
        var UpcastComplex64AndMap2;
        (function(UpcastComplex64AndMap3) {
          UpcastComplex64AndMap3["float32"] = "complex64";
          UpcastComplex64AndMap3["int32"] = "complex64";
          UpcastComplex64AndMap3["bool"] = "complex64";
          UpcastComplex64AndMap3["complex64"] = "complex64";
        })(UpcastComplex64AndMap2 || (UpcastComplex64AndMap2 = {}));
        var upcastTypeMap2 = {
          "float32": UpcastFloat32AndMap2,
          "int32": UpcastInt32AndMap2,
          "bool": UpcastBoolAndMap2,
          "complex64": UpcastComplex64AndMap2
        };
        function upcastType2(typeA, typeB) {
          if (typeA === "string" || typeB === "string") {
            if (typeA === "string" && typeB === "string") {
              return "string";
            }
            throw new Error("Can not upcast " + typeA + " with " + typeB);
          }
          return upcastTypeMap2[typeA][typeB];
        }
        function sumOutType2(type) {
          return upcastType2(type, "int32");
        }
        function makeTypesMatch2(a, b) {
          if (a.dtype === b.dtype) {
            return [a, b];
          }
          var dtype = upcastType2(a.dtype, b.dtype);
          return [a.cast(dtype), b.cast(dtype)];
        }
        function assertTypesMatch(a, b) {
          assert2(a.dtype === b.dtype, function() {
            return "The dtypes of the first(" + a.dtype + ") and" + (" second(" + b.dtype + ") input must match");
          });
        }
        function isTensorInList(tensor2, tensorList) {
          return tensorList.some(function(x) {
            return x.id === tensor2.id;
          });
        }
        function getTensorsInContainer2(result2) {
          var list = [];
          var seen = new Set();
          walkTensorContainer2(result2, list, seen);
          return list;
        }
        function walkTensorContainer2(container, list, seen) {
          if (container == null) {
            return;
          }
          if (container instanceof Tensor3) {
            list.push(container);
            return;
          }
          if (!isIterable2(container)) {
            return;
          }
          var iterable = container;
          for (var k in iterable) {
            var val = iterable[k];
            if (!seen.has(val)) {
              seen.add(val);
              walkTensorContainer2(val, list, seen);
            }
          }
        }
        function isIterable2(obj) {
          return Array.isArray(obj) || typeof obj === "object";
        }
        var tensor_util = {
          __proto__: null,
          makeTypesMatch: makeTypesMatch2,
          assertTypesMatch,
          isTensorInList,
          getTensorsInContainer: getTensorsInContainer2
        };
        function isRegisteredKernelInvocation2(kernelInvocation) {
          return kernelInvocation.kernelName != null;
        }
        var EngineState2 = function() {
          function EngineState3() {
            this.registeredVariables = {};
            this.nextTapeNodeId = 0;
            this.numBytes = 0;
            this.numTensors = 0;
            this.numStringTensors = 0;
            this.numDataBuffers = 0;
            this.gradientDepth = 0;
            this.kernelDepth = 0;
            this.scopeStack = [];
            this.numDataMovesStack = [];
            this.nextScopeId = 0;
            this.tensorInfo = new WeakMap();
            this.profiling = false;
            this.activeProfile = {
              newBytes: 0,
              newTensors: 0,
              peakBytes: 0,
              kernels: [],
              result: null,
              get kernelNames() {
                return Array.from(new Set(this.kernels.map(function(k) {
                  return k.name;
                })));
              }
            };
          }
          EngineState3.prototype.dispose = function() {
            for (var variableName in this.registeredVariables) {
              this.registeredVariables[variableName].dispose();
            }
          };
          return EngineState3;
        }();
        var Engine2 = function() {
          function Engine3(ENV5) {
            this.ENV = ENV5;
            this.registry = {};
            this.registryFactory = {};
            this.pendingBackendInitId = 0;
            this.state = new EngineState2();
          }
          Engine3.prototype.ready = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var sortedBackends, i, backendName, success;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (this.pendingBackendInit != null) {
                      return [2, this.pendingBackendInit.then(function() {
                      })];
                    }
                    if (this.backendInstance != null) {
                      return [2];
                    }
                    sortedBackends = this.getSortedBackends();
                    i = 0;
                    _a.label = 1;
                  case 1:
                    if (!(i < sortedBackends.length))
                      return [3, 5];
                    backendName = sortedBackends[i];
                    return [4, this.initializeBackend(backendName).success];
                  case 2:
                    success = _a.sent();
                    if (!success)
                      return [3, 4];
                    return [4, this.setBackend(backendName)];
                  case 3:
                    _a.sent();
                    return [2];
                  case 4:
                    i++;
                    return [3, 1];
                  case 5:
                    throw new Error("Could not initialize any backends, all backend initializations failed.");
                }
              });
            });
          };
          Object.defineProperty(Engine3.prototype, "backend", {
            get: function() {
              if (this.pendingBackendInit != null) {
                throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
              }
              if (this.backendInstance == null) {
                var _a = this.initializeBackendsAndReturnBest(), name_1 = _a.name, asyncInit = _a.asyncInit;
                if (asyncInit) {
                  throw new Error("The highest priority backend '" + name_1 + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                }
                this.setBackend(name_1);
              }
              return this.backendInstance;
            },
            enumerable: true,
            configurable: true
          });
          Engine3.prototype.backendNames = function() {
            return Object.keys(this.registryFactory);
          };
          Engine3.prototype.findBackend = function(backendName) {
            if (!(backendName in this.registry)) {
              if (backendName in this.registryFactory) {
                var asyncInit = this.initializeBackend(backendName).asyncInit;
                if (asyncInit) {
                  return null;
                }
              } else {
                return null;
              }
            }
            return this.registry[backendName];
          };
          Engine3.prototype.findBackendFactory = function(backendName) {
            if (!(backendName in this.registryFactory)) {
              return null;
            }
            return this.registryFactory[backendName].factory;
          };
          Engine3.prototype.registerBackend = function(backendName, factory, priority) {
            if (priority === void 0) {
              priority = 1;
            }
            if (backendName in this.registryFactory) {
              console.warn(backendName + " backend was already registered. Reusing existing backend factory.");
              return false;
            }
            this.registryFactory[backendName] = { factory, priority };
            return true;
          };
          Engine3.prototype.setBackend = function(backendName) {
            return __awaiter2(this, void 0, void 0, function() {
              var _a, success, asyncInit, result2, _b;
              return __generator2(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (this.registryFactory[backendName] == null) {
                      throw new Error("Backend name '" + backendName + "' not found in registry");
                    }
                    this.backendName = backendName;
                    if (!(this.registry[backendName] == null))
                      return [3, 4];
                    this.backendInstance = null;
                    _a = this.initializeBackend(backendName), success = _a.success, asyncInit = _a.asyncInit;
                    if (!asyncInit)
                      return [3, 2];
                    return [4, success];
                  case 1:
                    _b = _c.sent();
                    return [3, 3];
                  case 2:
                    _b = success;
                    _c.label = 3;
                  case 3:
                    result2 = _b;
                    if (!result2) {
                      return [2, false];
                    }
                    _c.label = 4;
                  case 4:
                    this.backendInstance = this.registry[backendName];
                    this.setupRegisteredKernels();
                    this.profiler = new Profiler2(this.backendInstance);
                    return [2, true];
                }
              });
            });
          };
          Engine3.prototype.setupRegisteredKernels = function() {
            var _this = this;
            var kernels = getKernelsForBackend2(this.backendName);
            kernels.forEach(function(kernel) {
              if (kernel.setupFunc != null) {
                kernel.setupFunc(_this.backendInstance);
              }
            });
          };
          Engine3.prototype.disposeRegisteredKernels = function(backendName) {
            var _this = this;
            var kernels = getKernelsForBackend2(backendName);
            kernels.forEach(function(kernel) {
              if (kernel.disposeFunc != null) {
                kernel.disposeFunc(_this.registry[backendName]);
              }
            });
          };
          Engine3.prototype.initializeBackend = function(backendName) {
            var _this = this;
            var registryFactoryEntry = this.registryFactory[backendName];
            if (registryFactoryEntry == null) {
              throw new Error("Cannot initialize backend " + backendName + ", no registration found.");
            }
            try {
              var backend2 = registryFactoryEntry.factory();
              if (backend2 && !(backend2 instanceof KernelBackend2) && typeof backend2.then === "function") {
                var promiseId_1 = ++this.pendingBackendInitId;
                var success = backend2.then(function(backendInstance) {
                  if (promiseId_1 < _this.pendingBackendInitId) {
                    return false;
                  }
                  _this.registry[backendName] = backendInstance;
                  _this.pendingBackendInit = null;
                  return true;
                }).catch(function(err) {
                  if (promiseId_1 < _this.pendingBackendInitId) {
                    return false;
                  }
                  _this.pendingBackendInit = null;
                  console.warn("Initialization of backend " + backendName + " failed");
                  console.warn(err.stack || err.message);
                  return false;
                });
                this.pendingBackendInit = success;
                return { success, asyncInit: true };
              } else {
                this.registry[backendName] = backend2;
                return { success: true, asyncInit: false };
              }
            } catch (err) {
              console.warn("Initialization of backend " + backendName + " failed");
              console.warn(err.stack || err.message);
              return { success: false, asyncInit: false };
            }
          };
          Engine3.prototype.removeBackend = function(backendName) {
            if (!(backendName in this.registryFactory)) {
              throw new Error(backendName + " backend not found in registry");
            }
            if (this.backendName === backendName && this.pendingBackendInit != null) {
              this.pendingBackendInitId++;
            }
            if (backendName in this.registry) {
              this.disposeRegisteredKernels(backendName);
              this.registry[backendName].dispose();
              delete this.registry[backendName];
            }
            delete this.registryFactory[backendName];
            if (this.backendName === backendName) {
              this.pendingBackendInit = null;
              this.backendName = null;
              this.backendInstance = null;
            }
          };
          Engine3.prototype.getSortedBackends = function() {
            var _this = this;
            if (Object.keys(this.registryFactory).length === 0) {
              throw new Error("No backend found in registry.");
            }
            return Object.keys(this.registryFactory).sort(function(a, b) {
              return _this.registryFactory[b].priority - _this.registryFactory[a].priority;
            });
          };
          Engine3.prototype.initializeBackendsAndReturnBest = function() {
            var sortedBackends = this.getSortedBackends();
            for (var i = 0; i < sortedBackends.length; i++) {
              var backendName = sortedBackends[i];
              var _a = this.initializeBackend(backendName), success = _a.success, asyncInit = _a.asyncInit;
              if (asyncInit || success) {
                return { name: backendName, asyncInit };
              }
            }
            throw new Error("Could not initialize any backends, all backend initializations failed.");
          };
          Engine3.prototype.moveData = function(backend2, dataId) {
            var info = this.state.tensorInfo.get(dataId);
            var srcBackend = info.backend;
            var values = this.readSync(dataId);
            var refCount = srcBackend.refCount(dataId);
            srcBackend.disposeData(dataId, true);
            info.backend = backend2;
            backend2.move(dataId, values, info.shape, info.dtype, refCount);
            if (this.shouldCheckForMemLeaks()) {
              this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
            }
          };
          Engine3.prototype.tidy = function(nameOrFn, fn) {
            var _this = this;
            var name = null;
            if (fn == null) {
              if (typeof nameOrFn !== "function") {
                throw new Error("Please provide a function to tidy()");
              }
              fn = nameOrFn;
            } else {
              if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
                throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
              }
              if (typeof fn !== "function") {
                throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
              }
              name = nameOrFn;
            }
            var result2;
            return this.scopedRun(function() {
              return _this.startScope(name);
            }, function() {
              return _this.endScope(result2);
            }, function() {
              result2 = fn();
              if (result2 instanceof Promise) {
                console.error("Cannot return a Promise inside of tidy.");
              }
              return result2;
            });
          };
          Engine3.prototype.scopedRun = function(start, end, f) {
            start();
            try {
              var res = f();
              end();
              return res;
            } catch (ex) {
              end();
              throw ex;
            }
          };
          Engine3.prototype.nextTensorId = function() {
            return Engine3.nextTensorId++;
          };
          Engine3.prototype.nextVariableId = function() {
            return Engine3.nextVariableId++;
          };
          Engine3.prototype.clone = function(x) {
            var y = ENGINE2.runKernel(Identity2, { x });
            var inputs = { x };
            var grad2 = function(dy) {
              return {
                x: function() {
                  var dtype = "float32";
                  var gradInputs = { x: dy };
                  var attrs = { dtype };
                  return ENGINE2.runKernel(Cast2, gradInputs, attrs);
                }
              };
            };
            var saved = [];
            this.addTapeNode(this.state.activeScope.name, inputs, [y], grad2, saved, {});
            return y;
          };
          Engine3.prototype.runKernel = function(kernelName, inputs, attrs) {
            var hasKernel = getKernel2(kernelName, this.backendName) != null;
            if (!hasKernel) {
              throw new Error("Kernel '" + kernelName + "' not registered for backend '" + this.backendName + "'");
            }
            return this.runKernelFunc({ kernelName, inputs, attrs });
          };
          Engine3.prototype.shouldCheckForMemLeaks = function() {
            return this.ENV.getBool("IS_TEST");
          };
          Engine3.prototype.checkKernelForMemLeak = function(kernelName, numDataIdsBefore, outInfos) {
            var numDataIdsAfter = this.backend.numDataIds();
            var numOutputDataIds = 0;
            outInfos.forEach(function(info) {
              numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
            });
            var numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
            var dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
            if (dataIdsLeaked > 0) {
              throw new Error("Backend '" + this.backendName + "' has an internal memory leak " + ("(" + dataIdsLeaked + " data ids) after running '" + kernelName + "'"));
            }
          };
          Engine3.prototype.runKernelFunc = function(kernelParams) {
            var _this = this;
            var outputs;
            var saved = [];
            var isTapeOn = this.isTapeOn();
            var startingBytecount = this.state.numBytes;
            var startingNumTensors = this.state.numTensors;
            if (this.shouldCheckForMemLeaks()) {
              this.state.numDataMovesStack.push(0);
            }
            var kernelFunc;
            if (this.backendName == null) {
              this.backend;
            }
            var out;
            var kernelOrScopeName = isRegisteredKernelInvocation2(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
            if (isRegisteredKernelInvocation2(kernelParams)) {
              var kernelName_1 = kernelParams.kernelName, inputs_1 = kernelParams.inputs, attrs_1 = kernelParams.attrs;
              if (this.backendName == null) {
                this.backend;
              }
              var kernel_1 = getKernel2(kernelName_1, this.backendName);
              assert2(kernel_1 != null, function() {
                return "Cannot find registered kernel '" + kernelName_1 + "' for backend '" + _this.backendName + "'";
              });
              kernelFunc = function() {
                var numDataIdsBefore = _this.backend.numDataIds();
                out = kernel_1.kernelFunc({ inputs: inputs_1, attrs: attrs_1, backend: _this.backend });
                var outInfos = Array.isArray(out) ? out : [out];
                if (_this.shouldCheckForMemLeaks()) {
                  _this.checkKernelForMemLeak(kernelName_1, numDataIdsBefore, outInfos);
                }
                var outTensors = outInfos.map(function(outInfo) {
                  if (outInfo.rank != null) {
                    return outInfo;
                  }
                  var _a = outInfo, dataId = _a.dataId, shape = _a.shape, dtype = _a.dtype;
                  return _this.makeTensorFromDataId(dataId, shape, dtype);
                });
                if (isTapeOn) {
                  var tensorsToSave = _this.getTensorsForGradient(kernelName_1, inputs_1, outTensors);
                  saved = _this.saveTensorsForBackwardMode(tensorsToSave);
                }
                return outTensors;
              };
            } else {
              var forwardFunc_1 = kernelParams.forwardFunc;
              var saveFunc_1 = function(tensors) {
                if (!isTapeOn) {
                  return;
                }
                saved = tensors.map(function(tensor2) {
                  return _this.keep(_this.clone(tensor2));
                });
              };
              kernelFunc = function() {
                var numDataIdsBefore = _this.backend.numDataIds();
                out = _this.tidy(function() {
                  return forwardFunc_1(_this.backend, saveFunc_1);
                });
                var outs = Array.isArray(out) ? out : [out];
                if (_this.shouldCheckForMemLeaks()) {
                  _this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
                }
                return outs;
              };
            }
            var inputs = kernelParams.inputs, attrs = kernelParams.attrs;
            var backwardsFunc = isRegisteredKernelInvocation2(kernelParams) ? null : kernelParams.backwardsFunc;
            var kernelProfile;
            this.scopedRun(function() {
              return _this.state.kernelDepth++;
            }, function() {
              return _this.state.kernelDepth--;
            }, function() {
              if (!_this.ENV.getBool("DEBUG") && !_this.state.profiling) {
                outputs = kernelFunc();
              } else {
                kernelProfile = _this.profiler.profileKernel(kernelOrScopeName, inputs, function() {
                  return kernelFunc();
                });
                if (_this.ENV.getBool("DEBUG")) {
                  _this.profiler.logKernelProfile(kernelProfile);
                }
                outputs = kernelProfile.outputs;
              }
            });
            if (isTapeOn) {
              this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
            }
            if (this.state.profiling) {
              this.state.activeProfile.kernels.push({
                name: kernelOrScopeName,
                bytesAdded: this.state.numBytes - startingBytecount,
                totalBytesSnapshot: this.state.numBytes,
                tensorsAdded: this.state.numTensors - startingNumTensors,
                totalTensorsSnapshot: this.state.numTensors,
                inputShapes: Object.keys(inputs).map(function(key) {
                  return inputs[key] != null ? inputs[key].shape : null;
                }),
                outputShapes: outputs.map(function(item) {
                  return item.shape;
                }),
                kernelTimeMs: kernelProfile.timeMs,
                extraInfo: kernelProfile.extraInfo
              });
            }
            return Array.isArray(out) ? outputs : outputs[0];
          };
          Engine3.prototype.saveTensorsForBackwardMode = function(tensors) {
            var _this = this;
            var saved = tensors.map(function(tensor2) {
              return _this.keep(_this.clone(tensor2));
            });
            return saved;
          };
          Engine3.prototype.getTensorsForGradient = function(kernelName, inputs, outputs) {
            var gradConfig = getGradient2(kernelName);
            if (gradConfig != null) {
              var inputsToSave = gradConfig.inputsToSave || [];
              var outputsToSave_1 = gradConfig.outputsToSave || [];
              var inputTensorsToSave = void 0;
              if (gradConfig.saveAllInputs) {
                assert2(Array.isArray(inputs), function() {
                  return "saveAllInputs is true, expected inputs to be an array.";
                });
                inputTensorsToSave = Object.keys(inputs).map(function(key) {
                  return inputs[key];
                });
              } else {
                inputTensorsToSave = inputsToSave.map(function(inputName) {
                  return inputs[inputName];
                });
              }
              var outputTensorsToSave = outputs.filter(function(_, i) {
                return outputsToSave_1[i];
              });
              return inputTensorsToSave.concat(outputTensorsToSave);
            }
            return [];
          };
          Engine3.prototype.makeTensor = function(values, shape, dtype, backend2) {
            if (values == null) {
              throw new Error("Values passed to engine.makeTensor() are null");
            }
            dtype = dtype || "float32";
            backend2 = backend2 || this.backend;
            var backendVals = values;
            if (dtype === "string" && isString3(values[0])) {
              backendVals = values.map(function(d) {
                return encodeString2(d);
              });
            }
            var dataId = backend2.write(backendVals, shape, dtype);
            var t = new Tensor3(shape, dtype, dataId, this.nextTensorId());
            this.trackTensor(t, backend2);
            if (dtype === "string") {
              var info = this.state.tensorInfo.get(dataId);
              var newBytes = bytesFromStringArray2(backendVals);
              this.state.numBytes += newBytes - info.bytes;
              info.bytes = newBytes;
            }
            return t;
          };
          Engine3.prototype.makeTensorFromDataId = function(dataId, shape, dtype, backend2) {
            dtype = dtype || "float32";
            var t = new Tensor3(shape, dtype, dataId, this.nextTensorId());
            this.trackTensor(t, backend2);
            return t;
          };
          Engine3.prototype.makeVariable = function(initialValue, trainable, name, dtype) {
            if (trainable === void 0) {
              trainable = true;
            }
            name = name || this.nextVariableId().toString();
            if (dtype != null && dtype !== initialValue.dtype) {
              initialValue = initialValue.cast(dtype);
            }
            var v = new Variable2(initialValue, trainable, name, this.nextTensorId());
            if (this.state.registeredVariables[v.name] != null) {
              throw new Error("Variable with name " + v.name + " was already registered");
            }
            this.state.registeredVariables[v.name] = v;
            this.incRef(v, this.backend);
            return v;
          };
          Engine3.prototype.trackTensor = function(a, backend2) {
            this.state.numTensors++;
            if (a.dtype === "string") {
              this.state.numStringTensors++;
            }
            var bytes = 0;
            if (a.dtype !== "complex64" && a.dtype !== "string") {
              bytes = a.size * bytesPerElement2(a.dtype);
            }
            this.state.numBytes += bytes;
            if (!this.state.tensorInfo.has(a.dataId)) {
              this.state.numDataBuffers++;
              this.state.tensorInfo.set(a.dataId, {
                backend: backend2 || this.backend,
                dtype: a.dtype,
                shape: a.shape,
                bytes
              });
            }
            if (!(a instanceof Variable2)) {
              this.track(a);
            }
          };
          Engine3.prototype.incRef = function(a, backend2) {
            this.trackTensor(a, backend2);
            this.backend.incRef(a.dataId);
          };
          Engine3.prototype.removeDataId = function(dataId, backend2) {
            if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend2) {
              this.state.tensorInfo.delete(dataId);
              this.state.numDataBuffers--;
            }
          };
          Engine3.prototype.disposeTensor = function(a) {
            if (!this.state.tensorInfo.has(a.dataId)) {
              return;
            }
            var info = this.state.tensorInfo.get(a.dataId);
            this.state.numTensors--;
            if (a.dtype === "string") {
              this.state.numStringTensors--;
              this.state.numBytes -= info.bytes;
            }
            if (a.dtype !== "complex64" && a.dtype !== "string") {
              var bytes = a.size * bytesPerElement2(a.dtype);
              this.state.numBytes -= bytes;
            }
            if (info.backend.disposeData(a.dataId)) {
              this.removeDataId(a.dataId, info.backend);
            }
          };
          Engine3.prototype.disposeVariables = function() {
            for (var varName in this.state.registeredVariables) {
              var v = this.state.registeredVariables[varName];
              this.disposeVariable(v);
            }
          };
          Engine3.prototype.disposeVariable = function(v) {
            this.disposeTensor(v);
            if (this.state.registeredVariables[v.name] != null) {
              delete this.state.registeredVariables[v.name];
            }
          };
          Engine3.prototype.memory = function() {
            var info = this.backend.memory();
            info.numTensors = this.state.numTensors;
            info.numDataBuffers = this.state.numDataBuffers;
            info.numBytes = this.state.numBytes;
            if (this.state.numStringTensors > 0) {
              info.unreliable = true;
              if (info.reasons == null) {
                info.reasons = [];
              }
              info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
            }
            return info;
          };
          Engine3.prototype.profile = function(query) {
            return __awaiter2(this, void 0, void 0, function() {
              var startBytes, startNumTensors, _a, _i, _b, kernel, _c, _d;
              return __generator2(this, function(_e) {
                switch (_e.label) {
                  case 0:
                    this.state.profiling = true;
                    startBytes = this.state.numBytes;
                    startNumTensors = this.state.numTensors;
                    this.state.activeProfile.kernels = [];
                    _a = this.state.activeProfile;
                    return [4, query()];
                  case 1:
                    _a.result = _e.sent();
                    this.state.profiling = false;
                    this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(d) {
                      return d.totalBytesSnapshot;
                    }));
                    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
                    this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
                    _i = 0, _b = this.state.activeProfile.kernels;
                    _e.label = 2;
                  case 2:
                    if (!(_i < _b.length))
                      return [3, 6];
                    kernel = _b[_i];
                    _c = kernel;
                    return [4, kernel.kernelTimeMs];
                  case 3:
                    _c.kernelTimeMs = _e.sent();
                    _d = kernel;
                    return [4, kernel.extraInfo];
                  case 4:
                    _d.extraInfo = _e.sent();
                    _e.label = 5;
                  case 5:
                    _i++;
                    return [3, 2];
                  case 6:
                    return [2, this.state.activeProfile];
                }
              });
            });
          };
          Engine3.prototype.isTapeOn = function() {
            return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
          };
          Engine3.prototype.addTapeNode = function(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
            var _this = this;
            var tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
            var gradConfig = getGradient2(kernelName);
            if (gradConfig != null) {
              gradientsFunc = gradConfig.gradFunc;
            }
            if (gradientsFunc != null) {
              tapeNode.gradient = function(dys) {
                dys = dys.map(function(dy, i) {
                  if (dy == null) {
                    var output = outputs[i];
                    var vals = makeZerosTypedArray2(output.size, output.dtype);
                    return _this.makeTensor(vals, output.shape, output.dtype);
                  }
                  return dy;
                });
                return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
              };
            }
            this.state.activeTape.push(tapeNode);
          };
          Engine3.prototype.keep = function(result2) {
            result2.kept = true;
            return result2;
          };
          Engine3.prototype.startTape = function() {
            if (this.state.gradientDepth === 0) {
              this.state.activeTape = [];
            }
            this.state.gradientDepth++;
          };
          Engine3.prototype.endTape = function() {
            this.state.gradientDepth--;
          };
          Engine3.prototype.startScope = function(name) {
            var scopeInfo = {
              track: [],
              name: "unnamed scope",
              id: this.state.nextScopeId++
            };
            if (name) {
              scopeInfo.name = name;
            }
            this.state.scopeStack.push(scopeInfo);
            this.state.activeScope = scopeInfo;
          };
          Engine3.prototype.endScope = function(result2) {
            var _this = this;
            var tensorsToTrackInParent = getTensorsInContainer2(result2);
            var tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(function(t) {
              return t.id;
            }));
            for (var i = 0; i < this.state.activeScope.track.length; i++) {
              var tensor2 = this.state.activeScope.track[i];
              if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
                tensor2.dispose();
              }
            }
            var oldScope = this.state.scopeStack.pop();
            this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
            tensorsToTrackInParent.forEach(function(tensor3) {
              if (!tensor3.kept && tensor3.scopeId === oldScope.id) {
                _this.track(tensor3);
              }
            });
          };
          Engine3.prototype.gradients = function(f, xs, dy, allowNoGradients) {
            var _this = this;
            if (allowNoGradients === void 0) {
              allowNoGradients = false;
            }
            assert2(xs.length > 0, function() {
              return "gradients() received an empty list of xs.";
            });
            if (dy != null && dy.dtype !== "float32") {
              throw new Error("dy must have 'float32' dtype, but has '" + dy.dtype + "'");
            }
            var y = this.scopedRun(function() {
              return _this.startTape();
            }, function() {
              return _this.endTape();
            }, function() {
              return _this.tidy("forward", f);
            });
            assert2(y instanceof Tensor3, function() {
              return "The result y returned by f() must be a tensor.";
            });
            var filteredTape = getFilteredNodesXToY2(this.state.activeTape, xs, y);
            if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
              throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
            }
            return this.tidy("backward", function() {
              var accumulatedGradientMap = {};
              accumulatedGradientMap[y.id] = dy == null ? ones2(y.shape) : dy;
              backpropagateGradients2(accumulatedGradientMap, filteredTape, function(f2) {
                return _this.tidy(f2);
              }, add5);
              var grads2 = xs.map(function(x) {
                return accumulatedGradientMap[x.id];
              });
              if (_this.state.gradientDepth === 0) {
                _this.state.activeTape.forEach(function(node) {
                  for (var _i = 0, _a = node.saved; _i < _a.length; _i++) {
                    var tensor2 = _a[_i];
                    tensor2.dispose();
                  }
                });
                _this.state.activeTape = null;
              }
              return { value: y, grads: grads2 };
            });
          };
          Engine3.prototype.customGrad = function(f) {
            var _this = this;
            assert2(isFunction3(f), function() {
              return "The f passed in customGrad(f) must be a function.";
            });
            return function() {
              var inputs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
              }
              assert2(inputs.every(function(t) {
                return t instanceof Tensor3;
              }), function() {
                return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
              });
              var res;
              var inputMap = {};
              inputs.forEach(function(input, i) {
                inputMap[i] = input;
              });
              var forwardFunc = function(_, save2) {
                res = f.apply(void 0, inputs.concat([save2]));
                assert2(res.value instanceof Tensor3, function() {
                  return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
                });
                assert2(isFunction3(res.gradFunc), function() {
                  return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
                });
                return res.value;
              };
              var backwardsFunc = function(dy, saved) {
                var gradRes = res.gradFunc(dy, saved);
                var grads2 = Array.isArray(gradRes) ? gradRes : [gradRes];
                assert2(grads2.length === inputs.length, function() {
                  return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
                });
                assert2(grads2.every(function(t) {
                  return t instanceof Tensor3;
                }), function() {
                  return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
                });
                var gradMap = {};
                grads2.forEach(function(grad2, i) {
                  gradMap[i] = function() {
                    return grad2;
                  };
                });
                return gradMap;
              };
              return _this.runKernelFunc({
                forwardFunc,
                backwardsFunc,
                inputs: inputMap
              });
            };
          };
          Engine3.prototype.readSync = function(dataId) {
            var info = this.state.tensorInfo.get(dataId);
            return info.backend.readSync(dataId);
          };
          Engine3.prototype.read = function(dataId) {
            var info = this.state.tensorInfo.get(dataId);
            return info.backend.read(dataId);
          };
          Engine3.prototype.time = function(query) {
            return __awaiter2(this, void 0, void 0, function() {
              var start, timingInfo;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    start = now2();
                    return [4, this.backend.time(query)];
                  case 1:
                    timingInfo = _a.sent();
                    timingInfo.wallMs = now2() - start;
                    return [2, timingInfo];
                }
              });
            });
          };
          Engine3.prototype.track = function(result2) {
            if (this.state.activeScope != null) {
              result2.scopeId = this.state.activeScope.id;
              this.state.activeScope.track.push(result2);
            }
            return result2;
          };
          Object.defineProperty(Engine3.prototype, "registeredVariables", {
            get: function() {
              return this.state.registeredVariables;
            },
            enumerable: true,
            configurable: true
          });
          Engine3.prototype.reset = function() {
            this.pendingBackendInitId++;
            this.state.dispose();
            this.ENV.reset();
            this.state = new EngineState2();
            for (var backendName in this.registry) {
              this.disposeRegisteredKernels(backendName);
              this.registry[backendName].dispose();
              delete this.registry[backendName];
            }
            this.backendName = null;
            this.backendInstance = null;
            this.pendingBackendInit = null;
          };
          Engine3.nextTensorId = 0;
          Engine3.nextVariableId = 0;
          return Engine3;
        }();
        function ones2(shape) {
          var values = makeOnesTypedArray2(sizeFromShape2(shape), "float32");
          return ENGINE2.makeTensor(values, shape, "float32");
        }
        function getOrMakeEngine2() {
          var ns = getGlobalNamespace2();
          if (ns._tfengine == null) {
            var environment = new Environment2(ns);
            ns._tfengine = new Engine2(environment);
          }
          setEnvironmentGlobal2(ns._tfengine.ENV);
          setTensorTracker2(function() {
            return ns._tfengine;
          });
          return ns._tfengine;
        }
        var ENGINE2 = getOrMakeEngine2();
        function add5(a, b) {
          var inputs = { a, b };
          return ENGINE2.runKernel(Add2, inputs);
        }
        function _isNavigatorDefined2() {
          return typeof navigator !== "undefined" && navigator != null;
        }
        function isMobile3(nav) {
          if (nav || _isNavigatorDefined2()) {
            if (!nav) {
              nav = navigator;
            }
            if (nav.product === "ReactNative") {
              return true;
            }
            var a = nav.userAgent || nav.vendor || window.opera;
            return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
          }
          return false;
        }
        function isBrowser2() {
          return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
        }
        var device_util2 = {
          __proto__: null,
          isMobile: isMobile3,
          isBrowser: isBrowser2
        };
        var ENV4 = env2();
        ENV4.registerFlag("DEBUG", function() {
          return false;
        }, function(debugValue) {
          if (debugValue) {
            console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
          }
        });
        ENV4.registerFlag("IS_BROWSER", function() {
          return isBrowser2();
        });
        ENV4.registerFlag("IS_NODE", function() {
          return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
        });
        ENV4.registerFlag("IS_CHROME", function() {
          return typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        });
        ENV4.registerFlag("PROD", function() {
          return false;
        });
        ENV4.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
          return ENV4.getBool("DEBUG");
        });
        ENV4.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
          return true;
        });
        ENV4.registerFlag("IS_TEST", function() {
          return false;
        });
        ENV4.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function() {
          return true;
        });
        ENV4.registerFlag("WRAP_TO_IMAGEBITMAP", function() {
          return false;
        });
        function inferShape2(val, dtype) {
          var firstElem = val;
          if (isTypedArray2(val)) {
            return dtype === "string" ? [] : [val.length];
          }
          if (!Array.isArray(val)) {
            return [];
          }
          var shape = [];
          while (Array.isArray(firstElem) || isTypedArray2(firstElem) && dtype !== "string") {
            shape.push(firstElem.length);
            firstElem = firstElem[0];
          }
          if (Array.isArray(val) && env2().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
            deepAssertShapeConsistency2(val, shape, []);
          }
          return shape;
        }
        function deepAssertShapeConsistency2(val, shape, indices) {
          indices = indices || [];
          if (!Array.isArray(val) && !isTypedArray2(val)) {
            assert2(shape.length === 0, function() {
              return "Element arr[" + indices.join("][") + "] is a primitive, " + ("but should be an array/TypedArray of " + shape[0] + " elements");
            });
            return;
          }
          assert2(shape.length > 0, function() {
            return "Element arr[" + indices.join("][") + "] should be a primitive, " + ("but is an array of " + val.length + " elements");
          });
          assert2(val.length === shape[0], function() {
            return "Element arr[" + indices.join("][") + "] should have " + shape[0] + " " + ("elements, but has " + val.length + " elements");
          });
          var subShape = shape.slice(1);
          for (var i = 0; i < val.length; ++i) {
            deepAssertShapeConsistency2(val[i], subShape, indices.concat(i));
          }
        }
        function assertDtype2(expectedDtype, actualDType, argName, functionName) {
          if (expectedDtype === "string_or_numeric") {
            return;
          }
          if (expectedDtype == null) {
            throw new Error("Expected dtype cannot be null.");
          }
          if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
            throw new Error("Argument '" + argName + "' passed to '" + functionName + "' must " + ("be " + expectedDtype + " tensor, but got " + actualDType + " tensor"));
          }
        }
        function convertToTensor2(x, argName, functionName, parseAsDtype) {
          if (parseAsDtype === void 0) {
            parseAsDtype = "numeric";
          }
          if (x instanceof Tensor3) {
            assertDtype2(parseAsDtype, x.dtype, argName, functionName);
            return x;
          }
          var inferredDtype = inferDtype2(x);
          if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
            inferredDtype = parseAsDtype;
          }
          assertDtype2(parseAsDtype, inferredDtype, argName, functionName);
          if (x == null || !isTypedArray2(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
            var type = x == null ? "null" : x.constructor.name;
            throw new Error("Argument '" + argName + "' passed to '" + functionName + "' must be a " + ("Tensor or TensorLike, but got '" + type + "'"));
          }
          var inferredShape = inferShape2(x, inferredDtype);
          if (!isTypedArray2(x) && !Array.isArray(x)) {
            x = [x];
          }
          var skipTypedArray = true;
          var values = inferredDtype !== "string" ? toTypedArray2(x, inferredDtype) : flatten2(x, [], skipTypedArray);
          return ENGINE2.makeTensor(values, inferredShape, inferredDtype);
        }
        function convertToTensorArray(arg, argName, functionName, parseAsDtype) {
          if (parseAsDtype === void 0) {
            parseAsDtype = "numeric";
          }
          if (!Array.isArray(arg)) {
            throw new Error("Argument " + argName + " passed to " + functionName + " must be a `Tensor[]` or `TensorLike[]`");
          }
          var tensors = arg;
          return tensors.map(function(t, i) {
            return convertToTensor2(t, argName + "[" + i + "]", functionName, parseAsDtype);
          });
        }
        var OP_SCOPE_SUFFIX2 = "__op";
        function op2(f) {
          var keys = Object.keys(f);
          if (keys.length !== 1) {
            throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + (keys.length + " keys."));
          }
          var opName = keys[0];
          var fn = f[opName];
          if (opName.endsWith("_")) {
            opName = opName.substring(0, opName.length - 1);
          }
          opName = opName + OP_SCOPE_SUFFIX2;
          var f2 = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            ENGINE2.startScope(opName);
            try {
              var result2 = fn.apply(void 0, args);
              if (isPromise2(result2)) {
                console.error("Cannot return a Promise inside of tidy.");
              }
              ENGINE2.endScope(result2);
              return result2;
            } catch (ex) {
              ENGINE2.endScope(null);
              throw ex;
            }
          };
          Object.defineProperty(f2, "name", { value: opName, configurable: true });
          return f2;
        }
        function complex_2(real4, imag3) {
          var $real = convertToTensor2(real4, "real", "complex");
          var $imag = convertToTensor2(imag3, "imag", "complex");
          assertShapesMatch2($real.shape, $imag.shape, "real and imag shapes, " + $real.shape + " and " + $imag.shape + ", must match in call to tf.complex().");
          var inputs = { real: $real, imag: $imag };
          return ENGINE2.runKernel(Complex2, inputs);
        }
        var complex4 = op2({ complex_: complex_2 });
        function makeTensor2(values, shape, inferredShape, dtype) {
          if (dtype == null) {
            dtype = inferDtype2(values);
          }
          if (dtype === "complex64") {
            throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
          }
          if (!isTypedArray2(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
            throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
          }
          if (shape != null) {
            assertNonNegativeIntegerDimensions2(shape);
            var providedSize_1 = sizeFromShape2(shape);
            var inferredSize_1 = sizeFromShape2(inferredShape);
            assert2(providedSize_1 === inferredSize_1, function() {
              return "Based on the provided shape, [" + shape + "], the tensor should have " + (providedSize_1 + " values but has " + inferredSize_1);
            });
            for (var i = 0; i < inferredShape.length; ++i) {
              var inferred = inferredShape[i];
              var flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape2(shape.slice(i)) : true;
              assert2(inferredShape[i] === shape[i] || !flatDimsDontMatch, function() {
                return "Error creating a new Tensor. Inferred shape " + ("(" + inferredShape + ") does not match the provided ") + ("shape (" + shape + "). ");
              });
            }
          }
          if (!isTypedArray2(values) && !Array.isArray(values)) {
            values = [values];
          }
          shape = shape || inferredShape;
          values = dtype !== "string" ? toTypedArray2(values, dtype) : flatten2(values, [], true);
          return ENGINE2.makeTensor(values, shape, dtype);
        }
        function tensor(values, shape, dtype) {
          var inferredShape = inferShape2(values, dtype);
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        var DTYPE_VALUE_SIZE_MAP2 = {
          "float32": 4,
          "float16": 2,
          "int32": 4,
          "uint16": 2,
          "uint8": 1,
          "bool": 1,
          "complex64": 8
        };
        var NUM_BYTES_STRING_LENGTH = 4;
        function encodeWeights2(tensors, group) {
          return __awaiter2(this, void 0, void 0, function() {
            var specs, dataPromises, names, _loop_1, i, tensorValues;
            var _this = this;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  specs = [];
                  dataPromises = [];
                  names = Array.isArray(tensors) ? tensors.map(function(tensor2) {
                    return tensor2.name;
                  }) : Object.keys(tensors);
                  _loop_1 = function(i2) {
                    var name_1 = names[i2];
                    var t = Array.isArray(tensors) ? tensors[i2].tensor : tensors[name_1];
                    if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
                      throw new Error("Unsupported dtype in weight '" + name_1 + "': " + t.dtype);
                    }
                    var spec = { name: name_1, shape: t.shape, dtype: t.dtype };
                    if (t.dtype === "string") {
                      var utf8bytes = new Promise(function(resolve) {
                        return __awaiter2(_this, void 0, void 0, function() {
                          var vals, totalNumBytes, bytes, offset, i_1, val, bytesOfLength;
                          return __generator2(this, function(_a2) {
                            switch (_a2.label) {
                              case 0:
                                return [4, t.bytes()];
                              case 1:
                                vals = _a2.sent();
                                totalNumBytes = vals.reduce(function(p, c) {
                                  return p + c.length;
                                }, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
                                bytes = new Uint8Array(totalNumBytes);
                                offset = 0;
                                for (i_1 = 0; i_1 < vals.length; i_1++) {
                                  val = vals[i_1];
                                  bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
                                  bytes.set(bytesOfLength, offset);
                                  offset += NUM_BYTES_STRING_LENGTH;
                                  bytes.set(val, offset);
                                  offset += val.length;
                                }
                                resolve(bytes);
                                return [2];
                            }
                          });
                        });
                      });
                      dataPromises.push(utf8bytes);
                    } else {
                      dataPromises.push(t.data());
                    }
                    if (group != null) {
                      spec.group = group;
                    }
                    specs.push(spec);
                  };
                  for (i = 0; i < names.length; ++i) {
                    _loop_1(i);
                  }
                  return [4, Promise.all(dataPromises)];
                case 1:
                  tensorValues = _a.sent();
                  return [2, { data: concatenateTypedArrays(tensorValues), specs }];
              }
            });
          });
        }
        function decodeWeights2(buffer3, specs) {
          var out = {};
          var float16Decode;
          var offset = 0;
          for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
            var spec = specs_1[_i];
            var name_2 = spec.name;
            var dtype = spec.dtype;
            var shape = spec.shape;
            var size = sizeFromShape2(shape);
            var values = void 0;
            if ("quantization" in spec) {
              var quantization = spec.quantization;
              if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
                if (!("min" in quantization && "scale" in quantization)) {
                  throw new Error("Weight " + spec.name + " with quantization " + quantization.dtype + " doesn't have corresponding metadata min and scale.");
                }
              } else if (quantization.dtype === "float16") {
                if (dtype !== "float32") {
                  throw new Error("Weight " + spec.name + " is quantized with " + quantization.dtype + " " + ("which only supports weights of type float32 not " + dtype + "."));
                }
              } else {
                throw new Error("Weight " + spec.name + " has unknown " + ("quantization dtype " + quantization.dtype + ". ") + "Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
              }
              var quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP2[quantization.dtype];
              var byteBuffer = buffer3.slice(offset, offset + size * quantizationSizeFactor);
              var quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
              if (dtype === "float32") {
                if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
                  values = new Float32Array(quantizedArray.length);
                  for (var i = 0; i < quantizedArray.length; i++) {
                    var v = quantizedArray[i];
                    values[i] = v * quantization.scale + quantization.min;
                  }
                } else if (quantization.dtype === "float16") {
                  if (float16Decode === void 0) {
                    float16Decode = getFloat16Decoder();
                  }
                  values = float16Decode(quantizedArray);
                } else {
                  throw new Error("Unsupported quantization type " + quantization.dtype + " for weight type float32.");
                }
              } else if (dtype === "int32") {
                if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
                  throw new Error("Unsupported quantization type " + quantization.dtype + " for weight type int32.");
                }
                values = new Int32Array(quantizedArray.length);
                for (var i = 0; i < quantizedArray.length; i++) {
                  var v = quantizedArray[i];
                  values[i] = Math.round(v * quantization.scale + quantization.min);
                }
              } else {
                throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
              }
              offset += size * quantizationSizeFactor;
            } else if (dtype === "string") {
              var size_1 = sizeFromShape2(spec.shape);
              values = [];
              for (var i = 0; i < size_1; i++) {
                var byteLength = new Uint32Array(buffer3.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
                offset += NUM_BYTES_STRING_LENGTH;
                var bytes = new Uint8Array(buffer3.slice(offset, offset + byteLength));
                values.push(bytes);
                offset += byteLength;
              }
            } else {
              var dtypeFactor = DTYPE_VALUE_SIZE_MAP2[dtype];
              var byteBuffer = buffer3.slice(offset, offset + size * dtypeFactor);
              if (dtype === "float32") {
                values = new Float32Array(byteBuffer);
              } else if (dtype === "int32") {
                values = new Int32Array(byteBuffer);
              } else if (dtype === "bool") {
                values = new Uint8Array(byteBuffer);
              } else if (dtype === "complex64") {
                values = new Float32Array(byteBuffer);
                var real4 = new Float32Array(values.length / 2);
                var image3 = new Float32Array(values.length / 2);
                for (var i = 0; i < real4.length; i++) {
                  real4[i] = values[i * 2];
                  image3[i] = values[i * 2 + 1];
                }
                var realTensor = tensor(real4, shape, "float32");
                var imageTensor = tensor(image3, shape, "float32");
                out[name_2] = complex4(realTensor, imageTensor);
                realTensor.dispose();
                imageTensor.dispose();
              } else {
                throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
              }
              offset += size * dtypeFactor;
            }
            if (dtype !== "complex64") {
              out[name_2] = tensor(values, shape, dtype);
            }
          }
          return out;
        }
        function concatenateTypedArrays(xs) {
          if (xs === null) {
            throw new Error("Invalid input value: " + JSON.stringify(xs));
          }
          var totalByteLength = 0;
          var normalizedXs = [];
          xs.forEach(function(x) {
            totalByteLength += x.byteLength;
            normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
            if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
              throw new Error("Unsupported TypedArray subtype: " + x.constructor.name);
            }
          });
          var y = new Uint8Array(totalByteLength);
          var offset = 0;
          normalizedXs.forEach(function(x) {
            y.set(new Uint8Array(x.buffer), offset);
            offset += x.byteLength;
          });
          return y.buffer;
        }
        var useNodeBuffer2 = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
        function stringByteLength2(str) {
          if (useNodeBuffer2) {
            return Buffer.byteLength(str);
          }
          return new Blob([str]).size;
        }
        function arrayBufferToBase64String2(buffer3) {
          if (useNodeBuffer2) {
            return Buffer.from(buffer3).toString("base64");
          }
          var buf = new Uint8Array(buffer3);
          var s = "";
          for (var i = 0, l = buf.length; i < l; i++) {
            s += String.fromCharCode(buf[i]);
          }
          return btoa(s);
        }
        function base64StringToArrayBuffer2(str) {
          if (useNodeBuffer2) {
            var buf = Buffer.from(str, "base64");
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          }
          var s = atob(str);
          var buffer3 = new Uint8Array(s.length);
          for (var i = 0; i < s.length; ++i) {
            buffer3.set([s.charCodeAt(i)], i);
          }
          return buffer3.buffer;
        }
        function concatenateArrayBuffers2(buffers) {
          if (buffers.length === 1) {
            return buffers[0];
          }
          var totalByteLength = 0;
          buffers.forEach(function(buffer3) {
            totalByteLength += buffer3.byteLength;
          });
          var temp = new Uint8Array(totalByteLength);
          var offset = 0;
          buffers.forEach(function(buffer3) {
            temp.set(new Uint8Array(buffer3), offset);
            offset += buffer3.byteLength;
          });
          return temp.buffer;
        }
        function basename2(path) {
          var SEPARATOR = "/";
          path = path.trim();
          while (path.endsWith(SEPARATOR)) {
            path = path.slice(0, path.length - 1);
          }
          var items = path.split(SEPARATOR);
          return items[items.length - 1];
        }
        function getModelArtifactsInfoForJSON2(modelArtifacts) {
          if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
            throw new Error("Expected JSON model topology, received ArrayBuffer.");
          }
          return {
            dateSaved: new Date(),
            modelTopologyType: "JSON",
            modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength2(JSON.stringify(modelArtifacts.modelTopology)),
            weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength2(JSON.stringify(modelArtifacts.weightSpecs)),
            weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
          };
        }
        function computeFloat16MantisaTable() {
          var convertMantissa = function(i2) {
            var m = i2 << 13;
            var e = 0;
            while ((m & 8388608) === 0) {
              e -= 8388608;
              m <<= 1;
            }
            m &= ~8388608;
            e += 947912704;
            return m | e;
          };
          var mantisaTable = new Uint32Array(2048);
          mantisaTable[0] = 0;
          for (var i = 1; i < 1024; i++) {
            mantisaTable[i] = convertMantissa(i);
          }
          for (var i = 1024; i < 2048; i++) {
            mantisaTable[i] = 939524096 + (i - 1024 << 13);
          }
          return mantisaTable;
        }
        function computeFloat16ExponentTable() {
          var exponentTable = new Uint32Array(64);
          exponentTable[0] = 0;
          exponentTable[31] = 1199570944;
          exponentTable[32] = 2147483648;
          exponentTable[63] = 3347054592;
          for (var i = 1; i < 31; i++) {
            exponentTable[i] = i << 23;
          }
          for (var i = 33; i < 63; i++) {
            exponentTable[i] = 2147483648 + (i - 32 << 23);
          }
          return exponentTable;
        }
        function computeFloat16OffsetTable() {
          var offsetTable = new Uint32Array(64);
          for (var i = 0; i < 64; i++) {
            offsetTable[i] = 1024;
          }
          offsetTable[0] = offsetTable[32] = 0;
          return offsetTable;
        }
        function getFloat16Decoder() {
          var mantisaTable = computeFloat16MantisaTable();
          var exponentTable = computeFloat16ExponentTable();
          var offsetTable = computeFloat16OffsetTable();
          return function(quantizedArray) {
            var buffer3 = new ArrayBuffer(4 * quantizedArray.length);
            var bufferUint32View = new Uint32Array(buffer3);
            for (var index2 = 0; index2 < quantizedArray.length; index2++) {
              var float16Bits = quantizedArray[index2];
              var float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
              bufferUint32View[index2] = float32Bits;
            }
            return new Float32Array(buffer3);
          };
        }
        var IORouterRegistry2 = function() {
          function IORouterRegistry3() {
            this.saveRouters = [];
            this.loadRouters = [];
          }
          IORouterRegistry3.getInstance = function() {
            if (IORouterRegistry3.instance == null) {
              IORouterRegistry3.instance = new IORouterRegistry3();
            }
            return IORouterRegistry3.instance;
          };
          IORouterRegistry3.registerSaveRouter = function(saveRouter) {
            IORouterRegistry3.getInstance().saveRouters.push(saveRouter);
          };
          IORouterRegistry3.registerLoadRouter = function(loadRouter) {
            IORouterRegistry3.getInstance().loadRouters.push(loadRouter);
          };
          IORouterRegistry3.getSaveHandlers = function(url) {
            return IORouterRegistry3.getHandlers(url, "save");
          };
          IORouterRegistry3.getLoadHandlers = function(url, loadOptions) {
            return IORouterRegistry3.getHandlers(url, "load", loadOptions);
          };
          IORouterRegistry3.getHandlers = function(url, handlerType, loadOptions) {
            var validHandlers = [];
            var routers = handlerType === "load" ? IORouterRegistry3.getInstance().loadRouters : IORouterRegistry3.getInstance().saveRouters;
            routers.forEach(function(router) {
              var handler = router(url, loadOptions);
              if (handler !== null) {
                validHandlers.push(handler);
              }
            });
            return validHandlers;
          };
          return IORouterRegistry3;
        }();
        var registerSaveRouter2 = function(loudRouter) {
          return IORouterRegistry2.registerSaveRouter(loudRouter);
        };
        var registerLoadRouter2 = function(loudRouter) {
          return IORouterRegistry2.registerLoadRouter(loudRouter);
        };
        var getSaveHandlers2 = function(url) {
          return IORouterRegistry2.getSaveHandlers(url);
        };
        var getLoadHandlers2 = function(url, loadOptions) {
          return IORouterRegistry2.getLoadHandlers(url, loadOptions);
        };
        var DATABASE_NAME2 = "tensorflowjs";
        var DATABASE_VERSION2 = 1;
        var MODEL_STORE_NAME2 = "models_store";
        var INFO_STORE_NAME2 = "model_info_store";
        function getIndexedDBFactory2() {
          if (!env2().getBool("IS_BROWSER")) {
            throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
          }
          var theWindow = typeof window === "undefined" ? self : window;
          var factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
          if (factory == null) {
            throw new Error("The current browser does not appear to support IndexedDB.");
          }
          return factory;
        }
        function setUpDatabase2(openRequest) {
          var db = openRequest.result;
          db.createObjectStore(MODEL_STORE_NAME2, { keyPath: "modelPath" });
          db.createObjectStore(INFO_STORE_NAME2, { keyPath: "modelPath" });
        }
        var BrowserIndexedDB2 = function() {
          function BrowserIndexedDB3(modelPath) {
            this.indexedDB = getIndexedDBFactory2();
            if (modelPath == null || !modelPath) {
              throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
            }
            this.modelPath = modelPath;
          }
          BrowserIndexedDB3.prototype.save = function(modelArtifacts) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                  throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                }
                return [2, this.databaseAction(this.modelPath, modelArtifacts)];
              });
            });
          };
          BrowserIndexedDB3.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                return [2, this.databaseAction(this.modelPath)];
              });
            });
          };
          BrowserIndexedDB3.prototype.databaseAction = function(modelPath, modelArtifacts) {
            var _this = this;
            return new Promise(function(resolve, reject) {
              var openRequest = _this.indexedDB.open(DATABASE_NAME2, DATABASE_VERSION2);
              openRequest.onupgradeneeded = function() {
                return setUpDatabase2(openRequest);
              };
              openRequest.onsuccess = function() {
                var db = openRequest.result;
                if (modelArtifacts == null) {
                  var modelTx = db.transaction(MODEL_STORE_NAME2, "readonly");
                  var modelStore = modelTx.objectStore(MODEL_STORE_NAME2);
                  var getRequest_1 = modelStore.get(_this.modelPath);
                  getRequest_1.onsuccess = function() {
                    if (getRequest_1.result == null) {
                      db.close();
                      return reject(new Error("Cannot find model with path '" + _this.modelPath + "' in IndexedDB."));
                    } else {
                      resolve(getRequest_1.result.modelArtifacts);
                    }
                  };
                  getRequest_1.onerror = function(error) {
                    db.close();
                    return reject(getRequest_1.error);
                  };
                  modelTx.oncomplete = function() {
                    return db.close();
                  };
                } else {
                  var modelArtifactsInfo_1 = getModelArtifactsInfoForJSON2(modelArtifacts);
                  var infoTx_1 = db.transaction(INFO_STORE_NAME2, "readwrite");
                  var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME2);
                  var putInfoRequest_1 = infoStore_1.put({ modelPath: _this.modelPath, modelArtifactsInfo: modelArtifactsInfo_1 });
                  var modelTx_1;
                  putInfoRequest_1.onsuccess = function() {
                    modelTx_1 = db.transaction(MODEL_STORE_NAME2, "readwrite");
                    var modelStore2 = modelTx_1.objectStore(MODEL_STORE_NAME2);
                    var putModelRequest = modelStore2.put({
                      modelPath: _this.modelPath,
                      modelArtifacts,
                      modelArtifactsInfo: modelArtifactsInfo_1
                    });
                    putModelRequest.onsuccess = function() {
                      return resolve({ modelArtifactsInfo: modelArtifactsInfo_1 });
                    };
                    putModelRequest.onerror = function(error) {
                      infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME2);
                      var deleteInfoRequest = infoStore_1.delete(_this.modelPath);
                      deleteInfoRequest.onsuccess = function() {
                        db.close();
                        return reject(putModelRequest.error);
                      };
                      deleteInfoRequest.onerror = function(error2) {
                        db.close();
                        return reject(putModelRequest.error);
                      };
                    };
                  };
                  putInfoRequest_1.onerror = function(error) {
                    db.close();
                    return reject(putInfoRequest_1.error);
                  };
                  infoTx_1.oncomplete = function() {
                    if (modelTx_1 == null) {
                      db.close();
                    } else {
                      modelTx_1.oncomplete = function() {
                        return db.close();
                      };
                    }
                  };
                }
              };
              openRequest.onerror = function(error) {
                return reject(openRequest.error);
              };
            });
          };
          BrowserIndexedDB3.URL_SCHEME = "indexeddb://";
          return BrowserIndexedDB3;
        }();
        var indexedDBRouter2 = function(url) {
          if (!env2().getBool("IS_BROWSER")) {
            return null;
          } else {
            if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB2.URL_SCHEME)) {
              return browserIndexedDB2(url.slice(BrowserIndexedDB2.URL_SCHEME.length));
            } else {
              return null;
            }
          }
        };
        IORouterRegistry2.registerSaveRouter(indexedDBRouter2);
        IORouterRegistry2.registerLoadRouter(indexedDBRouter2);
        function browserIndexedDB2(modelPath) {
          return new BrowserIndexedDB2(modelPath);
        }
        function maybeStripScheme3(key) {
          return key.startsWith(BrowserIndexedDB2.URL_SCHEME) ? key.slice(BrowserIndexedDB2.URL_SCHEME.length) : key;
        }
        var BrowserIndexedDBManager2 = function() {
          function BrowserIndexedDBManager3() {
            this.indexedDB = getIndexedDBFactory2();
          }
          BrowserIndexedDBManager3.prototype.listModels = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var _this = this;
              return __generator2(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                  var openRequest = _this.indexedDB.open(DATABASE_NAME2, DATABASE_VERSION2);
                  openRequest.onupgradeneeded = function() {
                    return setUpDatabase2(openRequest);
                  };
                  openRequest.onsuccess = function() {
                    var db = openRequest.result;
                    var tx = db.transaction(INFO_STORE_NAME2, "readonly");
                    var store = tx.objectStore(INFO_STORE_NAME2);
                    var getAllInfoRequest = store.getAll();
                    getAllInfoRequest.onsuccess = function() {
                      var out = {};
                      for (var _i = 0, _a2 = getAllInfoRequest.result; _i < _a2.length; _i++) {
                        var item = _a2[_i];
                        out[item.modelPath] = item.modelArtifactsInfo;
                      }
                      resolve(out);
                    };
                    getAllInfoRequest.onerror = function(error) {
                      db.close();
                      return reject(getAllInfoRequest.error);
                    };
                    tx.oncomplete = function() {
                      return db.close();
                    };
                  };
                  openRequest.onerror = function(error) {
                    return reject(openRequest.error);
                  };
                })];
              });
            });
          };
          BrowserIndexedDBManager3.prototype.removeModel = function(path) {
            return __awaiter2(this, void 0, void 0, function() {
              var _this = this;
              return __generator2(this, function(_a) {
                path = maybeStripScheme3(path);
                return [2, new Promise(function(resolve, reject) {
                  var openRequest = _this.indexedDB.open(DATABASE_NAME2, DATABASE_VERSION2);
                  openRequest.onupgradeneeded = function() {
                    return setUpDatabase2(openRequest);
                  };
                  openRequest.onsuccess = function() {
                    var db = openRequest.result;
                    var infoTx = db.transaction(INFO_STORE_NAME2, "readwrite");
                    var infoStore = infoTx.objectStore(INFO_STORE_NAME2);
                    var getInfoRequest = infoStore.get(path);
                    var modelTx;
                    getInfoRequest.onsuccess = function() {
                      if (getInfoRequest.result == null) {
                        db.close();
                        return reject(new Error("Cannot find model with path '" + path + "' in IndexedDB."));
                      } else {
                        var deleteInfoRequest = infoStore.delete(path);
                        var deleteModelData_1 = function() {
                          modelTx = db.transaction(MODEL_STORE_NAME2, "readwrite");
                          var modelStore = modelTx.objectStore(MODEL_STORE_NAME2);
                          var deleteModelRequest = modelStore.delete(path);
                          deleteModelRequest.onsuccess = function() {
                            return resolve(getInfoRequest.result.modelArtifactsInfo);
                          };
                          deleteModelRequest.onerror = function(error) {
                            return reject(getInfoRequest.error);
                          };
                        };
                        deleteInfoRequest.onsuccess = deleteModelData_1;
                        deleteInfoRequest.onerror = function(error) {
                          deleteModelData_1();
                          db.close();
                          return reject(getInfoRequest.error);
                        };
                      }
                    };
                    getInfoRequest.onerror = function(error) {
                      db.close();
                      return reject(getInfoRequest.error);
                    };
                    infoTx.oncomplete = function() {
                      if (modelTx == null) {
                        db.close();
                      } else {
                        modelTx.oncomplete = function() {
                          return db.close();
                        };
                      }
                    };
                  };
                  openRequest.onerror = function(error) {
                    return reject(openRequest.error);
                  };
                })];
              });
            });
          };
          return BrowserIndexedDBManager3;
        }();
        var PATH_SEPARATOR2 = "/";
        var PATH_PREFIX2 = "tensorflowjs_models";
        var INFO_SUFFIX2 = "info";
        var MODEL_TOPOLOGY_SUFFIX2 = "model_topology";
        var WEIGHT_SPECS_SUFFIX2 = "weight_specs";
        var WEIGHT_DATA_SUFFIX2 = "weight_data";
        var MODEL_METADATA_SUFFIX2 = "model_metadata";
        function getModelKeys2(path) {
          return {
            info: [PATH_PREFIX2, path, INFO_SUFFIX2].join(PATH_SEPARATOR2),
            topology: [PATH_PREFIX2, path, MODEL_TOPOLOGY_SUFFIX2].join(PATH_SEPARATOR2),
            weightSpecs: [PATH_PREFIX2, path, WEIGHT_SPECS_SUFFIX2].join(PATH_SEPARATOR2),
            weightData: [PATH_PREFIX2, path, WEIGHT_DATA_SUFFIX2].join(PATH_SEPARATOR2),
            modelMetadata: [PATH_PREFIX2, path, MODEL_METADATA_SUFFIX2].join(PATH_SEPARATOR2)
          };
        }
        function getModelPathFromKey2(key) {
          var items = key.split(PATH_SEPARATOR2);
          if (items.length < 3) {
            throw new Error("Invalid key format: " + key);
          }
          return items.slice(1, items.length - 1).join(PATH_SEPARATOR2);
        }
        function maybeStripScheme$1(key) {
          return key.startsWith(BrowserLocalStorage2.URL_SCHEME) ? key.slice(BrowserLocalStorage2.URL_SCHEME.length) : key;
        }
        var BrowserLocalStorage2 = function() {
          function BrowserLocalStorage3(modelPath) {
            if (!env2().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
              throw new Error("The current environment does not support local storage.");
            }
            this.LS = window.localStorage;
            if (modelPath == null || !modelPath) {
              throw new Error("For local storage, modelPath must not be null, undefined or empty.");
            }
            this.modelPath = modelPath;
            this.keys = getModelKeys2(this.modelPath);
          }
          BrowserLocalStorage3.prototype.save = function(modelArtifacts) {
            return __awaiter2(this, void 0, void 0, function() {
              var topology, weightSpecs, modelArtifactsInfo, result2;
              return __generator2(this, function(_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                  throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                } else {
                  topology = JSON.stringify(modelArtifacts.modelTopology);
                  weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
                  modelArtifactsInfo = getModelArtifactsInfoForJSON2(modelArtifacts);
                  try {
                    this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                    this.LS.setItem(this.keys.topology, topology);
                    this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                    this.LS.setItem(this.keys.weightData, arrayBufferToBase64String2(modelArtifacts.weightData));
                    result2 = {
                      format: modelArtifacts.format,
                      generatedBy: modelArtifacts.generatedBy,
                      convertedBy: modelArtifacts.convertedBy
                    };
                    if (modelArtifacts.signature != null) {
                      result2.signature = modelArtifacts.signature;
                    }
                    if (modelArtifacts.userDefinedMetadata != null) {
                      result2.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
                    }
                    if (modelArtifacts.modelInitializer != null) {
                      result2.modelInitializer = modelArtifacts.modelInitializer;
                    }
                    this.LS.setItem(this.keys.modelMetadata, JSON.stringify(result2));
                    return [2, { modelArtifactsInfo }];
                  } catch (err) {
                    this.LS.removeItem(this.keys.info);
                    this.LS.removeItem(this.keys.topology);
                    this.LS.removeItem(this.keys.weightSpecs);
                    this.LS.removeItem(this.keys.weightData);
                    this.LS.removeItem(this.keys.modelMetadata);
                    throw new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: " + ("modelTopologyBytes=" + modelArtifactsInfo.modelTopologyBytes + ", ") + ("weightSpecsBytes=" + modelArtifactsInfo.weightSpecsBytes + ", ") + ("weightDataBytes=" + modelArtifactsInfo.weightDataBytes + "."));
                  }
                }
                return [2];
              });
            });
          };
          BrowserLocalStorage3.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var info, out, topology, weightSpecs, metadataString, metadata, weightDataBase64;
              return __generator2(this, function(_a) {
                info = JSON.parse(this.LS.getItem(this.keys.info));
                if (info == null) {
                  throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                }
                if (info.modelTopologyType !== "JSON") {
                  throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                }
                out = {};
                topology = JSON.parse(this.LS.getItem(this.keys.topology));
                if (topology == null) {
                  throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
                }
                out.modelTopology = topology;
                weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (weightSpecs == null) {
                  throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
                }
                out.weightSpecs = weightSpecs;
                metadataString = this.LS.getItem(this.keys.modelMetadata);
                if (metadataString != null) {
                  metadata = JSON.parse(metadataString);
                  out.format = metadata["format"];
                  out.generatedBy = metadata["generatedBy"];
                  out.convertedBy = metadata["convertedBy"];
                  if (metadata["signature"] != null) {
                    out.signature = metadata["signature"];
                  }
                  if (metadata["userDefinedMetadata"] != null) {
                    out.userDefinedMetadata = metadata["userDefinedMetadata"];
                  }
                  if (metadata["modelInitializer"] != null) {
                    out.modelInitializer = metadata["modelInitializer"];
                  }
                }
                weightDataBase64 = this.LS.getItem(this.keys.weightData);
                if (weightDataBase64 == null) {
                  throw new Error("In local storage, the binary weight values of model " + ("'" + this.modelPath + "' are missing."));
                }
                out.weightData = base64StringToArrayBuffer2(weightDataBase64);
                return [2, out];
              });
            });
          };
          BrowserLocalStorage3.URL_SCHEME = "localstorage://";
          return BrowserLocalStorage3;
        }();
        var localStorageRouter2 = function(url) {
          if (!env2().getBool("IS_BROWSER")) {
            return null;
          } else {
            if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage2.URL_SCHEME)) {
              return browserLocalStorage2(url.slice(BrowserLocalStorage2.URL_SCHEME.length));
            } else {
              return null;
            }
          }
        };
        IORouterRegistry2.registerSaveRouter(localStorageRouter2);
        IORouterRegistry2.registerLoadRouter(localStorageRouter2);
        function browserLocalStorage2(modelPath) {
          return new BrowserLocalStorage2(modelPath);
        }
        var BrowserLocalStorageManager2 = function() {
          function BrowserLocalStorageManager3() {
            assert2(env2().getBool("IS_BROWSER"), function() {
              return "Current environment is not a web browser";
            });
            assert2(typeof window === "undefined" || typeof window.localStorage !== "undefined", function() {
              return "Current browser does not appear to support localStorage";
            });
            this.LS = window.localStorage;
          }
          BrowserLocalStorageManager3.prototype.listModels = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var out, prefix, suffix, i, key, modelPath;
              return __generator2(this, function(_a) {
                out = {};
                prefix = PATH_PREFIX2 + PATH_SEPARATOR2;
                suffix = PATH_SEPARATOR2 + INFO_SUFFIX2;
                for (i = 0; i < this.LS.length; ++i) {
                  key = this.LS.key(i);
                  if (key.startsWith(prefix) && key.endsWith(suffix)) {
                    modelPath = getModelPathFromKey2(key);
                    out[modelPath] = JSON.parse(this.LS.getItem(key));
                  }
                }
                return [2, out];
              });
            });
          };
          BrowserLocalStorageManager3.prototype.removeModel = function(path) {
            return __awaiter2(this, void 0, void 0, function() {
              var keys, info;
              return __generator2(this, function(_a) {
                path = maybeStripScheme$1(path);
                keys = getModelKeys2(path);
                if (this.LS.getItem(keys.info) == null) {
                  throw new Error("Cannot find model at path '" + path + "'");
                }
                info = JSON.parse(this.LS.getItem(keys.info));
                this.LS.removeItem(keys.info);
                this.LS.removeItem(keys.topology);
                this.LS.removeItem(keys.weightSpecs);
                this.LS.removeItem(keys.weightData);
                return [2, info];
              });
            });
          };
          return BrowserLocalStorageManager3;
        }();
        var URL_SCHEME_SUFFIX2 = "://";
        var ModelStoreManagerRegistry2 = function() {
          function ModelStoreManagerRegistry3() {
            this.managers = {};
          }
          ModelStoreManagerRegistry3.getInstance = function() {
            if (ModelStoreManagerRegistry3.instance == null) {
              ModelStoreManagerRegistry3.instance = new ModelStoreManagerRegistry3();
            }
            return ModelStoreManagerRegistry3.instance;
          };
          ModelStoreManagerRegistry3.registerManager = function(scheme, manager) {
            assert2(scheme != null, function() {
              return "scheme must not be undefined or null.";
            });
            if (scheme.endsWith(URL_SCHEME_SUFFIX2)) {
              scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX2));
            }
            assert2(scheme.length > 0, function() {
              return "scheme must not be an empty string.";
            });
            var registry = ModelStoreManagerRegistry3.getInstance();
            assert2(registry.managers[scheme] == null, function() {
              return "A model store manager is already registered for scheme '" + scheme + "'.";
            });
            registry.managers[scheme] = manager;
          };
          ModelStoreManagerRegistry3.getManager = function(scheme) {
            var manager = this.getInstance().managers[scheme];
            if (manager == null) {
              throw new Error("Cannot find model manager for scheme '" + scheme + "'");
            }
            return manager;
          };
          ModelStoreManagerRegistry3.getSchemes = function() {
            return Object.keys(this.getInstance().managers);
          };
          return ModelStoreManagerRegistry3;
        }();
        function parseURL(url) {
          if (url.indexOf(URL_SCHEME_SUFFIX2) === -1) {
            throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + ("" + ModelStoreManagerRegistry2.getSchemes().join(",")));
          }
          return {
            scheme: url.split(URL_SCHEME_SUFFIX2)[0],
            path: url.split(URL_SCHEME_SUFFIX2)[1]
          };
        }
        function cloneModelInternal(sourceURL, destURL, deleteSource) {
          if (deleteSource === void 0) {
            deleteSource = false;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var loadHandlers, loadHandler, saveHandlers, saveHandler, sourceScheme, sourcePath, sameMedium, modelArtifacts, saveResult;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  assert2(sourceURL !== destURL, function() {
                    return "Old path and new path are the same: '" + sourceURL + "'";
                  });
                  loadHandlers = IORouterRegistry2.getLoadHandlers(sourceURL);
                  assert2(loadHandlers.length > 0, function() {
                    return "Copying failed because no load handler is found for source URL " + sourceURL + ".";
                  });
                  assert2(loadHandlers.length < 2, function() {
                    return "Copying failed because more than one (" + loadHandlers.length + ") " + ("load handlers for source URL " + sourceURL + ".");
                  });
                  loadHandler = loadHandlers[0];
                  saveHandlers = IORouterRegistry2.getSaveHandlers(destURL);
                  assert2(saveHandlers.length > 0, function() {
                    return "Copying failed because no save handler is found for destination " + ("URL " + destURL + ".");
                  });
                  assert2(saveHandlers.length < 2, function() {
                    return "Copying failed because more than one (" + loadHandlers.length + ") " + ("save handlers for destination URL " + destURL + ".");
                  });
                  saveHandler = saveHandlers[0];
                  sourceScheme = parseURL(sourceURL).scheme;
                  sourcePath = parseURL(sourceURL).path;
                  sameMedium = sourceScheme === parseURL(sourceURL).scheme;
                  return [4, loadHandler.load()];
                case 1:
                  modelArtifacts = _a.sent();
                  if (!(deleteSource && sameMedium))
                    return [3, 3];
                  return [4, ModelStoreManagerRegistry2.getManager(sourceScheme).removeModel(sourcePath)];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  return [4, saveHandler.save(modelArtifacts)];
                case 4:
                  saveResult = _a.sent();
                  if (!(deleteSource && !sameMedium))
                    return [3, 6];
                  return [4, ModelStoreManagerRegistry2.getManager(sourceScheme).removeModel(sourcePath)];
                case 5:
                  _a.sent();
                  _a.label = 6;
                case 6:
                  return [2, saveResult.modelArtifactsInfo];
              }
            });
          });
        }
        function listModels2() {
          return __awaiter2(this, void 0, void 0, function() {
            var schemes, out, _i, schemes_1, scheme, schemeOut, path, url;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  schemes = ModelStoreManagerRegistry2.getSchemes();
                  out = {};
                  _i = 0, schemes_1 = schemes;
                  _a.label = 1;
                case 1:
                  if (!(_i < schemes_1.length))
                    return [3, 4];
                  scheme = schemes_1[_i];
                  return [4, ModelStoreManagerRegistry2.getManager(scheme).listModels()];
                case 2:
                  schemeOut = _a.sent();
                  for (path in schemeOut) {
                    url = scheme + URL_SCHEME_SUFFIX2 + path;
                    out[url] = schemeOut[path];
                  }
                  _a.label = 3;
                case 3:
                  _i++;
                  return [3, 1];
                case 4:
                  return [2, out];
              }
            });
          });
        }
        function removeModel2(url) {
          return __awaiter2(this, void 0, void 0, function() {
            var schemeAndPath, manager;
            return __generator2(this, function(_a) {
              schemeAndPath = parseURL(url);
              manager = ModelStoreManagerRegistry2.getManager(schemeAndPath.scheme);
              return [2, manager.removeModel(schemeAndPath.path)];
            });
          });
        }
        function copyModel2(sourceURL, destURL) {
          return __awaiter2(this, void 0, void 0, function() {
            var deleteSource;
            return __generator2(this, function(_a) {
              deleteSource = false;
              return [2, cloneModelInternal(sourceURL, destURL, deleteSource)];
            });
          });
        }
        function moveModel2(sourceURL, destURL) {
          return __awaiter2(this, void 0, void 0, function() {
            var deleteSource;
            return __generator2(this, function(_a) {
              deleteSource = true;
              return [2, cloneModelInternal(sourceURL, destURL, deleteSource)];
            });
          });
        }
        var PlatformBrowser2 = function() {
          function PlatformBrowser3() {
          }
          PlatformBrowser3.prototype.fetch = function(path, init) {
            return fetch(path, init);
          };
          PlatformBrowser3.prototype.now = function() {
            return performance.now();
          };
          PlatformBrowser3.prototype.encode = function(text, encoding) {
            if (encoding !== "utf-8" && encoding !== "utf8") {
              throw new Error("Browser's encoder only supports utf-8, but got " + encoding);
            }
            if (this.textEncoder == null) {
              this.textEncoder = new TextEncoder();
            }
            return this.textEncoder.encode(text);
          };
          PlatformBrowser3.prototype.decode = function(bytes, encoding) {
            return new TextDecoder(encoding).decode(bytes);
          };
          return PlatformBrowser3;
        }();
        if (env2().get("IS_BROWSER")) {
          env2().setPlatform("browser", new PlatformBrowser2());
          try {
            ModelStoreManagerRegistry2.registerManager(BrowserLocalStorage2.URL_SCHEME, new BrowserLocalStorageManager2());
          } catch (err) {
          }
          try {
            ModelStoreManagerRegistry2.registerManager(BrowserIndexedDB2.URL_SCHEME, new BrowserIndexedDBManager2());
          } catch (err) {
          }
        }
        var getNodeFetch2 = {
          importFetch: function() {
            return require_browser2();
          }
        };
        var systemFetch2;
        var PlatformNode2 = function() {
          function PlatformNode3() {
            this.util = require_util2();
            this.textEncoder = new this.util.TextEncoder();
          }
          PlatformNode3.prototype.fetch = function(path, requestInits) {
            if (env2().global.fetch != null) {
              return env2().global.fetch(path, requestInits);
            }
            if (systemFetch2 == null) {
              systemFetch2 = getNodeFetch2.importFetch();
            }
            return systemFetch2(path, requestInits);
          };
          PlatformNode3.prototype.now = function() {
            var time2 = process.hrtime();
            return time2[0] * 1e3 + time2[1] / 1e6;
          };
          PlatformNode3.prototype.encode = function(text, encoding) {
            if (encoding !== "utf-8" && encoding !== "utf8") {
              throw new Error("Node built-in encoder only supports utf-8, but got " + encoding);
            }
            return this.textEncoder.encode(text);
          };
          PlatformNode3.prototype.decode = function(bytes, encoding) {
            if (bytes.length === 0) {
              return "";
            }
            return new this.util.TextDecoder(encoding).decode(bytes);
          };
          return PlatformNode3;
        }();
        if (env2().get("IS_NODE")) {
          env2().setPlatform("node", new PlatformNode2());
        }
        function buffer2(shape, dtype, values) {
          if (dtype === void 0) {
            dtype = "float32";
          }
          dtype = dtype || "float32";
          assertNonNegativeIntegerDimensions2(shape);
          return new TensorBuffer2(shape, dtype, values);
        }
        function cast_2(x, dtype) {
          var $x = convertToTensor2(x, "x", "cast");
          if (!isValidDtype2(dtype)) {
            throw new Error("Failed to cast to unknown dtype " + dtype);
          }
          if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
            throw new Error("Only strings can be casted to strings");
          }
          var inputs = { x: $x };
          var attrs = { dtype };
          return ENGINE2.runKernel(Cast2, inputs, attrs);
        }
        var cast5 = op2({ cast_: cast_2 });
        function clone_2(x) {
          var $x = convertToTensor2(x, "x", "clone", "string_or_numeric");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Identity2, inputs);
        }
        var clone2 = op2({ clone_: clone_2 });
        function print2(x, verbose) {
          if (verbose === void 0) {
            verbose = false;
          }
          console.log(x.toString(verbose));
        }
        getOrMakeEngine2();
        var opHandler$1 = {
          buffer: buffer2,
          cast: cast5,
          clone: clone2,
          print: print2
        };
        setOpHandler2(opHandler$1);
        var DEFAULT_FILE_NAME_PREFIX2 = "model";
        var DEFAULT_JSON_EXTENSION_NAME2 = ".json";
        var DEFAULT_WEIGHT_DATA_EXTENSION_NAME2 = ".weights.bin";
        function defer3(f) {
          return new Promise(function(resolve) {
            return setTimeout(resolve);
          }).then(f);
        }
        var BrowserDownloads2 = function() {
          function BrowserDownloads3(fileNamePrefix) {
            if (!env2().getBool("IS_BROWSER")) {
              throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
            }
            if (fileNamePrefix.startsWith(BrowserDownloads3.URL_SCHEME)) {
              fileNamePrefix = fileNamePrefix.slice(BrowserDownloads3.URL_SCHEME.length);
            }
            if (fileNamePrefix == null || fileNamePrefix.length === 0) {
              fileNamePrefix = DEFAULT_FILE_NAME_PREFIX2;
            }
            this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME2;
            this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME2;
          }
          BrowserDownloads3.prototype.save = function(modelArtifacts) {
            return __awaiter2(this, void 0, void 0, function() {
              var weightsURL, weightsManifest, modelTopologyAndWeightManifest, modelTopologyAndWeightManifestURL, jsonAnchor_1, weightDataAnchor_1;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (typeof document === "undefined") {
                      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                    }
                    weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: "application/octet-stream" }));
                    if (!(modelArtifacts.modelTopology instanceof ArrayBuffer))
                      return [3, 1];
                    throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                  case 1:
                    weightsManifest = [{
                      paths: ["./" + this.weightDataFileName],
                      weights: modelArtifacts.weightSpecs
                    }];
                    modelTopologyAndWeightManifest = {
                      modelTopology: modelArtifacts.modelTopology,
                      format: modelArtifacts.format,
                      generatedBy: modelArtifacts.generatedBy,
                      convertedBy: modelArtifacts.convertedBy,
                      weightsManifest
                    };
                    if (modelArtifacts.signature != null) {
                      modelTopologyAndWeightManifest.signature = modelArtifacts.signature;
                    }
                    if (modelArtifacts.userDefinedMetadata != null) {
                      modelTopologyAndWeightManifest.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
                    }
                    if (modelArtifacts.modelInitializer != null) {
                      modelTopologyAndWeightManifest.modelInitializer = modelArtifacts.modelInitializer;
                    }
                    modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: "application/json" }));
                    jsonAnchor_1 = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor;
                    jsonAnchor_1.download = this.modelTopologyFileName;
                    jsonAnchor_1.href = modelTopologyAndWeightManifestURL;
                    return [4, defer3(function() {
                      return jsonAnchor_1.dispatchEvent(new MouseEvent("click"));
                    })];
                  case 2:
                    _a.sent();
                    if (!(modelArtifacts.weightData != null))
                      return [3, 4];
                    weightDataAnchor_1 = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
                    weightDataAnchor_1.download = this.weightDataFileName;
                    weightDataAnchor_1.href = weightsURL;
                    return [4, defer3(function() {
                      return weightDataAnchor_1.dispatchEvent(new MouseEvent("click"));
                    })];
                  case 3:
                    _a.sent();
                    _a.label = 4;
                  case 4:
                    return [2, { modelArtifactsInfo: getModelArtifactsInfoForJSON2(modelArtifacts) }];
                }
              });
            });
          };
          BrowserDownloads3.URL_SCHEME = "downloads://";
          return BrowserDownloads3;
        }();
        var BrowserFiles = function() {
          function BrowserFiles2(files) {
            if (files == null || files.length < 1) {
              throw new Error("When calling browserFiles, at least 1 file is required, " + ("but received " + files));
            }
            this.files = files;
          }
          BrowserFiles2.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var jsonFile, weightFiles;
              var _this = this;
              return __generator2(this, function(_a) {
                jsonFile = this.files[0];
                weightFiles = this.files.slice(1);
                return [2, new Promise(function(resolve, reject) {
                  var jsonReader = new FileReader();
                  jsonReader.onload = function(event) {
                    var modelJSON = JSON.parse(event.target.result);
                    var modelTopology = modelJSON.modelTopology;
                    if (modelTopology == null) {
                      reject(new Error("modelTopology field is missing from file " + jsonFile.name));
                      return;
                    }
                    if (weightFiles.length === 0) {
                      resolve({ modelTopology });
                    }
                    var weightsManifest = modelJSON.weightsManifest;
                    if (weightsManifest == null) {
                      reject(new Error("weightManifest field is missing from file " + jsonFile.name));
                      return;
                    }
                    var pathToFile;
                    try {
                      pathToFile = _this.checkManifestAndWeightFiles(weightsManifest, weightFiles);
                    } catch (err) {
                      reject(err);
                      return;
                    }
                    var weightSpecs = [];
                    var paths = [];
                    var perFileBuffers = [];
                    weightsManifest.forEach(function(weightsGroup) {
                      weightsGroup.paths.forEach(function(path) {
                        paths.push(path);
                        perFileBuffers.push(null);
                      });
                      weightSpecs.push.apply(weightSpecs, weightsGroup.weights);
                    });
                    weightsManifest.forEach(function(weightsGroup) {
                      weightsGroup.paths.forEach(function(path) {
                        var weightFileReader = new FileReader();
                        weightFileReader.onload = function(event2) {
                          var weightData = event2.target.result;
                          var index2 = paths.indexOf(path);
                          perFileBuffers[index2] = weightData;
                          if (perFileBuffers.indexOf(null) === -1) {
                            var result2 = {
                              modelTopology,
                              weightSpecs,
                              weightData: concatenateArrayBuffers2(perFileBuffers),
                              format: modelJSON.format,
                              generatedBy: modelJSON.generatedBy,
                              convertedBy: modelJSON.convertedBy
                            };
                            if (modelJSON.signature != null) {
                              result2.signature = modelJSON.signature;
                            }
                            if (modelJSON.userDefinedMetadata != null) {
                              result2.userDefinedMetadata = modelJSON.userDefinedMetadata;
                            }
                            if (modelJSON.modelInitializer != null) {
                              result2.modelInitializer = modelJSON.modelInitializer;
                            }
                            resolve(result2);
                          }
                        };
                        weightFileReader.onerror = function(error) {
                          return reject("Failed to weights data from file of path '" + path + "'.");
                        };
                        weightFileReader.readAsArrayBuffer(pathToFile[path]);
                      });
                    });
                  };
                  jsonReader.onerror = function(error) {
                    return reject("Failed to read model topology and weights manifest JSON " + ("from file '" + jsonFile.name + "'. BrowserFiles supports loading ") + "Keras-style tf.Model artifacts only.");
                  };
                  jsonReader.readAsText(jsonFile);
                })];
              });
            });
          };
          BrowserFiles2.prototype.checkManifestAndWeightFiles = function(manifest, files) {
            var basenames = [];
            var fileNames = files.map(function(file) {
              return basename2(file.name);
            });
            var pathToFile = {};
            for (var _i = 0, manifest_1 = manifest; _i < manifest_1.length; _i++) {
              var group = manifest_1[_i];
              group.paths.forEach(function(path) {
                var pathBasename = basename2(path);
                if (basenames.indexOf(pathBasename) !== -1) {
                  throw new Error("Duplicate file basename found in weights manifest: " + ("'" + pathBasename + "'"));
                }
                basenames.push(pathBasename);
                if (fileNames.indexOf(pathBasename) === -1) {
                  throw new Error("Weight file with basename '" + pathBasename + "' is not provided.");
                } else {
                  pathToFile[path] = files[fileNames.indexOf(pathBasename)];
                }
              });
            }
            if (basenames.length !== files.length) {
              throw new Error("Mismatch in the number of files in weights manifest " + ("(" + basenames.length + ") and the number of weight files provided ") + ("(" + files.length + ")."));
            }
            return pathToFile;
          };
          return BrowserFiles2;
        }();
        var browserDownloadsRouter2 = function(url) {
          if (!env2().getBool("IS_BROWSER")) {
            return null;
          } else {
            if (!Array.isArray(url) && url.startsWith(BrowserDownloads2.URL_SCHEME)) {
              return browserDownloads2(url.slice(BrowserDownloads2.URL_SCHEME.length));
            } else {
              return null;
            }
          }
        };
        IORouterRegistry2.registerSaveRouter(browserDownloadsRouter2);
        function browserDownloads2(fileNamePrefix) {
          if (fileNamePrefix === void 0) {
            fileNamePrefix = "model";
          }
          return new BrowserDownloads2(fileNamePrefix);
        }
        function browserFiles2(files) {
          return new BrowserFiles(files);
        }
        function monitorPromisesProgress2(promises, onProgress, startFraction, endFraction) {
          checkPromises(promises);
          startFraction = startFraction == null ? 0 : startFraction;
          endFraction = endFraction == null ? 1 : endFraction;
          checkFraction(startFraction, endFraction);
          var resolvedPromise = 0;
          var registerMonitor = function(promise) {
            promise.then(function(value) {
              var fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
              onProgress(fraction);
              return value;
            });
            return promise;
          };
          function checkPromises(promises2) {
            assert2(promises2 != null && Array.isArray(promises2) && promises2.length > 0, function() {
              return "promises must be a none empty array";
            });
          }
          function checkFraction(startFraction2, endFraction2) {
            assert2(startFraction2 >= 0 && startFraction2 <= 1, function() {
              return "Progress fraction must be in range [0, 1], but " + ("got startFraction " + startFraction2);
            });
            assert2(endFraction2 >= 0 && endFraction2 <= 1, function() {
              return "Progress fraction must be in range [0, 1], but " + ("got endFraction " + endFraction2);
            });
            assert2(endFraction2 >= startFraction2, function() {
              return "startFraction must be no more than endFraction, but " + ("got startFraction " + startFraction2 + " and endFraction ") + ("" + endFraction2);
            });
          }
          return Promise.all(promises.map(registerMonitor));
        }
        function loadWeightsAsArrayBuffer2(fetchURLs, loadOptions) {
          return __awaiter2(this, void 0, void 0, function() {
            var fetchFunc, requests, fetchStartFraction, fetchEndFraction, responses, _a, bufferPromises, bufferStartFraction, bufferEndFraction, buffers, _b;
            return __generator2(this, function(_c) {
              switch (_c.label) {
                case 0:
                  if (loadOptions == null) {
                    loadOptions = {};
                  }
                  fetchFunc = loadOptions.fetchFunc == null ? env2().platform.fetch : loadOptions.fetchFunc;
                  requests = fetchURLs.map(function(fetchURL) {
                    return fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true });
                  });
                  fetchStartFraction = 0;
                  fetchEndFraction = 0.5;
                  if (!(loadOptions.onProgress == null))
                    return [3, 2];
                  return [4, Promise.all(requests)];
                case 1:
                  _a = _c.sent();
                  return [3, 4];
                case 2:
                  return [4, monitorPromisesProgress2(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction)];
                case 3:
                  _a = _c.sent();
                  _c.label = 4;
                case 4:
                  responses = _a;
                  bufferPromises = responses.map(function(response) {
                    return response.arrayBuffer();
                  });
                  bufferStartFraction = 0.5;
                  bufferEndFraction = 1;
                  if (!(loadOptions.onProgress == null))
                    return [3, 6];
                  return [4, Promise.all(bufferPromises)];
                case 5:
                  _b = _c.sent();
                  return [3, 8];
                case 6:
                  return [4, monitorPromisesProgress2(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction)];
                case 7:
                  _b = _c.sent();
                  _c.label = 8;
                case 8:
                  buffers = _b;
                  return [2, buffers];
              }
            });
          });
        }
        function loadWeights2(manifest, filePathPrefix, weightNames, requestInit) {
          if (filePathPrefix === void 0) {
            filePathPrefix = "";
          }
          return __awaiter2(this, void 0, void 0, function() {
            var fetchWeights, loadWeights3;
            return __generator2(this, function(_a) {
              fetchWeights = function(fetchUrls) {
                return loadWeightsAsArrayBuffer2(fetchUrls, { requestInit });
              };
              loadWeights3 = weightsLoaderFactory2(fetchWeights);
              return [2, loadWeights3(manifest, filePathPrefix, weightNames)];
            });
          });
        }
        function weightsLoaderFactory2(fetchWeightsFunction) {
          var _this = this;
          return function(manifest, filePathPrefix, weightNames) {
            if (filePathPrefix === void 0) {
              filePathPrefix = "";
            }
            return __awaiter2(_this, void 0, void 0, function() {
              var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    groupIndicesToFetchMap = manifest.map(function() {
                      return false;
                    });
                    groupWeightsToFetch = {};
                    weightsFound = weightNames != null ? weightNames.map(function() {
                      return false;
                    }) : [];
                    allManifestWeightNames = [];
                    manifest.forEach(function(manifestGroupConfig, groupIndex) {
                      var groupOffset = 0;
                      manifestGroupConfig.weights.forEach(function(weightsEntry) {
                        var rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
                        var weightsBytes = DTYPE_VALUE_SIZE_MAP2[rawDtype] * sizeFromShape2(weightsEntry.shape);
                        var enqueueWeightsForFetchingFn = function() {
                          groupIndicesToFetchMap[groupIndex] = true;
                          if (groupWeightsToFetch[groupIndex] == null) {
                            groupWeightsToFetch[groupIndex] = [];
                          }
                          groupWeightsToFetch[groupIndex].push({
                            manifestEntry: weightsEntry,
                            groupOffset,
                            sizeBytes: weightsBytes
                          });
                        };
                        if (weightNames != null) {
                          weightNames.forEach(function(weightName, weightIndex) {
                            if (weightName === weightsEntry.name) {
                              enqueueWeightsForFetchingFn();
                              weightsFound[weightIndex] = true;
                            }
                          });
                        } else {
                          enqueueWeightsForFetchingFn();
                        }
                        allManifestWeightNames.push(weightsEntry.name);
                        groupOffset += weightsBytes;
                      });
                    });
                    if (!weightsFound.every(function(found) {
                      return found;
                    })) {
                      weightsNotFound = weightNames.filter(function(_, i) {
                        return !weightsFound[i];
                      });
                      throw new Error("Could not find weights in manifest with names: " + (weightsNotFound.join(", ") + ". \n") + "Manifest JSON has weights with names: " + (allManifestWeightNames.join(", ") + "."));
                    }
                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function(accumulator, shouldFetch, i) {
                      if (shouldFetch) {
                        accumulator.push(i);
                      }
                      return accumulator;
                    }, []);
                    fetchUrls = [];
                    groupIndicesToFetch.forEach(function(i) {
                      manifest[i].paths.forEach(function(filepath) {
                        var fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
                        fetchUrls.push(fetchUrl);
                      });
                    });
                    return [4, fetchWeightsFunction(fetchUrls)];
                  case 1:
                    buffers = _a.sent();
                    weightsTensorMap = {};
                    bufferIndexOffset = 0;
                    groupIndicesToFetch.forEach(function(i) {
                      var numBuffers = manifest[i].paths.length;
                      var groupBytes = 0;
                      for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                        groupBytes += buffers[bufferIndexOffset + i_1].byteLength;
                      }
                      var groupBuffer = new ArrayBuffer(groupBytes);
                      var groupByteBuffer = new Uint8Array(groupBuffer);
                      var groupBufferOffset = 0;
                      for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                        var buffer3 = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                        groupByteBuffer.set(buffer3, groupBufferOffset);
                        groupBufferOffset += buffer3.byteLength;
                      }
                      var weightsEntries = groupWeightsToFetch[i];
                      weightsEntries.forEach(function(weightsEntry) {
                        var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                        var nameToTensorMap = decodeWeights2(byteBuffer, [weightsEntry.manifestEntry]);
                        for (var name_1 in nameToTensorMap) {
                          weightsTensorMap[name_1] = nameToTensorMap[name_1];
                        }
                      });
                      bufferIndexOffset += numBuffers;
                    });
                    return [2, weightsTensorMap];
                }
              });
            });
          };
        }
        var OCTET_STREAM_MIME_TYPE2 = "application/octet-stream";
        var JSON_TYPE2 = "application/json";
        var HTTPRequest2 = function() {
          function HTTPRequest3(path, loadOptions) {
            this.DEFAULT_METHOD = "POST";
            if (loadOptions == null) {
              loadOptions = {};
            }
            this.weightPathPrefix = loadOptions.weightPathPrefix;
            this.onProgress = loadOptions.onProgress;
            this.weightUrlConverter = loadOptions.weightUrlConverter;
            if (loadOptions.fetchFunc != null) {
              assert2(typeof loadOptions.fetchFunc === "function", function() {
                return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
              });
              this.fetch = loadOptions.fetchFunc;
            } else {
              this.fetch = env2().platform.fetch;
            }
            assert2(path != null && path.length > 0, function() {
              return "URL path for http must not be null, undefined or empty.";
            });
            if (Array.isArray(path)) {
              assert2(path.length === 2, function() {
                return "URL paths for http must have a length of 2, " + ("(actual length is " + path.length + ").");
              });
            }
            this.path = path;
            if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
              throw new Error("requestInit is expected to have no pre-existing body, but has one.");
            }
            this.requestInit = loadOptions.requestInit || {};
          }
          HTTPRequest3.prototype.save = function(modelArtifacts) {
            return __awaiter2(this, void 0, void 0, function() {
              var init, weightsManifest, modelTopologyAndWeightManifest, response;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                    }
                    init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
                    init.body = new FormData();
                    weightsManifest = [{
                      paths: ["./model.weights.bin"],
                      weights: modelArtifacts.weightSpecs
                    }];
                    modelTopologyAndWeightManifest = {
                      modelTopology: modelArtifacts.modelTopology,
                      format: modelArtifacts.format,
                      generatedBy: modelArtifacts.generatedBy,
                      convertedBy: modelArtifacts.convertedBy,
                      weightsManifest
                    };
                    if (modelArtifacts.signature != null) {
                      modelTopologyAndWeightManifest.signature = modelArtifacts.signature;
                    }
                    if (modelArtifacts.userDefinedMetadata != null) {
                      modelTopologyAndWeightManifest.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
                    }
                    if (modelArtifacts.modelInitializer != null) {
                      modelTopologyAndWeightManifest.modelInitializer = modelArtifacts.modelInitializer;
                    }
                    init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE2 }), "model.json");
                    if (modelArtifacts.weightData != null) {
                      init.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE2 }), "model.weights.bin");
                    }
                    return [4, this.fetch(this.path, init)];
                  case 1:
                    response = _a.sent();
                    if (response.ok) {
                      return [2, {
                        modelArtifactsInfo: getModelArtifactsInfoForJSON2(modelArtifacts),
                        responses: [response]
                      }];
                    } else {
                      throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + (response.status + "."));
                    }
                }
              });
            });
          };
          HTTPRequest3.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var modelConfigRequest, modelConfig, e_1, message, modelTopology, weightsManifest, generatedBy, convertedBy, format, signature, userDefinedMetadata, weightSpecs, weightData, results, artifacts, initializer;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.fetch(this.path, this.requestInit)];
                  case 1:
                    modelConfigRequest = _a.sent();
                    if (!modelConfigRequest.ok) {
                      throw new Error("Request to " + this.path + " failed with status code " + (modelConfigRequest.status + ". Please verify this URL points to ") + "the model JSON of the model to load.");
                    }
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4, modelConfigRequest.json()];
                  case 3:
                    modelConfig = _a.sent();
                    return [3, 5];
                  case 4:
                    e_1 = _a.sent();
                    message = "Failed to parse model JSON of response from " + this.path + ".";
                    if (this.path.endsWith(".pb")) {
                      message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
                    } else {
                      message += " Please make sure the server is serving valid JSON for this request.";
                    }
                    throw new Error(message);
                  case 5:
                    modelTopology = modelConfig.modelTopology;
                    weightsManifest = modelConfig.weightsManifest;
                    generatedBy = modelConfig.generatedBy;
                    convertedBy = modelConfig.convertedBy;
                    format = modelConfig.format;
                    signature = modelConfig.signature;
                    userDefinedMetadata = modelConfig.userDefinedMetadata;
                    if (modelTopology == null && weightsManifest == null) {
                      throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
                    }
                    if (!(weightsManifest != null))
                      return [3, 7];
                    return [4, this.loadWeights(weightsManifest)];
                  case 6:
                    results = _a.sent();
                    weightSpecs = results[0], weightData = results[1];
                    _a.label = 7;
                  case 7:
                    artifacts = {
                      modelTopology,
                      weightSpecs,
                      weightData,
                      generatedBy,
                      convertedBy,
                      format
                    };
                    if (signature != null) {
                      artifacts.signature = signature;
                    }
                    if (userDefinedMetadata != null) {
                      artifacts.userDefinedMetadata = userDefinedMetadata;
                    }
                    initializer = modelConfig.modelInitializer;
                    if (initializer) {
                      artifacts.modelInitializer = initializer;
                    }
                    return [2, artifacts];
                }
              });
            });
          };
          HTTPRequest3.prototype.loadWeights = function(weightsManifest) {
            return __awaiter2(this, void 0, void 0, function() {
              var weightPath, _a, prefix, suffix, pathPrefix, weightSpecs, _i, weightsManifest_1, entry, fetchURLs, urlPromises, _b, weightsManifest_2, weightsGroup, _c, _d, path, _e, _f, _g, buffers;
              return __generator2(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
                    _a = parseUrl2(weightPath), prefix = _a[0], suffix = _a[1];
                    pathPrefix = this.weightPathPrefix || prefix;
                    weightSpecs = [];
                    for (_i = 0, weightsManifest_1 = weightsManifest; _i < weightsManifest_1.length; _i++) {
                      entry = weightsManifest_1[_i];
                      weightSpecs.push.apply(weightSpecs, entry.weights);
                    }
                    fetchURLs = [];
                    urlPromises = [];
                    for (_b = 0, weightsManifest_2 = weightsManifest; _b < weightsManifest_2.length; _b++) {
                      weightsGroup = weightsManifest_2[_b];
                      for (_c = 0, _d = weightsGroup.paths; _c < _d.length; _c++) {
                        path = _d[_c];
                        if (this.weightUrlConverter != null) {
                          urlPromises.push(this.weightUrlConverter(path));
                        } else {
                          fetchURLs.push(pathPrefix + path + suffix);
                        }
                      }
                    }
                    if (!this.weightUrlConverter)
                      return [3, 2];
                    _f = (_e = fetchURLs.push).apply;
                    _g = [fetchURLs];
                    return [4, Promise.all(urlPromises)];
                  case 1:
                    _f.apply(_e, _g.concat([_h.sent()]));
                    _h.label = 2;
                  case 2:
                    return [4, loadWeightsAsArrayBuffer2(fetchURLs, {
                      requestInit: this.requestInit,
                      fetchFunc: this.fetch,
                      onProgress: this.onProgress
                    })];
                  case 3:
                    buffers = _h.sent();
                    return [2, [weightSpecs, concatenateArrayBuffers2(buffers)]];
                }
              });
            });
          };
          HTTPRequest3.URL_SCHEME_REGEX = /^https?:\/\//;
          return HTTPRequest3;
        }();
        function parseUrl2(url) {
          var lastSlash = url.lastIndexOf("/");
          var lastSearchParam = url.lastIndexOf("?");
          var prefix = url.substring(0, lastSlash);
          var suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
          return [prefix + "/", suffix];
        }
        function isHTTPScheme2(url) {
          return url.match(HTTPRequest2.URL_SCHEME_REGEX) != null;
        }
        var httpRouter2 = function(url, loadOptions) {
          if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
            return null;
          } else {
            var isHTTP = true;
            if (Array.isArray(url)) {
              isHTTP = url.every(function(urlItem) {
                return isHTTPScheme2(urlItem);
              });
            } else {
              isHTTP = isHTTPScheme2(url);
            }
            if (isHTTP) {
              return http2(url, loadOptions);
            }
          }
          return null;
        };
        IORouterRegistry2.registerSaveRouter(httpRouter2);
        IORouterRegistry2.registerLoadRouter(httpRouter2);
        function http2(path, loadOptions) {
          return new HTTPRequest2(path, loadOptions);
        }
        function browserHTTPRequest2(path, loadOptions) {
          return http2(path, loadOptions);
        }
        var PassthroughLoader = function() {
          function PassthroughLoader2(modelArtifacts) {
            this.modelArtifacts = modelArtifacts;
          }
          PassthroughLoader2.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                return [2, this.modelArtifacts];
              });
            });
          };
          return PassthroughLoader2;
        }();
        var PassthroughSaver = function() {
          function PassthroughSaver2(saveHandler) {
            this.saveHandler = saveHandler;
          }
          PassthroughSaver2.prototype.save = function(modelArtifacts) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                return [2, this.saveHandler(modelArtifacts)];
              });
            });
          };
          return PassthroughSaver2;
        }();
        function fromMemory2(modelArtifacts, weightSpecs, weightData, trainingConfig) {
          if (arguments.length === 1) {
            var isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
            if (isModelArtifacts) {
              return new PassthroughLoader(modelArtifacts);
            } else {
              console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
              return new PassthroughLoader({ modelTopology: modelArtifacts });
            }
          } else {
            console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
            return new PassthroughLoader({
              modelTopology: modelArtifacts,
              weightSpecs,
              weightData,
              trainingConfig
            });
          }
        }
        function withSaveHandler2(saveHandler) {
          return new PassthroughSaver(saveHandler);
        }
        var io = {
          __proto__: null,
          browserFiles: browserFiles2,
          browserHTTPRequest: browserHTTPRequest2,
          concatenateArrayBuffers: concatenateArrayBuffers2,
          decodeWeights: decodeWeights2,
          encodeWeights: encodeWeights2,
          fromMemory: fromMemory2,
          getLoadHandlers: getLoadHandlers2,
          getModelArtifactsInfoForJSON: getModelArtifactsInfoForJSON2,
          getSaveHandlers: getSaveHandlers2,
          http: http2,
          isHTTPScheme: isHTTPScheme2,
          loadWeights: loadWeights2,
          registerLoadRouter: registerLoadRouter2,
          registerSaveRouter: registerSaveRouter2,
          weightsLoaderFactory: weightsLoaderFactory2,
          withSaveHandler: withSaveHandler2,
          copyModel: copyModel2,
          listModels: listModels2,
          moveModel: moveModel2,
          removeModel: removeModel2
        };
        function matMul_(a, b, transposeA, transposeB) {
          var _a;
          if (transposeA === void 0) {
            transposeA = false;
          }
          if (transposeB === void 0) {
            transposeB = false;
          }
          var $a = convertToTensor2(a, "a", "matMul");
          var $b = convertToTensor2(b, "b", "matMul");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          var attrs = { transposeA, transposeB };
          return ENGINE2.runKernel(BatchMatMul2, inputs, attrs);
        }
        var matMul = op2({ matMul_ });
        function oneHot_(indices, depth, onValue, offValue) {
          if (onValue === void 0) {
            onValue = 1;
          }
          if (offValue === void 0) {
            offValue = 0;
          }
          if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
          }
          var $indices = convertToTensor2(indices, "indices", "oneHot", "int32");
          var inputs = { indices: $indices };
          var attrs = { depth, onValue, offValue };
          return ENGINE2.runKernel(OneHot2, inputs, attrs);
        }
        var oneHot2 = op2({ oneHot_ });
        function transpose_(x, perm) {
          var $x = convertToTensor2(x, "x", "transpose");
          if (perm == null) {
            perm = $x.shape.map(function(s, i) {
              return i;
            }).reverse();
          }
          assert2($x.rank === perm.length, function() {
            return "Error in transpose: rank of input " + $x.rank + " " + ("must match length of perm " + perm + ".");
          });
          perm.forEach(function(axis) {
            assert2(axis >= 0 && axis < $x.rank, function() {
              return "All entries in 'perm' must be between 0 and " + ($x.rank - 1) + (" but got " + perm);
            });
          });
          if ($x.rank <= 1) {
            return $x.clone();
          }
          var inputs = { x: $x };
          var attrs = { perm };
          return ENGINE2.runKernel(Transpose2, inputs, attrs);
        }
        var transpose2 = op2({ transpose_ });
        function confusionMatrix_(labels, predictions, numClasses) {
          var $labels = convertToTensor2(labels, "labels", "confusionMatrix");
          var $predictions = convertToTensor2(predictions, "predictions", "confusionMatrix");
          assert2(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), function() {
            return "If provided, numClasses must be a positive integer, " + ("but got " + numClasses);
          });
          assert2($labels.rank === 1, function() {
            return "Expected the rank of labels to be 1, but got " + $labels.rank;
          });
          assert2($predictions.rank === 1, function() {
            return "Expected the rank of predictions to be 1, " + ("but got " + $predictions.rank);
          });
          assert2($labels.shape[0] === $predictions.shape[0], function() {
            return "Mismatch in the number of examples: " + ($labels.shape[0] + " vs. " + $predictions.shape[0] + ". ") + "Labels and predictions should have the same number of elements.";
          });
          assert2(numClasses > 0 && Number.isInteger(numClasses), function() {
            return "numClasses is required to be a positive integer, but got " + ("" + numClasses);
          });
          var oneHotLabels = oneHot2(cast5($labels, "int32"), numClasses);
          var oneHotPredictions = oneHot2(cast5($predictions, "int32"), numClasses);
          var oneHotLabelsT = transpose2(oneHotLabels);
          var product = matMul(oneHotLabelsT, oneHotPredictions);
          return cast5(product, "int32");
        }
        var confusionMatrix = op2({ confusionMatrix_ });
        var math = {
          __proto__: null,
          confusionMatrix
        };
        function tensor3d(values, shape, dtype) {
          assertNonNull2(values);
          if (shape != null && shape.length !== 3) {
            throw new Error("tensor3d() requires shape to have three numbers");
          }
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 3 && inferredShape.length !== 1) {
            throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
          }
          if (inferredShape.length === 1 && shape == null) {
            throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
          }
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        var fromPixels2DContext2;
        function fromPixels_(pixels, numChannels) {
          if (numChannels === void 0) {
            numChannels = 3;
          }
          if (numChannels > 4) {
            throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
          }
          if (pixels == null) {
            throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
          }
          var isPixelData2 = false;
          var isImageData = false;
          var isVideo = false;
          var isImage = false;
          var isCanvasLike = false;
          var isImageBitmap = false;
          if (pixels.data instanceof Uint8Array) {
            isPixelData2 = true;
          } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
            isImageData = true;
          } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
            isVideo = true;
          } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
            isImage = true;
          } else if (pixels.getContext != null) {
            isCanvasLike = true;
          } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
            isImageBitmap = true;
          } else {
            throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, " + ("but was " + pixels.constructor.name));
          }
          if (isVideo) {
            var HAVE_CURRENT_DATA_READY_STATE = 2;
            if (isVideo && pixels.readyState < HAVE_CURRENT_DATA_READY_STATE) {
              throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
            }
          }
          var kernel = getKernel2(FromPixels2, ENGINE2.backendName);
          if (kernel != null) {
            var inputs = { pixels };
            var attrs = { numChannels };
            return ENGINE2.runKernel(FromPixels2, inputs, attrs);
          }
          var _a = isVideo ? [
            pixels.videoWidth,
            pixels.videoHeight
          ] : [pixels.width, pixels.height], width = _a[0], height = _a[1];
          var vals;
          if (isCanvasLike) {
            vals = pixels.getContext("2d").getImageData(0, 0, width, height).data;
          } else if (isImageData || isPixelData2) {
            vals = pixels.data;
          } else if (isImage || isVideo || isImageBitmap) {
            if (fromPixels2DContext2 == null) {
              fromPixels2DContext2 = document.createElement("canvas").getContext("2d");
            }
            fromPixels2DContext2.canvas.width = width;
            fromPixels2DContext2.canvas.height = height;
            fromPixels2DContext2.drawImage(pixels, 0, 0, width, height);
            vals = fromPixels2DContext2.getImageData(0, 0, width, height).data;
          }
          var values;
          if (numChannels === 4) {
            values = new Int32Array(vals);
          } else {
            var numPixels = width * height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
              for (var channel = 0; channel < numChannels; ++channel) {
                values[i * numChannels + channel] = vals[i * 4 + channel];
              }
            }
          }
          var outShape = [height, width, numChannels];
          return tensor3d(values, outShape, "int32");
        }
        function isPixelData(pixels) {
          return pixels != null && pixels.data instanceof Uint8Array;
        }
        function isImageBitmapFullySupported() {
          return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
        }
        function isNonEmptyPixels(pixels) {
          return pixels != null && pixels.width !== 0 && pixels.height !== 0;
        }
        function canWrapPixelsToImageBitmap(pixels) {
          return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
        }
        function fromPixelsAsync(pixels, numChannels) {
          if (numChannels === void 0) {
            numChannels = 3;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var inputs, imageBitmap, e_1;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  inputs = null;
                  if (!(env2().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)))
                    return [3, 5];
                  imageBitmap = void 0;
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, createImageBitmap(pixels, { premultiplyAlpha: "none" })];
                case 2:
                  imageBitmap = _a.sent();
                  return [3, 4];
                case 3:
                  e_1 = _a.sent();
                  imageBitmap = null;
                  return [3, 4];
                case 4:
                  if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
                    inputs = imageBitmap;
                  } else {
                    inputs = pixels;
                  }
                  return [3, 6];
                case 5:
                  inputs = pixels;
                  _a.label = 6;
                case 6:
                  return [2, fromPixels_(inputs, numChannels)];
              }
            });
          });
        }
        function toPixels(img, canvas) {
          return __awaiter2(this, void 0, void 0, function() {
            var $img, originalImgTensor, _a, height, width, depth, data, multiplier, bytes, i, rgba, d, value, j, ctx, imageData;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  $img = convertToTensor2(img, "img", "toPixels");
                  if (!(img instanceof Tensor3)) {
                    originalImgTensor = $img;
                    $img = cast5(originalImgTensor, "int32");
                    originalImgTensor.dispose();
                  }
                  if ($img.rank !== 2 && $img.rank !== 3) {
                    throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + $img.rank + ".");
                  }
                  _a = $img.shape.slice(0, 2), height = _a[0], width = _a[1];
                  depth = $img.rank === 2 ? 1 : $img.shape[2];
                  if (depth > 4 || depth === 2) {
                    throw new Error("toPixels only supports depth of size " + ("1, 3 or 4 but got " + depth));
                  }
                  if ($img.dtype !== "float32" && $img.dtype !== "int32") {
                    throw new Error("Unsupported type for toPixels: " + $img.dtype + ". Please use float32 or int32 tensors.");
                  }
                  return [4, $img.data()];
                case 1:
                  data = _b.sent();
                  multiplier = $img.dtype === "float32" ? 255 : 1;
                  bytes = new Uint8ClampedArray(width * height * 4);
                  for (i = 0; i < height * width; ++i) {
                    rgba = [0, 0, 0, 255];
                    for (d = 0; d < depth; d++) {
                      value = data[i * depth + d];
                      if ($img.dtype === "float32") {
                        if (value < 0 || value > 1) {
                          throw new Error("Tensor values for a float32 Tensor must be in the " + ("range [0 - 1] but encountered " + value + "."));
                        }
                      } else if ($img.dtype === "int32") {
                        if (value < 0 || value > 255) {
                          throw new Error("Tensor values for a int32 Tensor must be in the " + ("range [0 - 255] but encountered " + value + "."));
                        }
                      }
                      if (depth === 1) {
                        rgba[0] = value * multiplier;
                        rgba[1] = value * multiplier;
                        rgba[2] = value * multiplier;
                      } else {
                        rgba[d] = value * multiplier;
                      }
                    }
                    j = i * 4;
                    bytes[j + 0] = Math.round(rgba[0]);
                    bytes[j + 1] = Math.round(rgba[1]);
                    bytes[j + 2] = Math.round(rgba[2]);
                    bytes[j + 3] = Math.round(rgba[3]);
                  }
                  if (canvas != null) {
                    canvas.width = width;
                    canvas.height = height;
                    ctx = canvas.getContext("2d");
                    imageData = new ImageData(bytes, width, height);
                    ctx.putImageData(imageData, 0, 0);
                  }
                  if ($img !== img) {
                    $img.dispose();
                  }
                  return [2, bytes];
              }
            });
          });
        }
        var fromPixels2 = op2({ fromPixels_ });
        var browser2 = {
          __proto__: null,
          fromPixelsAsync,
          toPixels,
          fromPixels: fromPixels2
        };
        function prepareAndValidate2(tensor2, indices) {
          var tensorRank = tensor2.shape.length;
          var indicesRank = indices.shape.length;
          if (tensorRank < 1) {
            throw new Error("tf.gatherND() expects the input to be rank 1 or higher," + (" but the rank was " + tensorRank + "."));
          }
          if (indicesRank < 1) {
            throw new Error("tf.gatherND() expects the indices to be rank 1 or higher," + (" but the rank was " + indicesRank + "."));
          }
          if (indices.dtype !== "int32") {
            throw new Error("tf.gatherND() expects the indices to be int32 type," + (" but the dtype was " + indices.dtype + "."));
          }
          if (indices.shape[indicesRank - 1] > tensorRank) {
            throw new Error("index innermost dimension length must be <= tensor rank; saw: " + (indices.shape[indicesRank - 1] + " vs. " + tensorRank));
          }
          if (sizeFromShape2(tensor2.shape) === 0) {
            throw new Error("Requested more than 0 entries, but input is empty." + (" Input shape: " + tensor2.shape + "."));
          }
          var indicesShape = indices.shape;
          var sliceRank = indicesShape[indicesShape.length - 1];
          var nResult = 1;
          for (var i = 0; i < indicesShape.length - 1; ++i) {
            nResult *= indicesShape[i];
          }
          var inputShape = tensor2.shape;
          var resultShape = indicesShape.slice();
          resultShape.pop();
          var sliceSize = 1;
          for (var i = sliceRank; i < tensorRank; ++i) {
            sliceSize *= inputShape[i];
            resultShape.push(inputShape[i]);
          }
          var strides = computeStrides2(tensor2.shape).map(function(stride) {
            return stride / sliceSize;
          }).concat([1]).slice(0, sliceRank);
          return [resultShape, nResult, sliceSize, strides];
        }
        var gather_nd_util = {
          __proto__: null,
          prepareAndValidate: prepareAndValidate2
        };
        function validateUpdateShape2(shape, indices, updates) {
          var sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
          var batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
          var shapeError = "Must have updates.shape = indices.shape[:batchDim] + " + ("shape[sliceDim:], got updates.shape: " + updates.shape) + (", indices.shape: " + indices.shape + ", shape: " + shape) + (", sliceDim: " + sliceDim + ", and batchDim: " + batchDim + ".");
          if (updates.rank < batchDim) {
            throw new Error(shapeError + (" update.rank < " + batchDim + ". "));
          }
          if (shape.length < sliceDim + (updates.rank - batchDim)) {
            throw new Error(shapeError + (" Output shape length < " + (sliceDim + (updates.rank - batchDim))));
          }
          if (updates.rank !== batchDim + shape.length - sliceDim) {
            throw new Error(shapeError + (" update.rank != " + (batchDim + shape.length - sliceDim)));
          }
          for (var d = 0; d < batchDim; ++d) {
            if (updates.shape[d] !== indices.shape[d]) {
              throw new Error(shapeError + (" updates.shape[" + d + "] (" + updates.shape[d] + ") != indices.shape[" + d + "] (" + indices.shape[d] + ")."));
            }
          }
          for (var d = 0; d < updates.rank - batchDim; ++d) {
            if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
              throw new Error(shapeError + (" updates.shape[" + (d + batchDim) + "] (" + updates.shape[d + batchDim] + ") != shape[" + (d + batchDim) + "] (" + shape[d + batchDim] + ")"));
            }
          }
        }
        function validateInput2(updates, indices, shape) {
          if (indices.rank < 1) {
            throw new Error("tf.scatterND() expects the indices to be rank 1 or higher," + (" but the rank was " + indices.rank + "."));
          }
          if (updates.rank < 1) {
            throw new Error("tf.scatterND() expects the updates to be rank 1 or higher," + (" but the rank was " + updates.rank + "."));
          }
          if (indices.dtype !== "int32") {
            throw new Error("The dtype of 'indices' should be int32, but got dtype: " + indices.dtype);
          }
          if (shape.length < 1) {
            throw new Error("Output rank must be greater or equal to 1, but got shape: " + shape);
          }
          if (shape.length === 0) {
            if (indices.size === 0) {
              throw new Error("Indices specified for empty output. indices shape: " + indices.shape);
            }
            if (updates.size === 0) {
              throw new Error("Updates specified for empty output. updates shape: " + updates.shape);
            }
          }
          validateUpdateShape2(shape, indices, updates);
        }
        function calculateShapes2(updates, indices, shape) {
          var indicesRank = indices.shape.length;
          var sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
          var totalNd = shape.length;
          var sliceSize = 1;
          for (var i = sliceRank; i < totalNd; ++i) {
            sliceSize *= shape[i];
          }
          var safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
          var numUpdates = sizeFromShape2(indices.shape) / safeSliceDim;
          var strides = computeStrides2(shape.slice(0, sliceRank)).concat([1]);
          var outputSize = sizeFromShape2(shape);
          return { sliceRank, numUpdates, sliceSize, strides, outputSize };
        }
        var scatter_nd_util = {
          __proto__: null,
          validateUpdateShape: validateUpdateShape2,
          validateInput: validateInput2,
          calculateShapes: calculateShapes2
        };
        function assertParamsValid2(input, begin, size) {
          var inputRank = input.shape.length;
          assert2(inputRank === begin.length, function() {
            return "Error in slice" + inputRank + "D: Length of begin " + begin + " must " + ("match the rank of the array (" + inputRank + ").");
          });
          assert2(inputRank === size.length, function() {
            return "Error in slice" + inputRank + "D: Length of size " + size + " must " + ("match the rank of the array (" + inputRank + ").");
          });
          var _loop_1 = function(i2) {
            assert2(begin[i2] + size[i2] <= input.shape[i2], function() {
              return "Error in slice" + inputRank + "D: begin[" + i2 + "] + size[" + i2 + "] " + ("(" + (begin[i2] + size[i2]) + ") would overflow input.shape[" + i2 + "] (" + input.shape[i2] + ")");
            });
          };
          for (var i = 0; i < inputRank; ++i) {
            _loop_1(i);
          }
        }
        function maskToAxes2(mask) {
          var axes = [];
          var axis = 0;
          while (mask > 0) {
            if (mask & 1) {
              axes.push(axis);
            }
            mask /= 2;
            axis++;
          }
          return axes;
        }
        function computeOutShape4(begin, end, strides) {
          var size = [];
          for (var axis = 0; axis < begin.length; axis++) {
            size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
          }
          return size;
        }
        function stridesWithElidedDims2(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
          var newStrides = strides.slice();
          for (var i = newStrides.length; i < inputShape.length; i++) {
            newStrides.push(1);
          }
          for (var i = 0; i < numElidedAxes; i++) {
            if (i === 0) {
              newStrides[ellipsisInsertionIndex] = 1;
            } else {
              newStrides.splice(ellipsisInsertionIndex, 0, 1);
              newStrides.pop();
            }
          }
          return newStrides;
        }
        function unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
          if (normalizedAxis <= ellipsisInsertionIndex) {
            return normalizedAxis;
          }
          return normalizedAxis - (numElidedAxes - 1);
        }
        function getElidedAxes2(numElidedAxes, ellipsisInsertionIndex) {
          var elidedAxes = [];
          for (var i = 0; i < numElidedAxes; i++) {
            elidedAxes.push(ellipsisInsertionIndex + i);
          }
          return elidedAxes;
        }
        function getNormalizedAxes2(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
          var inputRank = inputShape.length;
          var normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
          if (ellipsisAxes.length && numInterpolatedAxes > 0) {
            var fullIndex = ellipsisAxes[0];
            var numElidedAxes = numInterpolatedAxes + 1;
            normalizedBegin = startIndicesWithElidedDims2(beginMask, fullIndex, numElidedAxes, begin, inputShape);
            normalizedEnd = stopIndicesWithElidedDims2(endMask, fullIndex, numElidedAxes, end, inputShape);
            normalizedStrides = stridesWithElidedDims2(strides, fullIndex, numElidedAxes, inputShape);
          } else {
            for (var axis = 0; axis < inputRank; axis++) {
              normalizedBegin[axis] = startForAxis2(beginMask, begin, strides, inputShape, axis, ellipsisMask);
              normalizedEnd[axis] = stopForAxis2(endMask, end, strides, inputShape, axis, ellipsisMask);
              normalizedStrides[axis] = stridesForAxis2(strides, axis, ellipsisMask);
            }
          }
          return {
            begin: normalizedBegin,
            end: normalizedEnd,
            strides: normalizedStrides
          };
        }
        function startIndicesWithElidedDims2(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
          var newIndices = inputShape.slice();
          var elidedAxes = getElidedAxes2(numElidedAxes, ellipsisInsertionIndex);
          for (var axis = 0; axis < newIndices.length; axis++) {
            if (elidedAxes.indexOf(axis) > -1) {
              newIndices[axis] = 0;
            } else {
              var originalAxis = unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, axis);
              var originalValue = originalBegin[originalAxis];
              if (beginMask & 1 << originalAxis) {
                originalValue = 0;
              }
              newIndices[axis] = originalValue;
            }
          }
          return newIndices;
        }
        function stopIndicesWithElidedDims2(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
          var newIndices = inputShape.slice();
          var elidedAxes = getElidedAxes2(numElidedAxes, ellipsisInsertionIndex);
          for (var axis = 0; axis < newIndices.length; axis++) {
            if (elidedAxes.indexOf(axis) > -1) {
              newIndices[axis] = Number.MAX_SAFE_INTEGER;
            } else {
              var originalAxis = unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, axis);
              var originalValue = originalEnd[originalAxis];
              if (endMask & 1 << originalAxis) {
                originalValue = Number.MAX_SAFE_INTEGER;
              }
              newIndices[axis] = originalValue;
            }
          }
          for (var i = 0; i < newIndices.length; i++) {
            var axisSize = inputShape[i];
            if (newIndices[i] < 0) {
              newIndices[i] += axisSize;
            }
            newIndices[i] = clamp3(0, newIndices[i], inputShape[i]);
          }
          return newIndices;
        }
        function stridesForAxis2(strides, axis, ellipsisMask) {
          var stride = strides[axis];
          if (ellipsisMask & 1 << axis || stride == null) {
            stride = 1;
          }
          return stride;
        }
        function startForAxis2(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
          var start = startIndices[axis];
          var stride = strides[axis] || 1;
          if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
            if (stride > 0) {
              start = Number.MIN_SAFE_INTEGER;
            } else {
              start = Number.MAX_SAFE_INTEGER;
            }
          }
          var axisSize = inputShape[axis];
          if (start < 0) {
            start += axisSize;
          }
          start = clamp3(0, start, axisSize - 1);
          return start;
        }
        function stopForAxis2(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
          var stop = stopIndices[axis];
          var stride = strides[axis] || 1;
          if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
            if (stride > 0) {
              stop = Number.MAX_SAFE_INTEGER;
            } else {
              stop = Number.MIN_SAFE_INTEGER;
            }
          }
          var axisSize = inputShape[axis];
          if (stop < 0) {
            stop += axisSize;
          }
          if (stride > 0) {
            stop = clamp3(0, stop, axisSize);
          } else {
            stop = clamp3(-1, stop, axisSize - 1);
          }
          return stop;
        }
        function isSliceContinous2(shape, begin, size) {
          var firstNonOneAxis = size.length;
          for (var i = 0; i < size.length; i++) {
            if (size[i] > 1) {
              firstNonOneAxis = i;
              break;
            }
          }
          for (var i = firstNonOneAxis + 1; i < size.length; i++) {
            if (begin[i] > 0 || size[i] !== shape[i]) {
              return false;
            }
          }
          return true;
        }
        function computeFlatOffset2(begin, strides) {
          var flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
          for (var i = 0; i < begin.length - 1; i++) {
            flatOffset += begin[i] * strides[i];
          }
          return flatOffset;
        }
        function parseSliceParams2(x, begin, size) {
          var begin_;
          var xRank = x.shape.length;
          if (typeof begin === "number") {
            begin_ = [begin].concat(new Array(xRank - 1).fill(0));
          } else if (begin.length < xRank) {
            begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
          } else {
            begin_ = begin.slice();
          }
          begin_.forEach(function(d) {
            assert2(d !== -1, function() {
              return "slice() does not support negative begin indexing.";
            });
          });
          var size_;
          if (size == null) {
            size_ = new Array(xRank).fill(-1);
          } else if (typeof size === "number") {
            size_ = [size].concat(new Array(xRank - 1).fill(-1));
          } else if (size.length < xRank) {
            size_ = size.concat(new Array(xRank - size.length).fill(-1));
          } else {
            size_ = size;
          }
          size_ = size_.map(function(d, i) {
            if (d >= 0) {
              return d;
            } else {
              assert2(d === -1, function() {
                return "Negative size values should be exactly -1 but got " + (d + " for the slice() size at index " + i + ".");
              });
              return x.shape[i] - begin_[i];
            }
          });
          return [begin_, size_];
        }
        function sliceInfo2(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
          var $begin = begin.slice();
          var $end = end.slice();
          var $strides = strides;
          if (strides == null) {
            $strides = new Array($begin.length);
          }
          var ellipsisAxes = maskToAxes2(ellipsisMask);
          if (ellipsisAxes.length > 1) {
            throw new Error("Multiple ellipses in slice is not allowed.");
          }
          if (ellipsisMask !== 0 && newAxisMask !== 0) {
            throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
          }
          if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
            throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
          }
          var numInterpolatedAxes = xShape.length - $begin.length;
          var expandAxes = maskToAxes2(newAxisMask);
          var newShape = xShape.slice();
          expandAxes.forEach(function(axis) {
            $begin[axis] = 0;
            $end[axis] = 1;
            newShape.splice(axis, 0, 1);
          });
          var _a = getNormalizedAxes2(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask), normalizedBegin = _a.begin, normalizedEnd = _a.end, normalizedStrides = _a.strides;
          $begin = normalizedBegin;
          $end = normalizedEnd;
          $strides = normalizedStrides;
          var shrinkAxes = maskToAxes2(shrinkAxisMask);
          shrinkAxes.forEach(function(axis) {
            $end[axis] = $begin[axis] + 1;
            $strides[axis] = 1;
          });
          var size = computeOutShape4($begin, $end, $strides);
          var outShape = size.filter(function(_, axis) {
            return shrinkAxes.indexOf(axis) === -1;
          });
          var nonStrided = $strides.every(function(v) {
            return v === 1;
          });
          return { nonStrided, $begin, $end, $strides, size, newShape, outShape };
        }
        var slice_util = {
          __proto__: null,
          assertParamsValid: assertParamsValid2,
          maskToAxes: maskToAxes2,
          computeOutShape: computeOutShape4,
          stridesWithElidedDims: stridesWithElidedDims2,
          getNormalizedAxes: getNormalizedAxes2,
          startIndicesWithElidedDims: startIndicesWithElidedDims2,
          stopIndicesWithElidedDims: stopIndicesWithElidedDims2,
          stridesForAxis: stridesForAxis2,
          startForAxis: startForAxis2,
          stopForAxis: stopForAxis2,
          isSliceContinous: isSliceContinous2,
          computeFlatOffset: computeFlatOffset2,
          parseSliceParams: parseSliceParams2,
          sliceInfo: sliceInfo2
        };
        var Serializable = function() {
          function Serializable2() {
          }
          Serializable2.prototype.getClassName = function() {
            return this.constructor.className;
          };
          Serializable2.fromConfig = function(cls, config) {
            return new cls(config);
          };
          return Serializable2;
        }();
        var SerializationMap = function() {
          function SerializationMap2() {
            this.classNameMap = {};
          }
          SerializationMap2.getMap = function() {
            if (SerializationMap2.instance == null) {
              SerializationMap2.instance = new SerializationMap2();
            }
            return SerializationMap2.instance;
          };
          SerializationMap2.register = function(cls) {
            SerializationMap2.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
          };
          return SerializationMap2;
        }();
        function registerClass(cls) {
          assert2(cls.className != null, function() {
            return "Class being registered does not have the static className property defined.";
          });
          assert2(typeof cls.className === "string", function() {
            return "className is required to be a string, but got type " + typeof cls.className;
          });
          assert2(cls.className.length > 0, function() {
            return "Class being registered has an empty-string as its className, which is disallowed.";
          });
          SerializationMap.register(cls);
        }
        var serialization = {
          __proto__: null,
          Serializable,
          SerializationMap,
          registerClass
        };
        var TEST_EPSILON_FLOAT32 = 1e-3;
        var TEST_EPSILON_FLOAT16 = 0.1;
        function expectArraysClose(actual, expected, epsilon) {
          if (epsilon == null) {
            epsilon = testEpsilon();
          }
          return expectArraysPredicate(actual, expected, function(a, b) {
            return areClose(a, b, epsilon);
          });
        }
        function testEpsilon() {
          return ENGINE2.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
        }
        function expectArraysPredicate(actual, expected, predicate) {
          var checkClassType = true;
          if (isTypedArray2(actual) || isTypedArray2(expected)) {
            checkClassType = false;
          }
          if (isTypedArray2(actual) && isTypedArray2(expected)) {
            checkClassType = true;
          }
          if (checkClassType) {
            var aType = actual.constructor.name;
            var bType = expected.constructor.name;
            if (aType !== bType) {
              throw new Error("Arrays are of different type. Actual: " + aType + ". " + ("Expected: " + bType));
            }
          }
          if (Array.isArray(actual) && Array.isArray(expected)) {
            var actualShape = inferShape2(actual);
            var expectedShape = inferShape2(expected);
            if (!arraysEqual2(actualShape, expectedShape)) {
              throw new Error("Arrays have different shapes. " + ("Actual: [" + actualShape + "]. Expected: [" + expectedShape + "]"));
            }
          }
          var actualFlat = isTypedArray2(actual) ? actual : flatten2(actual);
          var expectedFlat = isTypedArray2(expected) ? expected : flatten2(expected);
          if (actualFlat.length !== expectedFlat.length) {
            throw new Error("Arrays have different lengths actual: " + actualFlat.length + " vs " + ("expected: " + expectedFlat.length + ".\n") + ("Actual:   " + actualFlat + ".\n") + ("Expected: " + expectedFlat + "."));
          }
          for (var i = 0; i < expectedFlat.length; ++i) {
            var a = actualFlat[i];
            var e = expectedFlat[i];
            if (!predicate(a, e)) {
              throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" + ("Actual:   " + actualFlat + ".\n") + ("Expected: " + expectedFlat + "."));
            }
          }
        }
        function expectPromiseToFail(fn, done) {
          fn().then(function() {
            return done.fail();
          }, function() {
            return done();
          });
        }
        function expectArraysEqual(actual, expected) {
          var exp4 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
          if (isString3(actual) || isString3(actual[0]) || isString3(expected) || isString3(expected[0])) {
            return expectArraysPredicate(actual, exp4, function(a, b) {
              return a == b;
            });
          }
          return expectArraysPredicate(actual, expected, function(a, b) {
            return areClose(a, b, 0);
          });
        }
        function expectNumbersClose(a, e, epsilon) {
          if (epsilon == null) {
            epsilon = testEpsilon();
          }
          if (!areClose(a, e, epsilon)) {
            throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
          }
        }
        function areClose(a, e, epsilon) {
          if (!isFinite(a) && !isFinite(e)) {
            return true;
          }
          if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
            return false;
          }
          return true;
        }
        function expectValuesInRange(actual, low, high) {
          for (var i = 0; i < actual.length; i++) {
            if (actual[i] < low || actual[i] > high) {
              throw new Error("Value out of range:" + actual[i] + " low: " + low + ", high: " + high);
            }
          }
        }
        function expectArrayBuffersEqual(actual, expected) {
          expect(new Float32Array(actual)).toEqual(new Float32Array(expected));
        }
        function encodeStrings(a) {
          for (var i = 0; i < a.length; i++) {
            var val = a[i];
            if (Array.isArray(val)) {
              encodeStrings(val);
            } else {
              a[i] = encodeString2(val);
            }
          }
          return a;
        }
        var test_util = {
          __proto__: null,
          TEST_EPSILON_FLOAT16,
          expectArraysClose,
          testEpsilon,
          expectPromiseToFail,
          expectArraysEqual,
          expectNumbersClose,
          expectValuesInRange,
          expectArrayBuffersEqual,
          encodeStrings
        };
        var version = "3.6.0";
        function enableProdMode() {
          env2().set("PROD", true);
        }
        function enableDebugMode() {
          env2().set("DEBUG", true);
        }
        function disableDeprecationWarnings() {
          env2().set("DEPRECATION_WARNINGS_ENABLED", false);
          console.warn("TensorFlow.js deprecation warnings have been disabled.");
        }
        function deprecationWarn2(msg) {
          if (env2().getBool("DEPRECATION_WARNINGS_ENABLED")) {
            console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
          }
        }
        function disposeVariables() {
          ENGINE2.disposeVariables();
        }
        function engine2() {
          return ENGINE2;
        }
        function memory() {
          return ENGINE2.memory();
        }
        function profile(f) {
          return ENGINE2.profile(f);
        }
        function tidy3(nameOrFn, fn) {
          return ENGINE2.tidy(nameOrFn, fn);
        }
        function dispose(container) {
          var tensors = getTensorsInContainer2(container);
          tensors.forEach(function(tensor2) {
            return tensor2.dispose();
          });
        }
        function keep(result2) {
          return ENGINE2.keep(result2);
        }
        function time(f) {
          return ENGINE2.time(f);
        }
        function setBackend(backendName) {
          return ENGINE2.setBackend(backendName);
        }
        function ready() {
          return ENGINE2.ready();
        }
        function getBackend() {
          return ENGINE2.backendName;
        }
        function removeBackend(name) {
          ENGINE2.removeBackend(name);
        }
        function findBackend(name) {
          return ENGINE2.findBackend(name);
        }
        function findBackendFactory(name) {
          return ENGINE2.findBackendFactory(name);
        }
        function registerBackend2(name, factory, priority) {
          if (priority === void 0) {
            priority = 1;
          }
          return ENGINE2.registerBackend(name, factory, priority);
        }
        function backend() {
          return ENGINE2.backend;
        }
        function setPlatform(platformName, platform) {
          env2().setPlatform(platformName, platform);
        }
        function add_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "add");
          var $b = convertToTensor2(b, "b", "add");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Add2, inputs);
        }
        var add$1 = op2({ add_ });
        function floorDiv_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "floorDiv");
          var $b = convertToTensor2(b, "b", "floorDiv");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(FloorDiv2, inputs);
        }
        var floorDiv2 = op2({ floorDiv_ });
        function div_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "div");
          var $b = convertToTensor2(b, "b", "div");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          if ($a.dtype === "int32" && $b.dtype === "int32") {
            return floorDiv2($a, $b);
          }
          var inputs = { a: $a, b: $b };
          var attrs = {};
          return ENGINE2.runKernel(RealDiv2, inputs, attrs);
        }
        var div2 = op2({ div_ });
        function mul_2(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "mul");
          var $b = convertToTensor2(b, "b", "mul");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Multiply2, inputs);
        }
        var mul3 = op2({ mul_: mul_2 });
        function abs_(x) {
          var $x = convertToTensor2(x, "x", "abs");
          if ($x.dtype === "complex64") {
            var inputs = { x: $x };
            return ENGINE2.runKernel(ComplexAbs2, inputs);
          } else {
            var inputs = { x: $x };
            return ENGINE2.runKernel(Abs2, inputs);
          }
        }
        var abs2 = op2({ abs_ });
        function acos_(x) {
          var $x = convertToTensor2(x, "x", "acos");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Acos2, inputs);
        }
        var acos2 = op2({ acos_ });
        function acosh_(x) {
          var $x = convertToTensor2(x, "x", "acosh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Acosh2, inputs);
        }
        var acosh2 = op2({ acosh_ });
        function addN_(tensors) {
          assert2(Array.isArray(tensors), function() {
            return "The argument passed to tf.addN() must be a list of tensors";
          });
          assert2(tensors.length >= 1, function() {
            return "Must pass at least one tensor to tf.addN(), but got " + ("" + tensors.length);
          });
          var $tensors = tensors.map(function(t, i) {
            return convertToTensor2(t, "tensors" + i, "addN");
          });
          var firstTensor = $tensors[0];
          $tensors.forEach(function(t) {
            if (t.dtype !== firstTensor.dtype) {
              throw new Error("All tensors passed to tf.addN() must have the same dtype");
            }
          });
          $tensors.forEach(function(t) {
            if (!arraysEqual2(t.shape, firstTensor.shape)) {
              throw new Error("All tensors passed to tf.addN() must have the same shape");
            }
          });
          var inputs = $tensors;
          return ENGINE2.runKernel(AddN2, inputs);
        }
        var addN2 = op2({ addN_ });
        function all_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "all", "bool");
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(All2, inputs, attrs);
        }
        var all2 = op2({ all_ });
        function any_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "any", "bool");
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(Any2, inputs, attrs);
        }
        var any2 = op2({ any_ });
        function argMax_(x, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "argMax");
          var inputs = { x: $x };
          var attrs = { axis };
          return ENGINE2.runKernel(ArgMax2, inputs, attrs);
        }
        var argMax3 = op2({ argMax_ });
        function argMin_(x, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "argMin");
          var inputs = { x: $x };
          var attrs = { axis };
          return ENGINE2.runKernel(ArgMin2, inputs, attrs);
        }
        var argMin2 = op2({ argMin_ });
        function asin_(x) {
          var $x = convertToTensor2(x, "x", "asin");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Asin2, inputs);
        }
        var asin2 = op2({ asin_ });
        function asinh_(x) {
          var $x = convertToTensor2(x, "x", "asinh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Asinh2, inputs);
        }
        var asinh2 = op2({ asinh_ });
        function atan_(x) {
          var $x = convertToTensor2(x, "x", "atan");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Atan3, inputs);
        }
        var atan3 = op2({ atan_ });
        function atan2_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "atan2");
          var $b = convertToTensor2(b, "b", "atan2");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Atan22, inputs);
        }
        var atan22 = op2({ atan2_ });
        function atanh_(x) {
          var $x = convertToTensor2(x, "x", "atanh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Atanh2, inputs);
        }
        var atanh2 = op2({ atanh_ });
        function computeDilation2DInfo2(inputShape, filterShape, strides, pad2, dataFormat, dilations) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          var inputChannels = inputShape[3];
          var $filterShape = filterShape.concat([inputChannels]);
          var $dataFormat = convertConv2DDataFormat2(dataFormat);
          return computeConv2DInfo2(inputShape, $filterShape, strides, dilations, pad2, null, null, $dataFormat);
        }
        function computePool2DInfo2(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat) {
          if (dataFormat === void 0) {
            dataFormat = "channelsLast";
          }
          var _a = parseTupleParam2(filterSize), filterHeight = _a[0], filterWidth = _a[1];
          var filterShape;
          if (dataFormat === "channelsLast") {
            filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
          } else if (dataFormat === "channelsFirst") {
            filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
          } else {
            throw new Error("Unknown dataFormat " + dataFormat);
          }
          return computeConv2DInfo2(inShape, filterShape, strides, dilations, pad2, roundingMode, false, dataFormat);
        }
        function computePool3DInfo2(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat) {
          if (dataFormat === void 0) {
            dataFormat = "NDHWC";
          }
          var _a = parse3TupleParam2(filterSize), filterDepth = _a[0], filterHeight = _a[1], filterWidth = _a[2];
          var filterShape;
          var $dataFormat;
          if (dataFormat === "NDHWC") {
            $dataFormat = "channelsLast";
            filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
          } else if (dataFormat === "NCDHW") {
            $dataFormat = "channelsFirst";
            filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
          } else {
            throw new Error("Unknown dataFormat " + dataFormat);
          }
          return computeConv3DInfo2(inShape, filterShape, strides, dilations, pad2, false, $dataFormat, roundingMode);
        }
        function computeConv2DInfo2(inShape, filterShape, strides, dilations, pad2, roundingMode, depthwise, dataFormat) {
          if (depthwise === void 0) {
            depthwise = false;
          }
          if (dataFormat === void 0) {
            dataFormat = "channelsLast";
          }
          var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
          if (dataFormat === "channelsLast") {
            batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
          } else if (dataFormat === "channelsFirst") {
            batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
          } else {
            throw new Error("Unknown dataFormat " + dataFormat);
          }
          var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
          var _b = parseTupleParam2(strides), strideHeight = _b[0], strideWidth = _b[1];
          var _c = parseTupleParam2(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
          var effectiveFilterHeight = getEffectiveFilterSize2(filterHeight, dilationHeight);
          var effectiveFilterWidth = getEffectiveFilterSize2(filterWidth, dilationWidth);
          var _d = getPadAndOutInfo2(pad2, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat), padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
          var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
          var outShape;
          if (dataFormat === "channelsFirst") {
            outShape = [batchSize, outChannels, outHeight, outWidth];
          } else if (dataFormat === "channelsLast") {
            outShape = [batchSize, outHeight, outWidth, outChannels];
          }
          return {
            batchSize,
            dataFormat,
            inHeight,
            inWidth,
            inChannels,
            outHeight,
            outWidth,
            outChannels,
            padInfo,
            strideHeight,
            strideWidth,
            filterHeight,
            filterWidth,
            effectiveFilterHeight,
            effectiveFilterWidth,
            dilationHeight,
            dilationWidth,
            inShape,
            outShape,
            filterShape
          };
        }
        function computeConv3DInfo2(inShape, filterShape, strides, dilations, pad2, depthwise, dataFormat, roundingMode) {
          if (depthwise === void 0) {
            depthwise = false;
          }
          if (dataFormat === void 0) {
            dataFormat = "channelsLast";
          }
          var _a = [-1, -1, -1, -1, -1], batchSize = _a[0], inDepth = _a[1], inHeight = _a[2], inWidth = _a[3], inChannels = _a[4];
          if (dataFormat === "channelsLast") {
            batchSize = inShape[0], inDepth = inShape[1], inHeight = inShape[2], inWidth = inShape[3], inChannels = inShape[4];
          } else if (dataFormat === "channelsFirst") {
            batchSize = inShape[0], inChannels = inShape[1], inDepth = inShape[2], inHeight = inShape[3], inWidth = inShape[4];
          } else {
            throw new Error("Unknown dataFormat " + dataFormat);
          }
          var filterDepth = filterShape[0], filterHeight = filterShape[1], filterWidth = filterShape[2], filterChannels = filterShape[4];
          var _b = parse3TupleParam2(strides), strideDepth = _b[0], strideHeight = _b[1], strideWidth = _b[2];
          var _c = parse3TupleParam2(dilations), dilationDepth = _c[0], dilationHeight = _c[1], dilationWidth = _c[2];
          var effectiveFilterDepth = getEffectiveFilterSize2(filterDepth, dilationDepth);
          var effectiveFilterHeight = getEffectiveFilterSize2(filterHeight, dilationHeight);
          var effectiveFilterWidth = getEffectiveFilterSize2(filterWidth, dilationWidth);
          var _d = get3DPadAndOutInfo2(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode), padInfo = _d.padInfo, outDepth = _d.outDepth, outHeight = _d.outHeight, outWidth = _d.outWidth;
          var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
          var outShape;
          if (dataFormat === "channelsFirst") {
            outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
          } else if (dataFormat === "channelsLast") {
            outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
          }
          return {
            batchSize,
            dataFormat,
            inDepth,
            inHeight,
            inWidth,
            inChannels,
            outDepth,
            outHeight,
            outWidth,
            outChannels,
            padInfo,
            strideDepth,
            strideHeight,
            strideWidth,
            filterDepth,
            filterHeight,
            filterWidth,
            effectiveFilterDepth,
            effectiveFilterHeight,
            effectiveFilterWidth,
            dilationDepth,
            dilationHeight,
            dilationWidth,
            inShape,
            outShape,
            filterShape
          };
        }
        function computeOutputShape2D2(inShape, fieldSize, stride, zeroPad, roundingMode) {
          if (zeroPad == null) {
            zeroPad = computeDefaultPad2(inShape, fieldSize, stride);
          }
          var inputRows = inShape[0];
          var inputCols = inShape[1];
          var outputRows = round3((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
          var outputCols = round3((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
          return [outputRows, outputCols];
        }
        function computeOutputShape4D2(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
          if (zeroPad == null) {
            zeroPad = computeDefaultPad2(inShape, fieldSize, stride);
          }
          var inputDepth = inShape[0];
          var inputRows = inShape[1];
          var inputCols = inShape[2];
          var outputDepths = round3((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
          var outputRows = round3((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
          var outputCols = round3((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
          return [outputDepths, outputRows, outputCols, outChannels];
        }
        function computeDefaultPad2(inputShape, fieldSize, stride, dilation) {
          if (dilation === void 0) {
            dilation = 1;
          }
          var effectiveFieldSize = getEffectiveFilterSize2(fieldSize, dilation);
          return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
        }
        function parseTupleParam2(param) {
          if (typeof param === "number") {
            return [param, param, param];
          }
          if (param.length === 2) {
            return [param[0], param[1], 1];
          }
          return param;
        }
        function parse3TupleParam2(param) {
          return typeof param === "number" ? [param, param, param] : param;
        }
        function getEffectiveFilterSize2(filterSize, dilation) {
          if (dilation <= 1) {
            return filterSize;
          }
          return filterSize + (filterSize - 1) * (dilation - 1);
        }
        function getPadAndOutInfo2(pad2, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
          var padInfo;
          var outHeight;
          var outWidth;
          if (typeof pad2 === "number") {
            var padType = pad2 === 0 ? "VALID" : "NUMBER";
            padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, type: padType };
            var outShape = computeOutputShape2D2([inHeight, inWidth], filterHeight, strideHeight, pad2, roundingMode);
            outHeight = outShape[0];
            outWidth = outShape[1];
          } else if (pad2 === "same") {
            outHeight = Math.ceil(inHeight / strideHeight);
            outWidth = Math.ceil(inWidth / strideWidth);
            var padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
            var padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
            var top_1 = Math.floor(padAlongHeight / 2);
            var bottom = padAlongHeight - top_1;
            var left = Math.floor(padAlongWidth / 2);
            var right = padAlongWidth - left;
            padInfo = { top: top_1, bottom, left, right, type: "SAME" };
          } else if (pad2 === "valid") {
            padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
            outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
            outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
          } else if (typeof pad2 === "object") {
            var top_2 = dataFormat === "channelsLast" ? pad2[1][0] : pad2[2][0];
            var bottom = dataFormat === "channelsLast" ? pad2[1][1] : pad2[2][1];
            var left = dataFormat === "channelsLast" ? pad2[2][0] : pad2[3][0];
            var right = dataFormat === "channelsLast" ? pad2[2][1] : pad2[3][1];
            var padType = top_2 === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
            padInfo = { top: top_2, bottom, left, right, type: padType };
            outHeight = round3((inHeight - filterHeight + top_2 + bottom) / strideHeight + 1, roundingMode);
            outWidth = round3((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
          } else {
            throw Error("Unknown padding parameter: " + pad2);
          }
          return { padInfo, outHeight, outWidth };
        }
        function get3DPadAndOutInfo2(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
          var padInfo;
          var outDepth;
          var outHeight;
          var outWidth;
          if (typeof pad2 === "number") {
            var padType = pad2 === 0 ? "VALID" : "NUMBER";
            padInfo = {
              top: pad2,
              bottom: pad2,
              left: pad2,
              right: pad2,
              front: pad2,
              back: pad2,
              type: padType
            };
            var outShape = computeOutputShape4D2([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad2, roundingMode);
            outDepth = outShape[0];
            outHeight = outShape[1];
            outWidth = outShape[2];
          } else if (pad2 === "same") {
            outDepth = Math.ceil(inDepth / strideDepth);
            outHeight = Math.ceil(inHeight / strideHeight);
            outWidth = Math.ceil(inWidth / strideWidth);
            var padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
            var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
            var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
            var front = Math.floor(padAlongDepth / 2);
            var back = padAlongDepth - front;
            var top_3 = Math.floor(padAlongHeight / 2);
            var bottom = padAlongHeight - top_3;
            var left = Math.floor(padAlongWidth / 2);
            var right = padAlongWidth - left;
            padInfo = { top: top_3, bottom, left, right, front, back, type: "SAME" };
          } else if (pad2 === "valid") {
            padInfo = {
              top: 0,
              bottom: 0,
              left: 0,
              right: 0,
              front: 0,
              back: 0,
              type: "VALID"
            };
            outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
            outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
            outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
          } else {
            throw Error("Unknown padding parameter: " + pad2);
          }
          return { padInfo, outDepth, outHeight, outWidth };
        }
        function round3(value, roundingMode) {
          if (!roundingMode) {
            return Math.trunc(value);
          }
          switch (roundingMode) {
            case "round":
              return Math.round(value);
            case "ceil":
              return Math.ceil(value);
            case "floor":
              return Math.floor(value);
            default:
              throw new Error("Unknown roundingMode " + roundingMode);
          }
        }
        function tupleValuesAreOne2(param) {
          var _a = parseTupleParam2(param), dimA = _a[0], dimB = _a[1], dimC = _a[2];
          return dimA === 1 && dimB === 1 && dimC === 1;
        }
        function eitherStridesOrDilationsAreOne2(strides, dilations) {
          return tupleValuesAreOne2(strides) || tupleValuesAreOne2(dilations);
        }
        function convertConv2DDataFormat2(dataFormat) {
          if (dataFormat === "NHWC") {
            return "channelsLast";
          } else if (dataFormat === "NCHW") {
            return "channelsFirst";
          } else {
            throw new Error("Unknown dataFormat " + dataFormat);
          }
        }
        function reshape_2(x, shape) {
          var $x = convertToTensor2(x, "x", "reshape", "string_or_numeric");
          var inputs = { x: $x };
          var attrs = { shape };
          return ENGINE2.runKernel(Reshape2, inputs, attrs);
        }
        var reshape4 = op2({ reshape_: reshape_2 });
        function avgPool_(x, filterSize, strides, pad2, dimRoundingMode) {
          var $x = convertToTensor2(x, "x", "avgPool", "float32");
          var dilations = 1;
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in avgPool: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".";
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in avgPool: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x4D };
          var attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
          var res = ENGINE2.runKernel(AvgPool2, inputs, attrs);
          res = cast5(res, $x.dtype);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var avgPool2 = op2({ avgPool_ });
        function avgPool3d_(x, filterSize, strides, pad2, dimRoundingMode, dataFormat) {
          if (dataFormat === void 0) {
            dataFormat = "NDHWC";
          }
          var $x = convertToTensor2(x, "x", "avgPool3d", "float32");
          var x5D = $x;
          var reshapedTo5D = false;
          if ($x.rank === 4) {
            reshapedTo5D = true;
            x5D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
          }
          assert2(x5D.rank === 5, function() {
            return "Error in avgPool3d: x must be rank 5 but got rank " + x5D.rank + ".";
          });
          assert2(dataFormat === "NDHWC", function() {
            return "Error in avgPool3d: Only NDHWC is currently supported, " + ("but got dataFormat of " + dataFormat);
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in avgPool3d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x5D };
          var attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
          var res = ENGINE2.runKernel(AvgPool3D2, inputs, attrs);
          res = cast5(res, x5D.dtype);
          if (reshapedTo5D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
          }
          return res;
        }
        var avgPool3d = op2({ avgPool3d_ });
        function concat_(tensors, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          assert2(tensors.length >= 1, function() {
            return "Pass at least one tensor to concat";
          });
          var $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
          if ($tensors[0].dtype === "complex64") {
            $tensors.forEach(function(tensor2) {
              if (tensor2.dtype !== "complex64") {
                throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + tensor2.dtype + ". ");
              }
            });
          }
          if ($tensors.length === 1) {
            return clone2($tensors[0]);
          }
          var inputs = $tensors;
          var attr = { axis };
          return ENGINE2.runKernel(Concat2, inputs, attr);
        }
        var concat3 = op2({ concat_ });
        function sigmoid_2(x) {
          var $x = convertToTensor2(x, "x", "sigmoid");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Sigmoid2, inputs);
        }
        var sigmoid4 = op2({ sigmoid_: sigmoid_2 });
        function slice_(x, begin, size) {
          var $x = convertToTensor2(x, "x", "slice", "string_or_numeric");
          if ($x.rank === 0) {
            throw new Error("Slicing scalar is not possible");
          }
          var inputs = { x: $x };
          var attrs = { begin, size };
          return ENGINE2.runKernel(Slice2, inputs, attrs);
        }
        var slice2 = op2({ slice_ });
        function tanh_(x) {
          var $x = convertToTensor2(x, "x", "tanh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Tanh2, inputs);
        }
        var tanh$1 = op2({ tanh_ });
        function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
          var $forgetBias = convertToTensor2(forgetBias, "forgetBias", "basicLSTMCell");
          var $lstmKernel = convertToTensor2(lstmKernel, "lstmKernel", "basicLSTMCell");
          var $lstmBias = convertToTensor2(lstmBias, "lstmBias", "basicLSTMCell");
          var $data = convertToTensor2(data, "data", "basicLSTMCell");
          var $c = convertToTensor2(c, "c", "basicLSTMCell");
          var $h = convertToTensor2(h, "h", "basicLSTMCell");
          var combined = concat3([$data, $h], 1);
          var weighted = matMul(combined, $lstmKernel);
          var res = add$1(weighted, $lstmBias);
          var batchSize = res.shape[0];
          var sliceCols = res.shape[1] / 4;
          var sliceSize = [batchSize, sliceCols];
          var i = slice2(res, [0, 0], sliceSize);
          var j = slice2(res, [0, sliceCols], sliceSize);
          var f = slice2(res, [0, sliceCols * 2], sliceSize);
          var o = slice2(res, [0, sliceCols * 3], sliceSize);
          var newC = add$1(mul3(sigmoid4(i), tanh$1(j)), mul3($c, sigmoid4(add$1($forgetBias, f))));
          var newH = mul3(tanh$1(newC), sigmoid4(o));
          return [newC, newH];
        }
        var basicLSTMCell = op2({ basicLSTMCell_ });
        function batchToSpaceND_(x, blockShape, crops) {
          var $x = convertToTensor2(x, "x", "batchToSpaceND");
          var prod3 = blockShape.reduce(function(a, b) {
            return a * b;
          });
          assert2($x.rank >= 1 + blockShape.length, function() {
            return "input rank is " + $x.rank + " but should be > than blockShape.length " + blockShape.length;
          });
          assert2(crops.length === blockShape.length, function() {
            return "crops.length is " + crops.length + " but should be equal to blockShape.length  " + blockShape.length;
          });
          assert2($x.shape[0] % prod3 === 0, function() {
            return "input tensor batch is " + $x.shape[0] + " but is not divisible by the product of " + ("the elements of blockShape " + blockShape.join(" * ") + " === " + prod3);
          });
          var inputs = { x: $x };
          var attrs = { blockShape, crops };
          return ENGINE2.runKernel(BatchToSpaceND2, inputs, attrs);
        }
        var batchToSpaceND2 = op2({ batchToSpaceND_ });
        function xAs4D(x) {
          var x4D;
          if (x.rank === 0 || x.rank === 1) {
            x4D = reshape4(x, [1, 1, 1, x.size]);
          } else if (x.rank === 2) {
            x4D = reshape4(x, [1, 1, x.shape[0], x.shape[1]]);
          } else if (x.rank === 3) {
            x4D = reshape4(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
          } else {
            x4D = x;
          }
          return x4D;
        }
        function batchNorm_(x, mean2, variance, offset, scale, varianceEpsilon) {
          if (varianceEpsilon == null) {
            varianceEpsilon = 1e-3;
          }
          var $x = convertToTensor2(x, "x", "batchNorm");
          var $mean = convertToTensor2(mean2, "mean", "batchNorm");
          var $variance = convertToTensor2(variance, "variance", "batchNorm");
          var $scale;
          if (scale != null) {
            $scale = convertToTensor2(scale, "scale", "batchNorm");
          }
          var $offset;
          if (offset != null) {
            $offset = convertToTensor2(offset, "offset", "batchNorm");
          }
          assert2($mean.rank === $variance.rank, function() {
            return "Batch normalization gradient requires mean and variance to have equal ranks.";
          });
          assert2($offset == null || $mean.rank === $offset.rank, function() {
            return "Batch normalization gradient requires mean and offset to have equal ranks.";
          });
          assert2($scale == null || $mean.rank === $scale.rank, function() {
            return "Batch normalization gradient requires mean and scale to have equal ranks.";
          });
          var x4D = xAs4D($x);
          var inputs = {
            x: x4D,
            scale: $scale,
            offset: $offset,
            mean: $mean,
            variance: $variance
          };
          var attrs = { varianceEpsilon };
          var res = ENGINE2.runKernel(FusedBatchNorm2, inputs, attrs);
          return reshape4(res, $x.shape);
        }
        var batchNorm2 = op2({ batchNorm_ });
        function batchNorm2d_(x, mean2, variance, offset, scale, varianceEpsilon) {
          var $x = convertToTensor2(x, "x", "batchNorm");
          var $mean = convertToTensor2(mean2, "mean", "batchNorm");
          var $variance = convertToTensor2(variance, "variance", "batchNorm");
          var $scale;
          if (scale != null) {
            $scale = convertToTensor2(scale, "scale", "batchNorm");
          }
          var $offset;
          if (offset != null) {
            $offset = convertToTensor2(offset, "offset", "batchNorm");
          }
          assert2($x.rank === 2, function() {
            return "Error in batchNorm2D: x must be rank 2 but got rank " + ($x.rank + ".");
          });
          assert2($mean.rank === 2 || $mean.rank === 1, function() {
            return "Error in batchNorm2D: mean must be rank 2 or rank 1 but " + ("got rank " + $mean.rank + ".");
          });
          assert2($variance.rank === 2 || $variance.rank === 1, function() {
            return "Error in batchNorm2D: variance must be rank 2 or rank 1 " + ("but got rank " + $variance.rank + ".");
          });
          if ($scale != null) {
            assert2($scale.rank === 2 || $scale.rank === 1, function() {
              return "Error in batchNorm2D: scale must be rank 2 or rank 1 " + ("but got rank " + $scale.rank + ".");
            });
          }
          if ($offset != null) {
            assert2($offset.rank === 2 || $offset.rank === 1, function() {
              return "Error in batchNorm2D: offset must be rank 2 or rank 1 " + ("but got rank " + $offset.rank + ".");
            });
          }
          return batchNorm2($x, $mean, $variance, $offset, $scale, varianceEpsilon);
        }
        var batchNorm2d = op2({ batchNorm2d_ });
        function batchNorm3d_(x, mean2, variance, offset, scale, varianceEpsilon) {
          var $x = convertToTensor2(x, "x", "batchNorm");
          var $mean = convertToTensor2(mean2, "mean", "batchNorm");
          var $variance = convertToTensor2(variance, "variance", "batchNorm");
          var $scale;
          if (scale != null) {
            $scale = convertToTensor2(scale, "scale", "batchNorm");
          }
          var $offset;
          if (offset != null) {
            $offset = convertToTensor2(offset, "offset", "batchNorm");
          }
          assert2($x.rank === 3, function() {
            return "Error in batchNorm3D: x must be rank 3 but got rank " + ($x.rank + ".");
          });
          assert2($mean.rank === 3 || $mean.rank === 1, function() {
            return "Error in batchNorm3D: mean must be rank 3 or rank 1 but " + ("got rank " + $mean.rank + ".");
          });
          assert2($variance.rank === 3 || $variance.rank === 1, function() {
            return "Error in batchNorm3D: variance must be rank 3 or rank 1 " + ("but got rank " + $variance.rank + ".");
          });
          if ($scale != null) {
            assert2($scale.rank === 3 || $scale.rank === 1, function() {
              return "Error in batchNorm3D: scale must be rank 3 or rank 1 " + ("but got rank " + $scale.rank + ".");
            });
          }
          if ($offset != null) {
            assert2($offset.rank === 3 || $offset.rank === 1, function() {
              return "Error in batchNorm3D: offset must be rank 3 or rank 1 " + ("but got rank " + $offset.rank + ".");
            });
          }
          return batchNorm2($x, $mean, $variance, $offset, $scale, varianceEpsilon);
        }
        var batchNorm3d = op2({ batchNorm3d_ });
        function batchNorm4d_(x, mean2, variance, offset, scale, varianceEpsilon) {
          var $x = convertToTensor2(x, "x", "batchNorm");
          var $mean = convertToTensor2(mean2, "mean", "batchNorm");
          var $variance = convertToTensor2(variance, "variance", "batchNorm");
          var $scale;
          if (scale != null) {
            $scale = convertToTensor2(scale, "scale", "batchNorm");
          }
          var $offset;
          if (offset != null) {
            $offset = convertToTensor2(offset, "offset", "batchNorm");
          }
          assert2($x.rank === 4, function() {
            return "Error in batchNorm4D: x must be rank 4 but got rank " + ($x.rank + ".");
          });
          assert2($mean.rank === 4 || $mean.rank === 1, function() {
            return "Error in batchNorm4D: mean must be rank 4 or rank 1 but " + ("got rank " + $mean.rank + ".");
          });
          assert2($variance.rank === 4 || $variance.rank === 1, function() {
            return "Error in batchNorm4D: variance must be rank 4 or rank 1 " + ("but got rank " + $variance.rank + ".");
          });
          if ($scale != null) {
            assert2($scale.rank === 4 || $scale.rank === 1, function() {
              return "Error in batchNorm4D: scale must be rank 4 or rank 1 " + ("but got rank " + $scale.rank + ".");
            });
          }
          if ($offset != null) {
            assert2($offset.rank === 4 || $offset.rank === 1, function() {
              return "Error in batchNorm4D: offset must be rank 4 or rank 1 " + ("but got rank " + $offset.rank + ".");
            });
          }
          return batchNorm2($x, $mean, $variance, $offset, $scale, varianceEpsilon);
        }
        var batchNorm4d = op2({ batchNorm4d_ });
        function bincount_(x, weights, size) {
          var $x = convertToTensor2(x, "x", "bincount");
          var $weights = convertToTensor2(weights, "weights", "bincount");
          assert2($x.dtype === "int32", function() {
            return "Error in bincount: input " + ("dtype must be int32, but got " + $x.dtype);
          });
          assert2(size >= 0, function() {
            return "size must be non-negative, but got " + size + ".";
          });
          assert2($weights.size === $x.size || $weights.size === 0, function() {
            return "Error in bincount: weights must have the same size as input or" + ("0-length, but got input shape: " + $x.shape + ", weights shape: ") + ($weights.shape + ".");
          });
          var inputs = { x: $x, weights: $weights };
          var attrs = { size };
          return ENGINE2.runKernel(Bincount2, inputs, attrs);
        }
        var bincount2 = op2({ bincount_ });
        function broadcastTo_(x, shape) {
          var input = convertToTensor2(x, "broadcastTo", "x");
          var xShape = input.shape;
          if (shape.some(function(d) {
            return !(d > 0) || d % 1 !== 0;
          })) {
            throw new Error("broadcastTo(): Invalid broadcast shape [" + shape + "].");
          }
          if (shape.length < input.rank) {
            throw new Error("broadcastTo(): shape.length=" + shape.length + " < input.rank=" + input.rank + ".");
          }
          if (shape.length > input.rank) {
            var newShape = input.shape.slice();
            while (newShape.length < shape.length) {
              newShape.unshift(1);
            }
            input = reshape4(input, newShape);
          }
          var inputShape = input.shape;
          var reps = Array.from(shape);
          for (var i = shape.length - 1; i >= 0; i--) {
            if (inputShape[i] === shape[i]) {
              reps[i] = 1;
            } else if (input.shape[i] !== 1) {
              throw new Error("broadcastTo(): [" + xShape + "] cannot be broadcast to [" + shape + "].");
            }
          }
          var axes = reps.map(function(n, i2) {
            return n > 1 ? i2 : -1;
          }).filter(function(i2) {
            return i2 >= 0;
          });
          if (axes.length === 0) {
            return clone2(input);
          }
          var inputs = { x: input };
          var attrs = { reps };
          return ENGINE2.runKernel(Tile2, inputs, attrs);
        }
        var broadcastTo = op2({ broadcastTo_ });
        function ceil_(x) {
          var $x = convertToTensor2(x, "x", "ceil");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Ceil2, inputs);
        }
        var ceil3 = op2({ ceil_ });
        function clipByValue_(x, clipValueMin, clipValueMax) {
          var $x = convertToTensor2(x, "x", "clipByValue");
          assert2(clipValueMin <= clipValueMax, function() {
            return "Error in clip: min (" + clipValueMin + ") must be " + ("less than or equal to max (" + clipValueMax + ").");
          });
          var inputs = { x: $x };
          var attrs = { clipValueMin, clipValueMax };
          return ENGINE2.runKernel(ClipByValue2, inputs, attrs);
        }
        var clipByValue2 = op2({ clipByValue_ });
        function concat1d_(tensors) {
          return concat3(tensors, 0);
        }
        var concat1d = op2({ concat1d_ });
        function concat2d_(tensors, axis) {
          return concat3(tensors, axis);
        }
        var concat2d = op2({ concat2d_ });
        function concat3d_(tensors, axis) {
          return concat3(tensors, axis);
        }
        var concat3d = op2({ concat3d_ });
        function concat4d_(tensors, axis) {
          return concat3(tensors, axis);
        }
        var concat4d = op2({ concat4d_ });
        function conv2d_(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          if (dilations === void 0) {
            dilations = [1, 1];
          }
          var $x = convertToTensor2(x, "x", "conv2d");
          var $filter = convertToTensor2(filter, "filter", "conv2d");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".";
          });
          assert2($filter.rank === 4, function() {
            return "Error in conv2d: filter must be rank 4, but got rank " + ($filter.rank + ".");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in conv2d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
          assert2(inDepth === $filter.shape[2], function() {
            return "Error in conv2d: depth of input (" + inDepth + ") must match " + ("input depth for filter " + $filter.shape[2] + ".");
          });
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in conv2D: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          var inputs = { x: x4D, filter: $filter };
          var attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
          var res = ENGINE2.runKernel(Conv2D2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var conv2d2 = op2({ conv2d_ });
        function conv1d_(x, filter, stride, pad2, dataFormat, dilation, dimRoundingMode) {
          if (dataFormat === void 0) {
            dataFormat = "NWC";
          }
          if (dilation === void 0) {
            dilation = 1;
          }
          var $x = convertToTensor2(x, "x", "conv1d");
          var $filter = convertToTensor2(filter, "filter", "conv1d");
          var x3D = $x;
          var reshapedTo3D = false;
          if ($x.rank === 2) {
            reshapedTo3D = true;
            x3D = reshape4($x, [1, $x.shape[0], $x.shape[1]]);
          }
          assert2(x3D.rank === 3, function() {
            return "Error in conv1d: input must be rank 3, but got rank " + x3D.rank + ".";
          });
          assert2($filter.rank === 3, function() {
            return "Error in conv1d: filter must be rank 3, but got rank " + ($filter.rank + ".");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in conv1d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          assert2(x3D.shape[2] === $filter.shape[1], function() {
            return "Error in conv1d: depth of input (" + x3D.shape[2] + ") must match " + ("input depth for filter " + $filter.shape[1] + ".");
          });
          assert2(eitherStridesOrDilationsAreOne2(stride, dilation), function() {
            return "Error in conv1D: Either stride or dilation must be 1. " + ("Got stride " + stride + " and dilation '" + dilation + "'");
          });
          assert2(dataFormat === "NWC", function() {
            return "Error in conv1d: got dataFormat of " + dataFormat + " but only NWC is currently supported.";
          });
          var filter4D = reshape4($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
          var input4D = reshape4(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
          var strides = [1, stride];
          var dilations = [1, dilation];
          var conv2dDataFormat = "NHWC";
          var res = conv2d2(input4D, filter4D, strides, pad2, conv2dDataFormat, dilations, dimRoundingMode);
          if (reshapedTo3D) {
            return reshape4(res, [res.shape[2], res.shape[3]]);
          }
          return reshape4(res, [res.shape[0], res.shape[2], res.shape[3]]);
        }
        var conv1d = op2({ conv1d_ });
        function conv2DBackpropInput_(xShape, dy, filter, strides, pad2, dataFormat, dimRoundingMode) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          assert2(xShape.length === dy.rank, function() {
            return "Length of inShape " + ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match");
          });
          var xShape4D = xShape;
          var dy4D = dy;
          var reshapedTo4D = false;
          if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = reshape4(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
            xShape4D = [1, xShape[0], xShape[1], xShape[2]];
          }
          assert2(xShape4D.length === 4, function() {
            return "Error in conv2dDerInput: inShape must be length 4, but got length " + (xShape4D.length + ".");
          });
          assert2(dy4D.rank === 4, function() {
            return "Error in conv2dDerInput: dy must be rank 4, but got " + ("rank " + dy4D.rank);
          });
          assert2(filter.rank === 4, function() {
            return "Error in conv2dDerInput: filter must be rank 4, but got " + ("rank " + filter.rank);
          });
          var inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
          var outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
          assert2(inDepth === filter.shape[2], function() {
            return "Error in conv2dDerInput: depth of input (" + inDepth + ") must " + ("match input depth for filter " + filter.shape[2] + ".");
          });
          assert2(outDepth === filter.shape[3], function() {
            return "Error in conv2dDerInput: depth of output (" + outDepth + ") must " + ("match output depth for filter " + filter.shape[3] + ".");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in conv2dDerInput: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { dy: dy4D, filter };
          var attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, inputShape: xShape4D };
          var res = ENGINE2.runKernel(Conv2DBackpropInput2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var conv2DBackpropInput2 = op2({ conv2DBackpropInput_ });
        function conv2dTranspose_(x, filter, outputShape, strides, pad2, dimRoundingMode) {
          var $x = convertToTensor2(x, "x", "conv2dTranspose");
          var $filter = convertToTensor2(filter, "filter", "conv2dTranspose");
          return conv2DBackpropInput2(outputShape, $x, $filter, strides, pad2, "NHWC", dimRoundingMode);
        }
        var conv2dTranspose = op2({ conv2dTranspose_ });
        function conv3d_(x, filter, strides, pad2, dataFormat, dilations) {
          if (dataFormat === void 0) {
            dataFormat = "NDHWC";
          }
          if (dilations === void 0) {
            dilations = [1, 1, 1];
          }
          var $x = convertToTensor2(x, "x", "conv3d");
          var $filter = convertToTensor2(filter, "filter", "conv3d");
          var x5D = $x;
          var reshapedTo5D = false;
          if ($x.rank === 4) {
            reshapedTo5D = true;
            x5D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
          }
          assert2(x5D.rank === 5, function() {
            return "Error in conv3d: input must be rank 5, but got rank " + x5D.rank + ".";
          });
          assert2($filter.rank === 5, function() {
            return "Error in conv3d: filter must be rank 5, but got rank " + ($filter.rank + ".");
          });
          assert2(x5D.shape[4] === $filter.shape[3], function() {
            return "Error in conv3d: depth of input (" + x5D.shape[4] + ") must match " + ("input depth for filter " + $filter.shape[3] + ".");
          });
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in conv3D: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          assert2(dataFormat === "NDHWC", function() {
            return "Error in conv3d: got dataFormat of " + dataFormat + " but only NDHWC is currently supported.";
          });
          var inputs = { x: x5D, filter: $filter };
          var attrs = { strides, pad: pad2, dataFormat, dilations };
          var res = ENGINE2.runKernel(Conv3D2, inputs, attrs);
          if (reshapedTo5D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
          }
          return res;
        }
        var conv3d = op2({ conv3d_ });
        function conv3DBackpropInput_(xShape, dy, filter, strides, pad2) {
          assert2(xShape.length === dy.rank, function() {
            return "Length of inShape " + ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match");
          });
          var xShape5D = xShape;
          var dy5D = dy;
          var reshapedTo5D = false;
          if (dy.rank === 4) {
            reshapedTo5D = true;
            dy5D = reshape4(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
            xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
          }
          var inDepth = xShape5D[4];
          var outDepth = dy5D.shape[4];
          assert2(xShape5D.length === 5, function() {
            return "Error in conv3dDerInput: inShape must be length 5, but got length " + (xShape5D.length + ".");
          });
          assert2(dy5D.rank === 5, function() {
            return "Error in conv3dDerInput: dy must be rank 5, but got " + ("rank " + dy5D.rank);
          });
          assert2(filter.rank === 5, function() {
            return "Error in conv3dDerInput: filter must be rank 5, but got " + ("rank " + filter.rank);
          });
          assert2(inDepth === filter.shape[3], function() {
            return "Error in conv3dDerInput: depth of input (" + inDepth + ") must " + ("match input depth for filter " + filter.shape[3] + ".");
          });
          assert2(outDepth === filter.shape[4], function() {
            return "Error in conv3dDerInput: depth of output (" + outDepth + ") must " + ("match output depth for filter " + filter.shape[4] + ".");
          });
          var inputs = { dy: dy5D, filter };
          var attrs = { pad: pad2, strides, inputShape: xShape5D };
          var res = ENGINE2.runKernel(Conv3DBackpropInputV22, inputs, attrs);
          if (reshapedTo5D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
          }
          return res;
        }
        var conv3DBackpropInput2 = op2({ conv3DBackpropInput_ });
        function conv3dTranspose_(x, filter, outputShape, strides, pad2) {
          var $x = convertToTensor2(x, "x", "conv3dTranspose");
          var $filter = convertToTensor2(filter, "filter", "conv3dTranspose");
          return conv3DBackpropInput2(outputShape, $x, $filter, strides, pad2);
        }
        var conv3dTranspose = op2({ conv3dTranspose_ });
        function cos_(x) {
          var $x = convertToTensor2(x, "x", "cos");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Cos2, inputs);
        }
        var cos2 = op2({ cos_ });
        function cosh_(x) {
          var $x = convertToTensor2(x, "x", "cosh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Cosh2, inputs);
        }
        var cosh2 = op2({ cosh_ });
        function cumsum_(x, axis, exclusive, reverse3) {
          if (axis === void 0) {
            axis = 0;
          }
          if (exclusive === void 0) {
            exclusive = false;
          }
          if (reverse3 === void 0) {
            reverse3 = false;
          }
          var $x = convertToTensor2(x, "x", "cumsum");
          var inputs = { x: $x };
          var attrs = { axis, exclusive, reverse: reverse3 };
          return ENGINE2.runKernel(Cumsum2, inputs, attrs);
        }
        var cumsum2 = op2({ cumsum_ });
        function denseBincount_(x, weights, size, binaryOutput) {
          if (binaryOutput === void 0) {
            binaryOutput = false;
          }
          var $x = convertToTensor2(x, "x", "denseBincount");
          var $weights = convertToTensor2(weights, "weights", "denseBincount");
          assert2($x.dtype === "int32", function() {
            return "Error in denseBincount: input " + ("dtype must be int32, but got " + $x.dtype);
          });
          assert2($x.rank <= 2, function() {
            return "Error in denseBincount: input must be at most rank 2, but got " + ("rank " + $x.rank + ".");
          });
          assert2(size >= 0, function() {
            return "size must be non-negative, but got " + size + ".";
          });
          assert2($weights.size === $x.size || $weights.size === 0, function() {
            return "Error in denseBincount: weights must have the same shape as x or " + ("0-length, but got x shape: " + $x.shape + ", weights shape: ") + ($weights.shape + ".");
          });
          var inputs = { x: $x, weights: $weights };
          var attrs = { size, binaryOutput };
          return ENGINE2.runKernel(DenseBincount2, inputs, attrs);
        }
        var denseBincount2 = op2({ denseBincount_ });
        function depthToSpace_(x, blockSize, dataFormat) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          var $x = convertToTensor2(x, "x", "depthToSpace");
          var inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
          var inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
          var inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
          assert2(inputHeight * blockSize >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n    " + inputHeight + " and " + blockSize + "  for depthToSpace with input shape\n    " + $x.shape;
          });
          assert2(inputWidth * blockSize >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n    " + inputWidth + " and " + blockSize + " for depthToSpace with input shape\n        " + $x.shape;
          });
          assert2(inputDepth % (blockSize * blockSize) === 0, function() {
            return "Dimension size must be evenly divisible by " + blockSize * blockSize + " but is " + inputDepth + " for depthToSpace with input shape " + $x.shape;
          });
          var inputs = { x: $x };
          var attrs = { blockSize, dataFormat };
          return ENGINE2.runKernel(DepthToSpace2, inputs, attrs);
        }
        var depthToSpace2 = op2({ depthToSpace_ });
        function depthwiseConv2d_(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          if (dilations === void 0) {
            dilations = [1, 1];
          }
          var $x = convertToTensor2(x, "x", "depthwiseConv2d");
          var $filter = convertToTensor2(filter, "filter", "depthwiseConv2d");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in depthwiseConv2d: input must be rank 4, but got " + ("rank " + x4D.rank + ".");
          });
          assert2($filter.rank === 4, function() {
            return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + ($filter.rank + ".");
          });
          assert2(x4D.shape[3] === $filter.shape[2], function() {
            return "Error in depthwiseConv2d: number of input channels " + ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") + ("filter " + $filter.shape[2] + ".");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in depthwiseConv2d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x4D, filter: $filter };
          var attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
          var res = ENGINE2.runKernel(DepthwiseConv2dNative2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var depthwiseConv2d = op2({ depthwiseConv2d_ });
        function diag_(x) {
          var $x = convertToTensor2(x, "x", "diag");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Diag2, inputs);
        }
        var diag2 = op2({ diag_ });
        function dilation2d_(x, filter, strides, pad2, dilations, dataFormat) {
          if (dilations === void 0) {
            dilations = [1, 1];
          }
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          var $x = convertToTensor2(x, "x", "dilation2d");
          var $filter = convertToTensor2(filter, "filter", "dilation2d");
          assert2($x.rank === 3 || $x.rank === 4, function() {
            return "Error in dilation2d: input must be rank 3 or 4, but got rank " + ($x.rank + ".");
          });
          assert2($filter.rank === 3, function() {
            return "Error in dilation2d: filter must be rank 3, but got rank " + ($filter.rank + ".");
          });
          assert2(dataFormat === "NHWC", function() {
            return "Error in dilation2d: Only NHWC is currently supported, " + ("but got dataFormat of " + dataFormat);
          });
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
            reshapedTo4D = true;
          }
          var inputs = { x: x4D, filter: $filter };
          var attrs = { strides, pad: pad2, dilations };
          var res = ENGINE2.runKernel(Dilation2D2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var dilation2d = op2({ dilation2d_ });
        function getBroadcastDims3(inShape, outShape) {
          var inRank = inShape.length;
          var dims = [];
          for (var i = 0; i < inRank; i++) {
            var dim = inRank - 1 - i;
            var a = inShape[dim] || 1;
            var b = outShape[outShape.length - 1 - i] || 1;
            if (b > 1 && a === 1) {
              dims.unshift(dim);
            }
          }
          return dims;
        }
        function getReductionAxes2(inShape, outShape) {
          var result2 = [];
          for (var i = 0; i < outShape.length; i++) {
            var inDim = inShape[inShape.length - i - 1];
            var outAxis = outShape.length - i - 1;
            var outDim = outShape[outAxis];
            if (inDim == null || inDim === 1 && outDim > 1) {
              result2.unshift(outAxis);
            }
          }
          return result2;
        }
        function assertAndGetBroadcastShape2(shapeA, shapeB) {
          var result2 = [];
          var l = Math.max(shapeA.length, shapeB.length);
          for (var i = 0; i < l; i++) {
            var a = shapeA[shapeA.length - i - 1];
            if (a == null) {
              a = 1;
            }
            var b = shapeB[shapeB.length - i - 1];
            if (b == null) {
              b = 1;
            }
            if (a === 1) {
              result2.unshift(b);
            } else if (b === 1) {
              result2.unshift(a);
            } else if (a !== b) {
              var errMsg = "Operands could not be broadcast together with shapes " + (shapeA + " and " + shapeB + ".");
              throw Error(errMsg);
            } else {
              result2.unshift(a);
            }
          }
          return result2;
        }
        function equal_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "equal");
          var $b = convertToTensor2(b, "b", "equal");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Equal2, inputs);
        }
        var equal3 = op2({ equal_ });
        function where_(condition, a, b) {
          var $a = convertToTensor2(a, "a", "where");
          var $b = convertToTensor2(b, "b", "where");
          var $condition = convertToTensor2(condition, "condition", "where", "bool");
          var broadcastShape = assertAndGetBroadcastShape2(assertAndGetBroadcastShape2($condition.shape, $a.shape), $b.shape);
          var $broadcastedCondition = broadcastTo($condition, broadcastShape);
          var $broadcastedA = broadcastTo($a, broadcastShape);
          var $broadcastedB = broadcastTo($b, broadcastShape);
          var inputs = {
            condition: $broadcastedCondition,
            t: $broadcastedA,
            e: $broadcastedB
          };
          return ENGINE2.runKernel(Select2, inputs);
        }
        var where = op2({ where_ });
        function zerosLike_(x) {
          var $x = convertToTensor2(x, "x", "zerosLike");
          var inputs = { x: $x };
          return ENGINE2.runKernel(ZerosLike2, inputs);
        }
        var zerosLike2 = op2({ zerosLike_ });
        function divNoNan_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "div");
          var $b = convertToTensor2(b, "b", "div");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var divResult = div2($a, $b);
          var zeros4 = zerosLike2(divResult);
          var bEqualsZero = equal3($b, zeros4);
          return where(bEqualsZero, zeros4, divResult);
        }
        var divNoNan = op2({ divNoNan_ });
        function dot_(t1, t2) {
          var $t1 = convertToTensor2(t1, "t1", "dot");
          var $t2 = convertToTensor2(t2, "t2", "dot");
          assert2(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), function() {
            return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + ($t1.rank + " and " + $t2.rank + ".");
          });
          var t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
          var t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
          assert2(t1Inner === t2Inner, function() {
            return "Error in dot: inner dimensions of inputs must match, but got " + (t1Inner + " and " + t2Inner + ".");
          });
          if ($t1.rank === 1 && $t2.rank === 1) {
            var t12D = reshape4($t1, [1, -1]);
            var t22D = reshape4($t2, [-1, 1]);
            var t1t2 = matMul(t12D, t22D);
            return reshape4(t1t2, []);
          } else if ($t1.rank === 1 && $t2.rank === 2) {
            var t12D = reshape4($t1, [1, -1]);
            var t22D = reshape4($t2, [$t2.shape[0], $t2.shape[1]]);
            var t1t2 = matMul(t12D, t22D);
            return reshape4(t1t2, [t1t2.size]);
          } else if ($t1.rank === 2 && $t2.rank === 1) {
            var t22D = reshape4($t2, [-1, 1]);
            var t1t2 = matMul($t1, t22D);
            return reshape4(t1t2, [t1t2.size]);
          } else {
            var t22D = reshape4($t2, [$t2.shape[0], $t2.shape[1]]);
            var t1t2 = matMul($t1, t22D);
            return t1t2;
          }
        }
        var dot = op2({ dot_ });
        function einsum_(equation) {
          var tensors = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            tensors[_i - 1] = arguments[_i];
          }
          var $tensors = tensors.map(function(t, i) {
            return convertToTensor2(t, "tensors" + i, "einsum");
          });
          var attrs = { equation };
          return ENGINE2.runKernel(Einsum2, $tensors, attrs);
        }
        var einsum2 = op2({ einsum_ });
        function elu_2(x) {
          var $x = convertToTensor2(x, "x", "elu");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Elu2, inputs);
        }
        var elu3 = op2({ elu_: elu_2 });
        function erf_(x) {
          var $x = convertToTensor2(x, "x", "erf");
          assert2($x.dtype === "int32" || $x.dtype === "float32", function() {
            return "Input dtype must be `int32` or `float32`.";
          });
          if ($x.dtype === "int32") {
            $x = cast5($x, "float32");
          }
          var inputs = { x: $x };
          return ENGINE2.runKernel(Erf2, inputs);
        }
        var erf2 = op2({ erf_ });
        function exp_(x) {
          var $x = convertToTensor2(x, "x", "exp");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Exp2, inputs);
        }
        var exp3 = op2({ exp_ });
        function expandDims_(x, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "expandDims", "string_or_numeric");
          assert2(axis <= $x.rank, function() {
            return "Axis must be <= rank of the tensor";
          });
          var inputs = { input: $x };
          var attrs = { dim: axis };
          return ENGINE2.runKernel(ExpandDims2, inputs, attrs);
        }
        var expandDims3 = op2({ expandDims_ });
        function expm1_(x) {
          var $x = convertToTensor2(x, "x", "expm1");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Expm12, inputs);
        }
        var expm13 = op2({ expm1_ });
        function tile_(x, reps) {
          var $x = convertToTensor2(x, "x", "tile", "string_or_numeric");
          assert2($x.rank === reps.length, function() {
            return "Error in transpose: rank of input " + $x.rank + " " + ("must match length of reps " + reps + ".");
          });
          var inputs = { x: $x };
          var attrs = { reps };
          return ENGINE2.runKernel(Tile2, inputs, attrs);
        }
        var tile2 = op2({ tile_ });
        function eye_(numRows, numColumns, batchShape, dtype) {
          if (dtype === void 0) {
            dtype = "float32";
          }
          if (numColumns == null) {
            numColumns = numRows;
          }
          var buff = buffer2([numRows, numColumns], dtype);
          var n = numRows <= numColumns ? numRows : numColumns;
          for (var i = 0; i < n; ++i) {
            buff.set(1, i, i);
          }
          var out = reshape4(buff.toTensor(), [numRows, numColumns]);
          if (batchShape == null) {
            return out;
          } else {
            if (batchShape.length === 1) {
              return tile2(expandDims3(out, 0), [batchShape[0], 1, 1]);
            } else if (batchShape.length === 2) {
              return tile2(expandDims3(expandDims3(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
            } else if (batchShape.length === 3) {
              return tile2(expandDims3(expandDims3(expandDims3(out, 0), 0), 0), [
                batchShape[0],
                batchShape[1],
                batchShape[2],
                1,
                1
              ]);
            } else {
              throw new Error("eye() currently supports only 1D and 2D " + ("batchShapes, but received " + batchShape.length + "D."));
            }
          }
        }
        var eye = op2({ eye_ });
        function fill2(shape, value, dtype) {
          var attrs = { shape, value, dtype };
          return ENGINE2.runKernel(Fill2, {}, attrs);
        }
        function floor_(x) {
          var $x = convertToTensor2(x, "x", "floor");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Floor2, inputs);
        }
        var floor3 = op2({ floor_ });
        function gather_(x, indices, axis, batchDims) {
          if (axis === void 0) {
            axis = 0;
          }
          if (batchDims === void 0) {
            batchDims = 0;
          }
          var $x = convertToTensor2(x, "x", "gather");
          var $indices = convertToTensor2(indices, "indices", "gather", "int32");
          var inputs = { x: $x, indices: $indices };
          var attrs = { axis, batchDims };
          return ENGINE2.runKernel(GatherV22, inputs, attrs);
        }
        var gather = op2({ gather_ });
        function greater_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "greater");
          var $b = convertToTensor2(b, "b", "greater");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Greater2, inputs);
        }
        var greater3 = op2({ greater_ });
        function greaterEqual_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "greaterEqual");
          var $b = convertToTensor2(b, "b", "greaterEqual");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(GreaterEqual2, inputs);
        }
        var greaterEqual3 = op2({ greaterEqual_ });
        function imag_(input) {
          var $input = convertToTensor2(input, "input", "imag");
          var inputs = { input: $input };
          return ENGINE2.runKernel(Imag2, inputs);
        }
        var imag2 = op2({ imag_ });
        function isFinite_(x) {
          var $x = convertToTensor2(x, "x", "isFinite");
          var inputs = { x: $x };
          return ENGINE2.runKernel(IsFinite2, inputs);
        }
        var isFinite$1 = op2({ isFinite_ });
        function isInf_(x) {
          var $x = convertToTensor2(x, "x", "isInf");
          var inputs = { x: $x };
          return ENGINE2.runKernel(IsInf2, inputs);
        }
        var isInf2 = op2({ isInf_ });
        function isNaN_(x) {
          var $x = convertToTensor2(x, "x", "isNaN");
          var inputs = { x: $x };
          return ENGINE2.runKernel(IsNan2, inputs);
        }
        var isNaN$1 = op2({ isNaN_ });
        function leakyRelu_2(x, alpha) {
          if (alpha === void 0) {
            alpha = 0.2;
          }
          var $x = convertToTensor2(x, "x", "leakyRelu");
          var inputs = { x: $x };
          var attrs = { alpha };
          return ENGINE2.runKernel(LeakyRelu2, inputs, attrs);
        }
        var leakyRelu3 = op2({ leakyRelu_: leakyRelu_2 });
        function less_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "less");
          var $b = convertToTensor2(b, "b", "less");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Less2, inputs);
        }
        var less3 = op2({ less_ });
        function lessEqual_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "lessEqual");
          var $b = convertToTensor2(b, "b", "lessEqual");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(LessEqual2, inputs);
        }
        var lessEqual3 = op2({ lessEqual_ });
        function linspace(start, stop, num) {
          if (num <= 0) {
            throw new Error("The number of values should be positive.");
          }
          var attrs = { start, stop, num };
          return ENGINE2.runKernel(LinSpace2, {}, attrs);
        }
        function localResponseNormalization_(x, depthRadius, bias, alpha, beta) {
          if (depthRadius === void 0) {
            depthRadius = 5;
          }
          if (bias === void 0) {
            bias = 1;
          }
          if (alpha === void 0) {
            alpha = 1;
          }
          if (beta === void 0) {
            beta = 0.5;
          }
          var $x = convertToTensor2(x, "x", "localResponseNormalization");
          assert2($x.rank === 4 || $x.rank === 3, function() {
            return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + $x.rank + ".";
          });
          assert2(isInt2(depthRadius), function() {
            return "Error in localResponseNormalization: depthRadius must be an " + ("integer but got depthRadius " + depthRadius + ".");
          });
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          var inputs = { x: x4D };
          var attrs = { depthRadius, bias, alpha, beta };
          var res = ENGINE2.runKernel(LRN2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          } else {
            return res;
          }
        }
        var localResponseNormalization = op2({ localResponseNormalization_ });
        function log_(x) {
          var $x = convertToTensor2(x, "x", "log");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Log2, inputs);
        }
        var log4 = op2({ log_ });
        function log1p_(x) {
          var $x = convertToTensor2(x, "x", "log1p");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Log1p2, inputs);
        }
        var log1p2 = op2({ log1p_ });
        function grad(f) {
          assert2(isFunction3(f), function() {
            return "The f passed in grad(f) must be a function";
          });
          return function(x, dy) {
            var $x = convertToTensor2(x, "x", "tf.grad", "string_or_numeric");
            var $dy = dy != null ? convertToTensor2(dy, "dy", "tf.grad") : null;
            return ENGINE2.tidy(function() {
              var _a = ENGINE2.gradients(function() {
                return f($x);
              }, [$x], $dy), value = _a.value, grads2 = _a.grads;
              if ($dy != null) {
                assertShapesMatch2(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
              }
              checkGrads(grads2);
              return grads2[0];
            });
          };
        }
        function grads(f) {
          assert2(isFunction3(f), function() {
            return "The f passed in grads(f) must be a function";
          });
          return function(args, dy) {
            assert2(Array.isArray(args), function() {
              return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
            });
            var $args = convertToTensorArray(args, "args", "tf.grads", "string_or_numeric");
            var $dy = dy != null ? convertToTensor2(dy, "dy", "tf.grads") : null;
            return ENGINE2.tidy(function() {
              var _a = ENGINE2.gradients(function() {
                return f.apply(void 0, $args);
              }, $args, $dy), value = _a.value, grads2 = _a.grads;
              if ($dy != null) {
                assertShapesMatch2(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
              }
              checkGrads(grads2);
              return grads2;
            });
          };
        }
        function valueAndGrad(f) {
          assert2(isFunction3(f), function() {
            return "The f passed in valueAndGrad(f) must be a function";
          });
          return function(x, dy) {
            assert2(x instanceof Tensor3, function() {
              return "The x passed in valueAndGrad(f)(x) must be a tensor";
            });
            assert2(dy == null || dy instanceof Tensor3, function() {
              return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
            });
            var _a = ENGINE2.gradients(function() {
              return f(x);
            }, [x], dy), grads2 = _a.grads, value = _a.value;
            checkGrads(grads2);
            return { grad: grads2[0], value };
          };
        }
        function valueAndGrads(f) {
          assert2(isFunction3(f), function() {
            return "The f passed in valueAndGrads(f) must be a function";
          });
          return function(args, dy) {
            assert2(Array.isArray(args) && args.every(function(arg) {
              return arg instanceof Tensor3;
            }), function() {
              return "The args passed in valueAndGrads(f)(args) must be array of tensors";
            });
            assert2(dy == null || dy instanceof Tensor3, function() {
              return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
            });
            var res = ENGINE2.gradients(function() {
              return f.apply(void 0, args);
            }, args, dy);
            if (dy != null) {
              assertShapesMatch2(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
            }
            checkGrads(res.grads);
            return res;
          };
        }
        function variableGrads(f, varList) {
          assert2(isFunction3(f), function() {
            return "The f passed in variableGrads(f) must be a function";
          });
          assert2(varList == null || Array.isArray(varList) && varList.every(function(v) {
            return v instanceof Variable2;
          }), function() {
            return "The varList passed in variableGrads(f, varList) must be an array of variables";
          });
          var specifiedVarList = varList != null;
          if (!specifiedVarList) {
            varList = [];
            for (var varName in ENGINE2.registeredVariables) {
              varList.push(ENGINE2.registeredVariables[varName]);
            }
          }
          var specifiedNonTrainable = specifiedVarList ? varList.filter(function(variable2) {
            return !variable2.trainable;
          }) : null;
          var originalVarCount = varList.length;
          varList = varList.filter(function(variable2) {
            return variable2.trainable;
          });
          assert2(varList.length > 0, function() {
            return "variableGrads() expects at least one of the input variables to " + ("be trainable, but none of the " + originalVarCount + " variables is ") + "trainable.";
          });
          var allowNoGradients = true;
          var _a = ENGINE2.gradients(f, varList, null, allowNoGradients), value = _a.value, grads2 = _a.grads;
          assert2(grads2.some(function(g) {
            return g != null;
          }), function() {
            return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
          });
          assert2(value.rank === 0, function() {
            return "The f passed in variableGrads(f) must return a scalar, but it " + ("returned a rank-" + value.rank + " tensor");
          });
          var namedGrads = {};
          varList.forEach(function(v, i) {
            if (grads2[i] != null) {
              namedGrads[v.name] = grads2[i];
            }
          });
          if (specifiedNonTrainable != null) {
            specifiedNonTrainable.forEach(function(v) {
              return namedGrads[v.name] = null;
            });
          }
          return { value, grads: namedGrads };
        }
        function customGrad(f) {
          return ENGINE2.customGrad(f);
        }
        function checkGrads(grads2) {
          var numNullGradients = grads2.filter(function(g) {
            return g == null;
          }).length;
          if (numNullGradients > 0) {
            throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
          }
        }
        function neg_(x) {
          var $x = convertToTensor2(x, "x", "neg");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Neg2, inputs);
        }
        var neg2 = op2({ neg_ });
        function softplus_(x) {
          var $x = convertToTensor2(x, "x", "softplus");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Softplus2, inputs);
        }
        var softplus2 = op2({ softplus_ });
        function logSigmoid_(x) {
          var $x = convertToTensor2(x, "x", "logSigmoid");
          var customOp = customGrad(function(x2) {
            var value = neg2(softplus2(neg2(x2)));
            var gradFunc = function(dy) {
              var derX = mul3(dy, sigmoid4(neg2(x2)));
              return derX;
            };
            return { value, gradFunc };
          });
          return customOp($x);
        }
        var logSigmoid = op2({ logSigmoid_ });
        function max_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "max");
          var inputs = { x: $x };
          var attrs = { reductionIndices: axis, keepDims };
          return ENGINE2.runKernel(Max2, inputs, attrs);
        }
        var max2 = op2({ max_ });
        function sub_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "sub");
          var $b = convertToTensor2(b, "b", "sub");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Sub2, inputs);
        }
        var sub4 = op2({ sub_ });
        function sum_2(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "sum");
          if ($x.dtype === "bool") {
            $x = cast5($x, "int32");
          }
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(Sum2, inputs, attrs);
        }
        var sum$1 = op2({ sum_: sum_2 });
        function logSoftmax_(logits, axis) {
          if (axis === void 0) {
            axis = -1;
          }
          var $logits = convertToTensor2(logits, "logits", "logSoftmax");
          if (axis === -1) {
            axis = $logits.rank - 1;
          }
          if (axis !== $logits.rank - 1) {
            throw Error("Log Softmax along a non-last dimension is not yet supported. " + ("Logits was rank " + $logits.rank + " and axis was " + axis));
          }
          var customOp = customGrad(function(logits2, save2) {
            var keepDims = true;
            var xMax = max2(logits2, axis, true);
            var shifted = sub4(logits2, xMax);
            var value = sub4(cast5(shifted, "float32"), log4(sum$1(exp3(shifted), axis, keepDims)));
            save2([value]);
            var gradFunc = function(dy, saved) {
              var value2 = saved[0];
              var keepDims2 = true;
              var softmax3 = exp3(value2);
              return sub4(dy, mul3(sum$1(dy, axis, keepDims2), softmax3));
            };
            return { value, gradFunc };
          });
          return customOp($logits);
        }
        var logSoftmax = op2({ logSoftmax_ });
        function axesAreInnerMostDims2(axes, rank) {
          for (var i = 0; i < axes.length; ++i) {
            if (axes[axes.length - i - 1] !== rank - 1 - i) {
              return false;
            }
          }
          return true;
        }
        function combineLocations2(outputLoc, reduceLoc, axes) {
          var rank = outputLoc.length + reduceLoc.length;
          var loc = [];
          var outIdx = 0;
          var reduceIdx = 0;
          for (var dim = 0; dim < rank; dim++) {
            if (axes.indexOf(dim) === -1) {
              loc.push(outputLoc[outIdx++]);
            } else {
              loc.push(reduceLoc[reduceIdx++]);
            }
          }
          return loc;
        }
        function computeOutAndReduceShapes2(aShape, axes) {
          var outShape = [];
          var rank = aShape.length;
          for (var dim = 0; dim < rank; dim++) {
            if (axes.indexOf(dim) === -1) {
              outShape.push(aShape[dim]);
            }
          }
          var reduceShape = axes.map(function(dim2) {
            return aShape[dim2];
          });
          return [outShape, reduceShape];
        }
        function expandShapeToKeepDim2(shape, axes) {
          var reduceSubShape = axes.map(function(x) {
            return 1;
          });
          return combineLocations2(shape, reduceSubShape, axes);
        }
        function assertAxesAreInnerMostDims2(msg, axes, rank) {
          assert2(axesAreInnerMostDims2(axes, rank), function() {
            return msg + " supports only inner-most axes for now. " + ("Got axes " + axes + " and rank-" + rank + " input.");
          });
        }
        function getAxesPermutation2(axes, rank) {
          if (axesAreInnerMostDims2(axes, rank)) {
            return null;
          }
          var result2 = [];
          for (var i = 0; i < rank; ++i) {
            if (axes.indexOf(i) === -1) {
              result2.push(i);
            }
          }
          axes.forEach(function(axis) {
            return result2.push(axis);
          });
          return result2;
        }
        function getUndoAxesPermutation2(axes) {
          return axes.map(function(axis, i) {
            return [i, axis];
          }).sort(function(a, b) {
            return a[1] - b[1];
          }).map(function(x) {
            return x[0];
          });
        }
        function getInnerMostAxes2(numAxes, rank) {
          var res = [];
          for (var i = rank - numAxes; i < rank; ++i) {
            res.push(i);
          }
          return res;
        }
        function logSumExp_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "logSumExp");
          var axes = parseAxisParam2(axis, $x.shape);
          var xMax = max2($x, axes, true);
          var a = sub4($x, xMax);
          var b = exp3(a);
          var c = sum$1(b, axes);
          var d = log4(c);
          var res = add$1(reshape4(xMax, d.shape), d);
          if (keepDims) {
            var newShape = expandShapeToKeepDim2(res.shape, axes);
            return reshape4(res, newShape);
          }
          return res;
        }
        var logSumExp = op2({ logSumExp_ });
        function logicalAnd_(a, b) {
          var $a = convertToTensor2(a, "a", "logicalAnd", "bool");
          var $b = convertToTensor2(b, "b", "logicalAnd", "bool");
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(LogicalAnd2, inputs);
        }
        var logicalAnd2 = op2({ logicalAnd_ });
        function logicalNot_(x) {
          var $x = convertToTensor2(x, "x", "logicalNot", "bool");
          var inputs = { x: $x };
          return ENGINE2.runKernel(LogicalNot2, inputs);
        }
        var logicalNot2 = op2({ logicalNot_ });
        function logicalOr_(a, b) {
          var $a = convertToTensor2(a, "a", "logicalOr", "bool");
          var $b = convertToTensor2(b, "b", "logicalOr", "bool");
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(LogicalOr2, inputs);
        }
        var logicalOr2 = op2({ logicalOr_ });
        function logicalXor_(a, b) {
          var $a = convertToTensor2(a, "a", "logicalXor", "bool");
          var $b = convertToTensor2(b, "b", "logicalXor", "bool");
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          return logicalAnd2(logicalOr2(a, b), logicalNot2(logicalAnd2(a, b)));
        }
        var logicalXor = op2({ logicalXor_ });
        function maxPool_(x, filterSize, strides, pad2, dimRoundingMode) {
          var $x = convertToTensor2(x, "x", "maxPool");
          var dilations = 1;
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".";
          });
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in maxPool: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in maxPool: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x4D };
          var attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
          var res = ENGINE2.runKernel(MaxPool2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var maxPool2 = op2({ maxPool_ });
        function maxPool3d_(x, filterSize, strides, pad2, dimRoundingMode, dataFormat) {
          if (filterSize === void 0) {
            filterSize = [1, 1, 1];
          }
          if (dataFormat === void 0) {
            dataFormat = "NDHWC";
          }
          var $x = convertToTensor2(x, "x", "maxPool3d");
          var x5D = $x;
          var reshapedTo5D = false;
          if ($x.rank === 4) {
            reshapedTo5D = true;
            x5D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
          }
          assert2(x5D.rank === 5, function() {
            return "Error in maxPool3d: x must be rank 5 but got rank " + x5D.rank + ".";
          });
          assert2(dataFormat === "NDHWC", function() {
            return "Error in maxPool3d: Only NDHWC is currently supported, " + ("but got dataFormat of " + dataFormat);
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in maxPool3d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x5D };
          var attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
          var res = ENGINE2.runKernel(MaxPool3D2, inputs, attrs);
          if (reshapedTo5D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
          }
          return res;
        }
        var maxPool3d2 = op2({ maxPool3d_ });
        function maxPoolWithArgmax_(x, filterSize, strides, pad2, includeBatchInIndex) {
          if (includeBatchInIndex === void 0) {
            includeBatchInIndex = false;
          }
          var $x = convertToTensor2(x, "x", "maxPoolWithArgmax");
          var inputs = { x: $x };
          var attrs = { filterSize, strides, pad: pad2, includeBatchInIndex };
          var result2 = ENGINE2.runKernel(MaxPoolWithArgmax2, inputs, attrs);
          return { result: result2[0], indexes: result2[1] };
        }
        var maxPoolWithArgmax = op2({ maxPoolWithArgmax_ });
        function maximum_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "maximum");
          var $b = convertToTensor2(b, "b", "maximum");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          if ($a.dtype === "bool") {
            $a = cast5($a, "int32");
            $b = cast5($b, "int32");
          }
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Maximum2, inputs);
        }
        var maximum3 = op2({ maximum_ });
        function mean_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "mean");
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(Mean2, inputs, attrs);
        }
        var mean = op2({ mean_ });
        function zeros3(shape, dtype) {
          if (dtype === void 0) {
            dtype = "float32";
          }
          if (dtype === "complex64") {
            var real4 = zeros3(shape, "float32");
            var imag3 = zeros3(shape, "float32");
            return complex4(real4, imag3);
          }
          var values = makeZerosTypedArray2(sizeFromShape2(shape), dtype);
          return ENGINE2.makeTensor(values, shape, dtype);
        }
        function ones$1(shape, dtype) {
          if (dtype === void 0) {
            dtype = "float32";
          }
          if (dtype === "complex64") {
            var real4 = ones$1(shape, "float32");
            var imag3 = zeros3(shape, "float32");
            return complex4(real4, imag3);
          }
          var values = makeOnesTypedArray2(sizeFromShape2(shape), dtype);
          return ENGINE2.makeTensor(values, shape, dtype);
        }
        function meshgrid(x, y, _a) {
          var _b = (_a === void 0 ? {} : _a).indexing, indexing = _b === void 0 ? "xy" : _b;
          if (indexing !== "xy" && indexing !== "ij") {
            throw new TypeError(indexing + " is not a valid third argument to meshgrid");
          }
          if (x === void 0) {
            return [];
          }
          var $x = convertToTensor2(x, "x", "meshgrid", x instanceof Tensor3 ? x.dtype : "float32");
          if (y === void 0) {
            return [$x];
          }
          var $y = convertToTensor2(y, "y", "meshgrid", y instanceof Tensor3 ? y.dtype : "float32");
          var w = sizeFromShape2($x.shape);
          var h = sizeFromShape2($y.shape);
          if (indexing === "xy") {
            $x = reshape4($x, [1, -1]);
            $y = reshape4($y, [-1, 1]);
            return [
              matMul(ones$1([h, 1], $x.dtype), $x),
              matMul($y, ones$1([1, w], $y.dtype))
            ];
          }
          $x = reshape4($x, [-1, 1]);
          $y = reshape4($y, [1, -1]);
          return [
            matMul($x, ones$1([1, h], $x.dtype)),
            matMul(ones$1([w, 1], $y.dtype), $y)
          ];
        }
        function min_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "min");
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(Min2, inputs, attrs);
        }
        var min2 = op2({ min_ });
        function minimum_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "minimum");
          var $b = convertToTensor2(b, "b", "minimum");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          if ($a.dtype === "bool") {
            $a = cast5($a, "int32");
            $b = cast5($b, "int32");
          }
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Minimum2, inputs);
        }
        var minimum3 = op2({ minimum_ });
        function mirrorPad_(x, paddings, mode) {
          assert2(mode === "reflect" || mode === "symmetric", function() {
            return "Invalid mode. Mode must be either reflect or symmetric. " + ("Got " + mode + ".");
          });
          var $x = convertToTensor2(x, "x", "mirrorPad");
          if ($x.rank === 0) {
            throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
          }
          assert2(paddings.length === $x.rank, function() {
            return "Padding doesn't match input. Must be " + $x.rank + ". " + ("Got " + paddings.length + ".");
          });
          var shapeOffset = mode === "reflect" ? 1 : 0;
          var _loop_1 = function(i2) {
            assert2(paddings[i2].length === 2, function() {
              return "Invalid number of paddings. Must be length of 2 each.";
            });
            assert2(paddings[i2][0] >= 0 && paddings[i2][0] <= $x.shape[i2] - shapeOffset && paddings[i2][1] >= 0 && paddings[i2][1] <= $x.shape[i2] - shapeOffset, function() {
              return "Padding in dimension " + i2 + " cannot be greater than or equal " + ("to " + ($x.shape[i2] - shapeOffset) + " or less than 0 for input of ") + ("shape " + $x.shape);
            });
          };
          for (var i = 0; i < $x.rank; i++) {
            _loop_1(i);
          }
          var attrs = { paddings, mode };
          var inputs = { x: $x };
          return ENGINE2.runKernel(MirrorPad2, inputs, attrs);
        }
        var mirrorPad = op2({ mirrorPad_ });
        function mod_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "mod");
          var $b = convertToTensor2(b, "b", "mod");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(Mod2, inputs);
        }
        var mod3 = op2({ mod_ });
        function square_(x) {
          var $x = convertToTensor2(x, "x", "square");
          var attrs = {};
          return ENGINE2.runKernel("Square", { x: $x }, attrs);
        }
        var square2 = op2({ square_ });
        function moments_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          x = convertToTensor2(x, "x", "moments");
          var axes = parseAxisParam2(axis, x.shape);
          var xMean = mean(x, axes, keepDims);
          var keepDimsShape = xMean.shape;
          if (!keepDims) {
            keepDimsShape = expandShapeToKeepDim2(xMean.shape, axes);
          }
          var devSquared = square2(sub4(cast5(x, "float32"), reshape4(xMean, keepDimsShape)));
          var variance = mean(devSquared, axes, keepDims);
          return { mean: xMean, variance };
        }
        var moments = op2({ moments_ });
        function multiRNNCell_(lstmCells, data, c, h) {
          var $data = convertToTensor2(data, "data", "multiRNNCell");
          var $c = convertToTensorArray(c, "c", "multiRNNCell");
          var $h = convertToTensorArray(h, "h", "multiRNNCell");
          var input = $data;
          var newStates = [];
          for (var i = 0; i < lstmCells.length; i++) {
            var output = lstmCells[i](input, $c[i], $h[i]);
            newStates.push(output[0]);
            newStates.push(output[1]);
            input = output[1];
          }
          var newC = [];
          var newH = [];
          for (var i = 0; i < newStates.length; i += 2) {
            newC.push(newStates[i]);
            newH.push(newStates[i + 1]);
          }
          return [newC, newH];
        }
        var multiRNNCell = op2({ multiRNNCell_ });
        function multinomial_(logits, numSamples, seed, normalized) {
          if (normalized === void 0) {
            normalized = false;
          }
          var $logits = convertToTensor2(logits, "logits", "multinomial");
          var numOutcomes = $logits.size;
          var origRank = $logits.rank;
          if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + (numOutcomes + "."));
          }
          if (origRank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank);
          }
          seed = seed || Math.random();
          var logits2D = origRank === 1 ? reshape4($logits, [1, -1]) : $logits;
          var inputs = { logits: logits2D };
          var attrs = { numSamples, seed, normalized };
          var res = ENGINE2.runKernel(Multinomial2, inputs, attrs);
          return origRank === 1 ? reshape4(res, [res.size]) : res;
        }
        var multinomial2 = op2({ multinomial_ });
        function notEqual_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "notEqual");
          var $b = convertToTensor2(b, "b", "notEqual");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          return ENGINE2.runKernel(NotEqual2, inputs);
        }
        var notEqual3 = op2({ notEqual_ });
        function onesLike_(x) {
          var $x = convertToTensor2(x, "x", "onesLike");
          var inputs = { x: $x };
          return ENGINE2.runKernel(OnesLike2, inputs);
        }
        var onesLike2 = op2({ onesLike_ });
        function outerProduct_(v1, v2) {
          var $v1 = convertToTensor2(v1, "v1", "outerProduct");
          var $v2 = convertToTensor2(v2, "v2", "outerProduct");
          assert2($v1.rank === 1 && $v2.rank === 1, function() {
            return "Error in outerProduct: inputs must be rank 1, but got ranks " + ($v1.rank + " and " + $v2.rank + ".");
          });
          var v12D = reshape4($v1, [-1, 1]);
          var v22D = reshape4($v2, [1, -1]);
          return matMul(v12D, v22D);
        }
        var outerProduct = op2({ outerProduct_ });
        function pad_(x, paddings, constantValue) {
          if (constantValue === void 0) {
            constantValue = 0;
          }
          var $x = convertToTensor2(x, "x", "pad");
          if ($x.rank === 0) {
            throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
          }
          var attrs = { paddings, constantValue };
          var inputs = { x: $x };
          return ENGINE2.runKernel(PadV22, inputs, attrs);
        }
        var pad = op2({ pad_ });
        function pad1d_(x, paddings, constantValue) {
          if (constantValue === void 0) {
            constantValue = 0;
          }
          assert2(paddings.length === 2, function() {
            return "Invalid number of paddings. Must be length of 2.";
          });
          return pad(x, [paddings], constantValue);
        }
        var pad1d = op2({ pad1d_ });
        function pad2d_(x, paddings, constantValue) {
          if (constantValue === void 0) {
            constantValue = 0;
          }
          assert2(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
          });
          return pad(x, paddings, constantValue);
        }
        var pad2d = op2({ pad2d_ });
        function pad3d_(x, paddings, constantValue) {
          if (constantValue === void 0) {
            constantValue = 0;
          }
          assert2(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
          });
          return pad(x, paddings, constantValue);
        }
        var pad3d2 = op2({ pad3d_ });
        function pad4d_(x, paddings, constantValue) {
          if (constantValue === void 0) {
            constantValue = 0;
          }
          assert2(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
          });
          return pad(x, paddings, constantValue);
        }
        var pad4d = op2({ pad4d_ });
        function spaceToBatchND_(x, blockShape, paddings) {
          var $x = convertToTensor2(x, "x", "spaceToBatchND");
          assert2($x.rank >= 1 + blockShape.length, function() {
            return "input rank " + $x.rank + " should be > than [blockShape] " + blockShape.length;
          });
          assert2(paddings.length === blockShape.length, function() {
            return "paddings.shape[0] " + paddings.length + " must be equal to [blockShape] " + blockShape.length;
          });
          assert2($x.shape.reduce(function(a, b, i) {
            if (i > 0 && i <= blockShape.length) {
              return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
            }
            return a;
          }, true), function() {
            return "input spatial dimensions " + $x.shape.slice(1) + " with paddings " + paddings.toString() + " must be divisible by blockShapes " + blockShape.toString();
          });
          var inputs = { x: $x };
          var attrs = { blockShape, paddings };
          return ENGINE2.runKernel(SpaceToBatchND2, inputs, attrs);
        }
        var spaceToBatchND2 = op2({ spaceToBatchND_ });
        function pool_(input, windowShape, poolingType, pad2, dilations, strides) {
          if (dilations == null) {
            dilations = [1, 1];
          }
          if (strides == null) {
            strides = 1;
          }
          if (pad2 === 0) {
            pad2 = "valid";
          }
          var $x = convertToTensor2(input, "x", "maxPool");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in pool: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          var convInfo = computePool2DInfo2(x4D.shape, windowShape, strides, dilations, pad2);
          var dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
          var basePadding;
          if (pad2 === "same") {
            basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
          } else {
            basePadding = [[0, 0], [0, 0]];
          }
          var isDilationOne = dilation[0] === 1 && dilation[1] === 1;
          var _a = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding), adjustedPadding = _a[0], adjustedCrops = _a[1];
          var convertedPad = isDilationOne ? pad2 : "valid";
          var convertedX = isDilationOne ? x4D : spaceToBatchND2(x4D, dilation, adjustedPadding);
          var forwardOp = poolingType === "avg" ? function() {
            return avgPool2(convertedX, windowShape, strides, convertedPad);
          } : function() {
            return maxPool2(convertedX, windowShape, strides, convertedPad);
          };
          var y = forwardOp();
          var res = isDilationOne ? y : batchToSpaceND2(y, dilation, adjustedCrops);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
          var padStart = basePadding.map(function(b) {
            return b[0];
          });
          var origPadEnd = basePadding.map(function(b) {
            return b[1];
          });
          var fullInputShape = inputShape.concat(padStart, origPadEnd);
          var padEndExtra = blockShape.map(function(b, i) {
            return (b - fullInputShape[i] % b) % b;
          });
          var padEnd = origPadEnd.map(function(s, i) {
            return s + padEndExtra[i];
          });
          var paddings = blockShape.map(function(_, i) {
            return [padStart[i], padEnd[i]];
          });
          var crops = blockShape.map(function(_, i) {
            return [0, padEndExtra[i]];
          });
          return [paddings, crops];
        }
        function withSpaceToBatchBasePaddings(filterShape, dilation) {
          var dilatedFilterShape = filterShape.map(function(s, i) {
            return s + (s - 1) * (dilation[i] - 1);
          });
          var padExtraShape = dilatedFilterShape.map(function(s) {
            return s - 1;
          });
          var padExtraStart = padExtraShape.map(function(s) {
            return Math.floor(s / 2);
          });
          var padExtraEnd = padExtraShape.map(function(s, i) {
            return s - padExtraStart[i];
          });
          return padExtraShape.map(function(_, i) {
            return [padExtraStart[i], padExtraEnd[i]];
          });
        }
        var pool = op2({ pool_ });
        function pow_(base2, exp4) {
          var _a;
          var $base = convertToTensor2(base2, "base", "pow");
          var $exp = convertToTensor2(exp4, "exp", "pow");
          _a = makeTypesMatch2($base, $exp), $base = _a[0], $exp = _a[1];
          var inputs = { a: $base, b: $exp };
          return ENGINE2.runKernel(Pow2, inputs);
        }
        var pow2 = op2({ pow_ });
        function prelu_2(x, alpha) {
          var $x = convertToTensor2(x, "x", "prelu");
          var $alpha = convertToTensor2(alpha, "alpha", "prelu");
          var inputs = { x: $x, alpha: $alpha };
          return ENGINE2.runKernel(Prelu2, inputs);
        }
        var prelu3 = op2({ prelu_: prelu_2 });
        function prod_(x, axis, keepDims) {
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          var $x = convertToTensor2(x, "x", "prod");
          if ($x.dtype === "bool") {
            $x = cast5($x, "int32");
          }
          var inputs = { x: $x };
          var attrs = { axis, keepDims };
          return ENGINE2.runKernel(Prod2, inputs, attrs);
        }
        var prod2 = op2({ prod_ });
        function rand_(shape, randFunction, dtype) {
          var size = sizeFromShape2(shape);
          var values = null;
          if (dtype == null || dtype === "float32") {
            values = new Float32Array(size);
          } else if (dtype === "int32") {
            values = new Int32Array(size);
          } else if (dtype === "bool") {
            values = new Uint8Array(size);
          } else {
            throw new Error("Unknown data type " + dtype);
          }
          for (var i = 0; i < size; i++) {
            values[i] = randFunction();
          }
          return ENGINE2.makeTensor(values, shape, dtype);
        }
        var rand = op2({ rand_ });
        var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
        function createCommonjsModule(fn, module2) {
          return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
        }
        var alea = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function Alea(seed) {
              var me = this, mash = Mash();
              me.next = function() {
                var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
                me.s0 = me.s1;
                me.s1 = me.s2;
                return me.s2 = t - (me.c = t | 0);
              };
              me.c = 1;
              me.s0 = mash(" ");
              me.s1 = mash(" ");
              me.s2 = mash(" ");
              me.s0 -= mash(seed);
              if (me.s0 < 0) {
                me.s0 += 1;
              }
              me.s1 -= mash(seed);
              if (me.s1 < 0) {
                me.s1 += 1;
              }
              me.s2 -= mash(seed);
              if (me.s2 < 0) {
                me.s2 += 1;
              }
              mash = null;
            }
            function copy(f, t) {
              t.c = f.c;
              t.s0 = f.s0;
              t.s1 = f.s1;
              t.s2 = f.s2;
              return t;
            }
            function impl(seed, opts) {
              var xg = new Alea(seed), state2 = opts && opts.state, prng = xg.next;
              prng.int32 = function() {
                return xg.next() * 4294967296 | 0;
              };
              prng.double = function() {
                return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
              };
              prng.quick = prng;
              if (state2) {
                if (typeof state2 == "object")
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            function Mash() {
              var n = 4022871197;
              var mash = function(data) {
                data = data.toString();
                for (var i = 0; i < data.length; i++) {
                  n += data.charCodeAt(i);
                  var h = 0.02519603282416938 * n;
                  n = h >>> 0;
                  h -= n;
                  h *= n;
                  n = h >>> 0;
                  h -= n;
                  n += h * 4294967296;
                }
                return (n >>> 0) * 23283064365386963e-26;
              };
              return mash;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.alea = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var xor128 = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function XorGen(seed) {
              var me = this, strseed = "";
              me.x = 0;
              me.y = 0;
              me.z = 0;
              me.w = 0;
              me.next = function() {
                var t = me.x ^ me.x << 11;
                me.x = me.y;
                me.y = me.z;
                me.z = me.w;
                return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
              };
              if (seed === (seed | 0)) {
                me.x = seed;
              } else {
                strseed += seed;
              }
              for (var k = 0; k < strseed.length + 64; k++) {
                me.x ^= strseed.charCodeAt(k) | 0;
                me.next();
              }
            }
            function copy(f, t) {
              t.x = f.x;
              t.y = f.y;
              t.z = f.z;
              t.w = f.w;
              return t;
            }
            function impl(seed, opts) {
              var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
              };
              prng.double = function() {
                do {
                  var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result2 = (top + bot) / (1 << 21);
                } while (result2 === 0);
                return result2;
              };
              prng.int32 = xg.next;
              prng.quick = prng;
              if (state2) {
                if (typeof state2 == "object")
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.xor128 = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var xorwow = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function XorGen(seed) {
              var me = this, strseed = "";
              me.next = function() {
                var t = me.x ^ me.x >>> 2;
                me.x = me.y;
                me.y = me.z;
                me.z = me.w;
                me.w = me.v;
                return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
              };
              me.x = 0;
              me.y = 0;
              me.z = 0;
              me.w = 0;
              me.v = 0;
              if (seed === (seed | 0)) {
                me.x = seed;
              } else {
                strseed += seed;
              }
              for (var k = 0; k < strseed.length + 64; k++) {
                me.x ^= strseed.charCodeAt(k) | 0;
                if (k == strseed.length) {
                  me.d = me.x << 10 ^ me.x >>> 4;
                }
                me.next();
              }
            }
            function copy(f, t) {
              t.x = f.x;
              t.y = f.y;
              t.z = f.z;
              t.w = f.w;
              t.v = f.v;
              t.d = f.d;
              return t;
            }
            function impl(seed, opts) {
              var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
              };
              prng.double = function() {
                do {
                  var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result2 = (top + bot) / (1 << 21);
                } while (result2 === 0);
                return result2;
              };
              prng.int32 = xg.next;
              prng.quick = prng;
              if (state2) {
                if (typeof state2 == "object")
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.xorwow = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var xorshift7 = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function XorGen(seed) {
              var me = this;
              me.next = function() {
                var X = me.x, i = me.i, t, v;
                t = X[i];
                t ^= t >>> 7;
                v = t ^ t << 24;
                t = X[i + 1 & 7];
                v ^= t ^ t >>> 10;
                t = X[i + 3 & 7];
                v ^= t ^ t >>> 3;
                t = X[i + 4 & 7];
                v ^= t ^ t << 7;
                t = X[i + 7 & 7];
                t = t ^ t << 13;
                v ^= t ^ t << 9;
                X[i] = v;
                me.i = i + 1 & 7;
                return v;
              };
              function init(me2, seed2) {
                var j, w, X = [];
                if (seed2 === (seed2 | 0)) {
                  w = X[0] = seed2;
                } else {
                  seed2 = "" + seed2;
                  for (j = 0; j < seed2.length; ++j) {
                    X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
                  }
                }
                while (X.length < 8)
                  X.push(0);
                for (j = 0; j < 8 && X[j] === 0; ++j)
                  ;
                if (j == 8)
                  w = X[7] = -1;
                else
                  w = X[j];
                me2.x = X;
                me2.i = 0;
                for (j = 256; j > 0; --j) {
                  me2.next();
                }
              }
              init(me, seed);
            }
            function copy(f, t) {
              t.x = f.x.slice();
              t.i = f.i;
              return t;
            }
            function impl(seed, opts) {
              if (seed == null)
                seed = +new Date();
              var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
              };
              prng.double = function() {
                do {
                  var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result2 = (top + bot) / (1 << 21);
                } while (result2 === 0);
                return result2;
              };
              prng.int32 = xg.next;
              prng.quick = prng;
              if (state2) {
                if (state2.x)
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.xorshift7 = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var xor4096 = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function XorGen(seed) {
              var me = this;
              me.next = function() {
                var w = me.w, X = me.X, i = me.i, t, v;
                me.w = w = w + 1640531527 | 0;
                v = X[i + 34 & 127];
                t = X[i = i + 1 & 127];
                v ^= v << 13;
                t ^= t << 17;
                v ^= v >>> 15;
                t ^= t >>> 12;
                v = X[i] = v ^ t;
                me.i = i;
                return v + (w ^ w >>> 16) | 0;
              };
              function init(me2, seed2) {
                var t, v, i, j, w, X = [], limit = 128;
                if (seed2 === (seed2 | 0)) {
                  v = seed2;
                  seed2 = null;
                } else {
                  seed2 = seed2 + "\0";
                  v = 0;
                  limit = Math.max(limit, seed2.length);
                }
                for (i = 0, j = -32; j < limit; ++j) {
                  if (seed2)
                    v ^= seed2.charCodeAt((j + 32) % seed2.length);
                  if (j === 0)
                    w = v;
                  v ^= v << 10;
                  v ^= v >>> 15;
                  v ^= v << 4;
                  v ^= v >>> 13;
                  if (j >= 0) {
                    w = w + 1640531527 | 0;
                    t = X[j & 127] ^= v + w;
                    i = t == 0 ? i + 1 : 0;
                  }
                }
                if (i >= 128) {
                  X[(seed2 && seed2.length || 0) & 127] = -1;
                }
                i = 127;
                for (j = 4 * 128; j > 0; --j) {
                  v = X[i + 34 & 127];
                  t = X[i = i + 1 & 127];
                  v ^= v << 13;
                  t ^= t << 17;
                  v ^= v >>> 15;
                  t ^= t >>> 12;
                  X[i] = v ^ t;
                }
                me2.w = w;
                me2.X = X;
                me2.i = i;
              }
              init(me, seed);
            }
            function copy(f, t) {
              t.i = f.i;
              t.w = f.w;
              t.X = f.X.slice();
              return t;
            }
            function impl(seed, opts) {
              if (seed == null)
                seed = +new Date();
              var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
              };
              prng.double = function() {
                do {
                  var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result2 = (top + bot) / (1 << 21);
                } while (result2 === 0);
                return result2;
              };
              prng.int32 = xg.next;
              prng.quick = prng;
              if (state2) {
                if (state2.X)
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.xor4096 = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var tychei = createCommonjsModule(function(module2) {
          (function(global2, module3, define2) {
            function XorGen(seed) {
              var me = this, strseed = "";
              me.next = function() {
                var b = me.b, c = me.c, d = me.d, a = me.a;
                b = b << 25 ^ b >>> 7 ^ c;
                c = c - d | 0;
                d = d << 24 ^ d >>> 8 ^ a;
                a = a - b | 0;
                me.b = b = b << 20 ^ b >>> 12 ^ c;
                me.c = c = c - d | 0;
                me.d = d << 16 ^ c >>> 16 ^ a;
                return me.a = a - b | 0;
              };
              me.a = 0;
              me.b = 0;
              me.c = 2654435769 | 0;
              me.d = 1367130551;
              if (seed === Math.floor(seed)) {
                me.a = seed / 4294967296 | 0;
                me.b = seed | 0;
              } else {
                strseed += seed;
              }
              for (var k = 0; k < strseed.length + 20; k++) {
                me.b ^= strseed.charCodeAt(k) | 0;
                me.next();
              }
            }
            function copy(f, t) {
              t.a = f.a;
              t.b = f.b;
              t.c = f.c;
              t.d = f.d;
              return t;
            }
            function impl(seed, opts) {
              var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
                return (xg.next() >>> 0) / 4294967296;
              };
              prng.double = function() {
                do {
                  var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result2 = (top + bot) / (1 << 21);
                } while (result2 === 0);
                return result2;
              };
              prng.int32 = xg.next;
              prng.quick = prng;
              if (state2) {
                if (typeof state2 == "object")
                  copy(state2, xg);
                prng.state = function() {
                  return copy(xg, {});
                };
              }
              return prng;
            }
            if (module3 && module3.exports) {
              module3.exports = impl;
            } else if (define2 && define2.amd) {
              define2(function() {
                return impl;
              });
            } else {
              this.tychei = impl;
            }
          })(commonjsGlobal, module2, false);
        });
        var seedrandom = createCommonjsModule(function(module2) {
          (function(pool2, math2) {
            var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
            function seedrandom2(seed, options, callback) {
              var key = [];
              options = options == true ? { entropy: true } : options || {};
              var shortseed = mixkey(flatten3(options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed, 3), key);
              var arc4 = new ARC4(key);
              var prng = function() {
                var n = arc4.g(chunks), d = startdenom, x = 0;
                while (n < significance) {
                  n = (n + x) * width;
                  d *= width;
                  x = arc4.g(1);
                }
                while (n >= overflow) {
                  n /= 2;
                  d /= 2;
                  x >>>= 1;
                }
                return (n + x) / d;
              };
              prng.int32 = function() {
                return arc4.g(4) | 0;
              };
              prng.quick = function() {
                return arc4.g(4) / 4294967296;
              };
              prng.double = prng;
              mixkey(tostring(arc4.S), pool2);
              return (options.pass || callback || function(prng2, seed2, is_math_call, state2) {
                if (state2) {
                  if (state2.S) {
                    copy(state2, arc4);
                  }
                  prng2.state = function() {
                    return copy(arc4, {});
                  };
                }
                if (is_math_call) {
                  math2[rngname] = prng2;
                  return seed2;
                } else
                  return prng2;
              })(prng, shortseed, "global" in options ? options.global : this == math2, options.state);
            }
            math2["seed" + rngname] = seedrandom2;
            function ARC4(key) {
              var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
              if (!keylen) {
                key = [keylen++];
              }
              while (i < width) {
                s[i] = i++;
              }
              for (i = 0; i < width; i++) {
                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                s[j] = t;
              }
              (me.g = function(count) {
                var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
                while (count--) {
                  t2 = s2[i2 = mask & i2 + 1];
                  r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
                }
                me.i = i2;
                me.j = j2;
                return r;
              })(width);
            }
            function copy(f, t) {
              t.i = f.i;
              t.j = f.j;
              t.S = f.S.slice();
              return t;
            }
            function flatten3(obj, depth) {
              var result2 = [], typ = typeof obj, prop;
              if (depth && typ == "object") {
                for (prop in obj) {
                  try {
                    result2.push(flatten3(obj[prop], depth - 1));
                  } catch (e) {
                  }
                }
              }
              return result2.length ? result2 : typ == "string" ? obj : obj + "\0";
            }
            function mixkey(seed, key) {
              var stringseed = seed + "", smear, j = 0;
              while (j < stringseed.length) {
                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
              }
              return tostring(key);
            }
            function autoseed() {
              try {
                var out;
                if (nodecrypto && (out = nodecrypto.randomBytes)) {
                  out = out(width);
                } else {
                  out = new Uint8Array(width);
                  (global2.crypto || global2.msCrypto).getRandomValues(out);
                }
                return tostring(out);
              } catch (e) {
                var browser3 = global2.navigator, plugins = browser3 && browser3.plugins;
                return [+new Date(), global2, plugins, global2.screen, tostring(pool2)];
              }
            }
            function tostring(a) {
              return String.fromCharCode.apply(0, a);
            }
            mixkey(math2.random(), pool2);
            if (module2.exports) {
              module2.exports = seedrandom2;
              try {
                nodecrypto = require_crypto();
              } catch (ex) {
              }
            }
          })([], Math);
        });
        seedrandom.alea = alea;
        seedrandom.xor128 = xor128;
        seedrandom.xorwow = xorwow;
        seedrandom.xorshift7 = xorshift7;
        seedrandom.xor4096 = xor4096;
        seedrandom.tychei = tychei;
        var seedrandom$1 = seedrandom;
        var seedrandom_1 = seedrandom$1.alea;
        var MPRandGauss = function() {
          function MPRandGauss2(mean2, stdDeviation, dtype, truncated, seed) {
            this.mean = mean2;
            this.stdDev = stdDeviation;
            this.dtype = dtype;
            this.nextVal = NaN;
            this.truncated = truncated;
            if (this.truncated) {
              this.upper = this.mean + this.stdDev * 2;
              this.lower = this.mean - this.stdDev * 2;
            }
            var seedValue = seed ? seed : Math.random();
            this.random = seedrandom_1(seedValue.toString());
          }
          MPRandGauss2.prototype.nextValue = function() {
            if (!isNaN(this.nextVal)) {
              var value = this.nextVal;
              this.nextVal = NaN;
              return value;
            }
            var resultX, resultY;
            var isValid = false;
            while (!isValid) {
              var v1 = void 0, v2 = void 0, s = void 0;
              do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
              } while (s >= 1 || s === 0);
              var mul4 = Math.sqrt(-2 * Math.log(s) / s);
              resultX = this.mean + this.stdDev * v1 * mul4;
              resultY = this.mean + this.stdDev * v2 * mul4;
              if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
              }
            }
            if (!this.truncated || this.isValidTruncated(resultY)) {
              this.nextVal = this.convertValue(resultY);
            }
            return this.convertValue(resultX);
          };
          MPRandGauss2.prototype.convertValue = function(value) {
            if (this.dtype == null || this.dtype === "float32") {
              return value;
            }
            return Math.round(value);
          };
          MPRandGauss2.prototype.isValidTruncated = function(value) {
            return value <= this.upper && value >= this.lower;
          };
          return MPRandGauss2;
        }();
        var RandGamma = function() {
          function RandGamma2(alpha, beta, dtype, seed) {
            this.alpha = alpha;
            this.beta = 1 / beta;
            this.dtype = dtype;
            var seedValue = seed ? seed : Math.random();
            this.randu = seedrandom_1(seedValue.toString());
            this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
            if (alpha < 1) {
              this.d = alpha + 2 / 3;
            } else {
              this.d = alpha - 1 / 3;
            }
            this.c = 1 / Math.sqrt(9 * this.d);
          }
          RandGamma2.prototype.nextValue = function() {
            var x2, v0, v1, x, u, v;
            while (true) {
              do {
                x = this.randn.nextValue();
                v = 1 + this.c * x;
              } while (v <= 0);
              v *= v * v;
              x2 = x * x;
              v0 = 1 - 0.331 * x2 * x2;
              v1 = 0.5 * x2 + this.d * (1 - v + Math.log(v));
              u = this.randu();
              if (u < v0 || Math.log(u) < v1) {
                break;
              }
            }
            v = 1 / this.beta * this.d * v;
            if (this.alpha < 1) {
              v *= Math.pow(this.randu(), 1 / this.alpha);
            }
            return this.convertValue(v);
          };
          RandGamma2.prototype.convertValue = function(value) {
            if (this.dtype === "float32") {
              return value;
            }
            return Math.round(value);
          };
          return RandGamma2;
        }();
        var UniformRandom = function() {
          function UniformRandom2(min3, max3, dtype, seed) {
            var _this = this;
            if (min3 === void 0) {
              min3 = 0;
            }
            if (max3 === void 0) {
              max3 = 1;
            }
            this.canReturnFloat = function() {
              return _this.dtype == null || _this.dtype === "float32";
            };
            this.min = min3;
            this.range = max3 - min3;
            this.dtype = dtype;
            if (seed == null) {
              seed = Math.random();
            }
            if (typeof seed === "number") {
              seed = seed.toString();
            }
            if (!this.canReturnFloat() && this.range <= 1) {
              throw new Error("The difference between " + min3 + " - " + max3 + " <= 1 and dtype is not float");
            }
            this.random = seedrandom_1(seed);
          }
          UniformRandom2.prototype.convertValue = function(value) {
            if (this.canReturnFloat()) {
              return value;
            }
            return Math.round(value);
          };
          UniformRandom2.prototype.nextValue = function() {
            return this.convertValue(this.min + this.range * this.random());
          };
          return UniformRandom2;
        }();
        function randomGamma_(shape, alpha, beta, dtype, seed) {
          if (beta === void 0) {
            beta = 1;
          }
          if (dtype === void 0) {
            dtype = "float32";
          }
          if (beta == null) {
            beta = 1;
          }
          if (dtype == null) {
            dtype = "float32";
          }
          if (dtype !== "float32" && dtype !== "int32") {
            throw new Error("Unsupported data type " + dtype);
          }
          var rgamma = new RandGamma(alpha, beta, dtype, seed);
          var res = buffer2(shape, dtype);
          for (var i = 0; i < res.values.length; i++) {
            res.values[i] = rgamma.nextValue();
          }
          return res.toTensor();
        }
        var randomGamma = op2({ randomGamma_ });
        function randomNormal_(shape, mean2, stdDev, dtype, seed) {
          if (mean2 === void 0) {
            mean2 = 0;
          }
          if (stdDev === void 0) {
            stdDev = 1;
          }
          if (dtype != null && dtype === "bool") {
            throw new Error("Unsupported data type " + dtype);
          }
          var randGauss = new MPRandGauss(mean2, stdDev, dtype, false, seed);
          var res = buffer2(shape, dtype);
          for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
          }
          return res.toTensor();
        }
        var randomNormal = op2({ randomNormal_ });
        function randomUniform_(shape, minval, maxval, dtype, seed) {
          if (minval === void 0) {
            minval = 0;
          }
          if (maxval === void 0) {
            maxval = 1;
          }
          if (dtype === void 0) {
            dtype = "float32";
          }
          var res = buffer2(shape, dtype);
          var random = new UniformRandom(minval, maxval, null, seed);
          for (var i = 0; i < res.values.length; i++) {
            res.values[i] = random.nextValue();
          }
          return res.toTensor();
        }
        var randomUniform = op2({ randomUniform_ });
        function range2(start, stop, step4, dtype) {
          if (step4 === void 0) {
            step4 = 1;
          }
          if (dtype === void 0) {
            dtype = "float32";
          }
          if (step4 === 0) {
            throw new Error("Cannot have a step of zero");
          }
          var attrs = { start, stop, step: step4, dtype };
          return ENGINE2.runKernel(Range2, {}, attrs);
        }
        function real_(input) {
          var $input = convertToTensor2(input, "input", "real");
          var inputs = { input: $input };
          return ENGINE2.runKernel(Real2, inputs);
        }
        var real3 = op2({ real_ });
        function reciprocal_(x) {
          var $x = convertToTensor2(x, "x", "reciprocal");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Reciprocal2, inputs);
        }
        var reciprocal2 = op2({ reciprocal_ });
        function relu_2(x) {
          var $x = convertToTensor2(x, "x", "relu");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Relu2, inputs);
        }
        var relu3 = op2({ relu_: relu_2 });
        function relu6_2(x) {
          var $x = convertToTensor2(x, "x", "relu6");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Relu62, inputs);
        }
        var relu63 = op2({ relu6_: relu6_2 });
        function reverse_(x, axis) {
          var $x = convertToTensor2(x, "x", "reverse");
          var inputs = { x: $x };
          var attrs = { dims: axis };
          return ENGINE2.runKernel(Reverse2, inputs, attrs);
        }
        var reverse2 = op2({ reverse_ });
        function reverse1d_(x) {
          var $x = convertToTensor2(x, "x", "reverse");
          assert2($x.rank === 1, function() {
            return "Error in reverse1D: x must be rank 1 but got rank " + $x.rank + ".";
          });
          return reverse2($x, 0);
        }
        var reverse1d = op2({ reverse1d_ });
        function reverse2d_(x, axis) {
          var $x = convertToTensor2(x, "x", "reverse");
          assert2($x.rank === 2, function() {
            return "Error in reverse2D: x must be rank 2 but got rank " + $x.rank + ".";
          });
          return reverse2($x, axis);
        }
        var reverse2d = op2({ reverse2d_ });
        function reverse3d_(x, axis) {
          var $x = convertToTensor2(x, "x", "reverse");
          assert2($x.rank === 3, function() {
            return "Error in reverse3D: x must be rank 3 but got rank " + $x.rank + ".";
          });
          return reverse2($x, axis);
        }
        var reverse3d = op2({ reverse3d_ });
        function reverse4d_(x, axis) {
          var $x = convertToTensor2(x, "x", "reverse");
          assert2($x.rank === 4, function() {
            return "Error in reverse4D: x must be rank 4 but got rank " + $x.rank + ".";
          });
          return reverse2($x, axis);
        }
        var reverse4d = op2({ reverse4d_ });
        function round_(x) {
          var $x = convertToTensor2(x, "x", "round");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Round2, inputs);
        }
        var round$1 = op2({ round_ });
        function rsqrt_(x) {
          var $x = convertToTensor2(x, "x", "rsqrt");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Rsqrt2, inputs);
        }
        var rsqrt3 = op2({ rsqrt_ });
        function scalar3(value, dtype) {
          if ((isTypedArray2(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
            throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
          }
          if (dtype === "string" && isTypedArray2(value) && !(value instanceof Uint8Array)) {
            throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
          }
          var shape = [];
          var inferredShape = [];
          return makeTensor2(value, shape, inferredShape, dtype);
        }
        function selu_(x) {
          var $x = convertToTensor2(x, "x", "selu");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Selu2, inputs);
        }
        var selu2 = op2({ selu_ });
        function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad2, dilation, dataFormat) {
          if (dilation === void 0) {
            dilation = [1, 1];
          }
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          var $x = convertToTensor2(x, "x", "separableConv2d");
          var $depthwiseFilter = convertToTensor2(depthwiseFilter, "depthwiseFilter", "separableConv2d");
          var $pointwiseFilter = convertToTensor2(pointwiseFilter, "pointwiseFilter", "separableConv2d");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          if (dataFormat === "NCHW") {
            throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
          }
          assert2(x4D.rank === 4, function() {
            return "Error in separableConv2d: input must be rank 4, but got " + ("rank " + x4D.rank + ".");
          });
          assert2($depthwiseFilter.rank === 4, function() {
            return "Error in separableConv2d: depthwise filter must be rank 4, but " + ("got rank " + $depthwiseFilter.rank + ".");
          });
          assert2($pointwiseFilter.rank === 4, function() {
            return "Error in separableConv2d: pointwise filter must be rank 4, but " + ("got rank " + $depthwiseFilter.rank + ".");
          });
          assert2($pointwiseFilter.shape[0] === 1, function() {
            return "Error in separableConv2d: the first dimension of pointwise filter " + (" must be 1, but got " + $pointwiseFilter.shape[0] + ".");
          });
          assert2($pointwiseFilter.shape[1] === 1, function() {
            return "Error in separableConv2d: the second dimension of pointwise " + ("filter must be 1, but got " + $pointwiseFilter.shape[1] + ".");
          });
          var inChannels = $depthwiseFilter.shape[2];
          var channelMultiplier = $depthwiseFilter.shape[3];
          assert2($pointwiseFilter.shape[2] === inChannels * channelMultiplier, function() {
            return "Error in separableConv2d: the third dimension of pointwise filter " + ("must be " + inChannels * channelMultiplier + ", ") + ("but got " + $pointwiseFilter.shape[2] + ".");
          });
          var depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad2, dataFormat, dilation);
          var pointwiseStride = 1;
          var res = conv2d2(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var separableConv2d = op2({ separableConv2d_ });
        function setdiff1dAsync_(x, y) {
          return __awaiter2(this, void 0, void 0, function() {
            var $x, $y, xVals, yVals, ySet, outputSize, i, buffer3, indices, i, p;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  $x = convertToTensor2(x, "x", "setdiff1d");
                  $y = convertToTensor2(y, "y", "setdiff1d");
                  assert2($x.dtype === $y.dtype, function() {
                    return "x and y should have the same dtype, but got x (" + $x.dtype + ") and y (" + $y.dtype + ").";
                  });
                  assert2($x.rank === 1, function() {
                    return "x should be 1D tensor, but got x (" + $x.shape + ").";
                  });
                  assert2($y.rank === 1, function() {
                    return "y should be 1D tensor, but got y (" + $y.shape + ").";
                  });
                  return [4, $x.data()];
                case 1:
                  xVals = _a.sent();
                  return [4, $y.data()];
                case 2:
                  yVals = _a.sent();
                  ySet = new Set(yVals);
                  outputSize = 0;
                  for (i = 0; i < xVals.length; i++) {
                    if (!ySet.has(xVals[i])) {
                      outputSize++;
                    }
                  }
                  buffer3 = new TensorBuffer2([outputSize], $x.dtype);
                  indices = new TensorBuffer2([outputSize], "int32");
                  for (i = 0, p = 0; i < xVals.length; i++) {
                    if (!ySet.has(xVals[i])) {
                      buffer3.values[p] = xVals[i];
                      indices.values[p] = i;
                      p++;
                    }
                  }
                  return [2, [buffer3.toTensor(), indices.toTensor()]];
              }
            });
          });
        }
        var setdiff1dAsync = setdiff1dAsync_;
        function sign_(x) {
          var $x = convertToTensor2(x, "x", "sign");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Sign2, inputs);
        }
        var sign2 = op2({ sign_ });
        function sin_(x) {
          var $x = convertToTensor2(x, "x", "sin");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Sin2, inputs);
        }
        var sin2 = op2({ sin_ });
        function sinh_(x) {
          var $x = convertToTensor2(x, "x", "sinh");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Sinh2, inputs);
        }
        var sinh2 = op2({ sinh_ });
        function slice1d_(x, begin, size) {
          var $x = convertToTensor2(x, "x", "slice1d");
          assert2($x.rank === 1, function() {
            return "slice1d expects a rank-1 tensor, but got a rank-" + $x.rank + " tensor";
          });
          return slice2($x, [begin], [size]);
        }
        var slice1d = op2({ slice1d_ });
        function slice2d_(x, begin, size) {
          var $x = convertToTensor2(x, "x", "slice2d");
          assert2($x.rank === 2, function() {
            return "slice2d expects a rank-2 tensor, but got a rank-" + $x.rank + " tensor";
          });
          return slice2($x, begin, size);
        }
        var slice2d = op2({ slice2d_ });
        function slice3d_(x, begin, size) {
          var $x = convertToTensor2(x, "x", "slice3d");
          assert2($x.rank === 3, function() {
            return "slice3d expects a rank-3 tensor, but got a rank-" + $x.rank + " tensor";
          });
          return slice2($x, begin, size);
        }
        var slice3d = op2({ slice3d_ });
        function slice4d_(x, begin, size) {
          var $x = convertToTensor2(x, "x", "slice4d");
          assert2($x.rank === 4, function() {
            return "slice4d expects a rank-4 tensor, but got a rank-" + $x.rank + " tensor";
          });
          return slice2($x, begin, size);
        }
        var slice4d = op2({ slice4d_ });
        function softmax_(logits, dim) {
          if (dim === void 0) {
            dim = -1;
          }
          var $logits = convertToTensor2(logits, "logits", "softmax", "float32");
          if (dim === -1) {
            dim = $logits.rank - 1;
          }
          if (dim !== $logits.rank - 1) {
            throw Error("Softmax along a non-last dimension is not yet supported. " + ("Logits was rank " + $logits.rank + " and dim was " + dim));
          }
          var inputs = { logits: $logits };
          var attrs = { dim };
          return ENGINE2.runKernel(Softmax2, inputs, attrs);
        }
        var softmax2 = op2({ softmax_ });
        function fft_(input) {
          assert2(input.dtype === "complex64", function() {
            return "The dtype for tf.spectral.fft() must be complex64 " + ("but got " + input.dtype + ".");
          });
          var inputs = { input };
          return ENGINE2.runKernel(FFT2, inputs);
        }
        var fft2 = op2({ fft_ });
        function ifft_(input) {
          assert2(input.dtype === "complex64", function() {
            return "The dtype for tf.spectral.ifft() must be complex64 " + ("but got " + input.dtype + ".");
          });
          var inputs = { input };
          return ENGINE2.runKernel(IFFT2, inputs);
        }
        var ifft2 = op2({ ifft_ });
        function irfft_(input) {
          var innerDimensionSize = input.shape[input.shape.length - 1];
          var batch = input.size / innerDimensionSize;
          var ret;
          if (innerDimensionSize <= 2) {
            var complexInput = reshape4(input, [batch, innerDimensionSize]);
            ret = ifft2(complexInput);
          } else {
            var outputShape = [batch, 2 * (innerDimensionSize - 1)];
            var realInput = reshape4(real3(input), [batch, innerDimensionSize]);
            var imagInput = reshape4(imag2(input), [batch, innerDimensionSize]);
            var realConjugate = reverse2(slice2(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
            var imagConjugate = mul3(reverse2(slice2(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar3(-1));
            var r = concat3([realInput, realConjugate], 1);
            var i = concat3([imagInput, imagConjugate], 1);
            var complexInput = reshape4(complex4(r, i), [outputShape[0], outputShape[1]]);
            ret = ifft2(complexInput);
          }
          ret = real3(ret);
          if (input.rank === 3 && input.shape[0] !== 0) {
            var temp = ret;
            var batch_1 = input.shape[0];
            ret = reshape4(ret, [batch_1, ret.shape[0] / batch_1, ret.shape[1]]);
            temp.dispose();
          }
          return ret;
        }
        var irfft = op2({ irfft_ });
        function split_(x, numOrSizeSplits, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "split");
          var inputs = { x: $x };
          var attr = { numOrSizeSplits, axis };
          return ENGINE2.runKernel(SplitV2, inputs, attr);
        }
        var split2 = op2({ split_ });
        function rfft_(input, fftLength) {
          assert2(input.dtype === "float32", function() {
            return "The dtype for rfft() must be real value but got " + input.dtype;
          });
          var innerDimensionSize = input.shape[input.shape.length - 1];
          var batch = input.size / innerDimensionSize;
          var adjustedInput;
          if (fftLength != null && fftLength < innerDimensionSize) {
            var begin = input.shape.map(function(v) {
              return 0;
            });
            var size = input.shape.map(function(v) {
              return v;
            });
            size[input.shape.length - 1] = fftLength;
            adjustedInput = slice2(input, begin, size);
            innerDimensionSize = fftLength;
          } else if (fftLength != null && fftLength > innerDimensionSize) {
            var zerosShape = input.shape.map(function(v) {
              return v;
            });
            zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
            adjustedInput = concat3([input, zeros3(zerosShape)], input.shape.length - 1);
            innerDimensionSize = fftLength;
          } else {
            adjustedInput = input;
          }
          var zerosInput = zerosLike2(adjustedInput);
          var complexInput = reshape4(complex4(adjustedInput, zerosInput), [batch, innerDimensionSize]);
          var ret = fft2(complexInput);
          var half2 = Math.floor(innerDimensionSize / 2) + 1;
          var realValues = real3(ret);
          var imagValues = imag2(ret);
          var realComplexConjugate = split2(realValues, [half2, innerDimensionSize - half2], realValues.shape.length - 1);
          var imagComplexConjugate = split2(imagValues, [half2, innerDimensionSize - half2], imagValues.shape.length - 1);
          var outputShape = adjustedInput.shape.slice();
          outputShape[adjustedInput.shape.length - 1] = half2;
          return reshape4(complex4(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
        }
        var rfft = op2({ rfft_ });
        function sqrt_(x) {
          var $x = convertToTensor2(x, "x", "sqrt");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Sqrt2, inputs);
        }
        var sqrt2 = op2({ sqrt_ });
        function squaredDifference_(a, b) {
          var _a;
          var $a = convertToTensor2(a, "a", "squaredDifference");
          var $b = convertToTensor2(b, "b", "squaredDifference");
          _a = makeTypesMatch2($a, $b), $a = _a[0], $b = _a[1];
          assertAndGetBroadcastShape2($a.shape, $b.shape);
          var inputs = { a: $a, b: $b };
          var attrs = {};
          return ENGINE2.runKernel(SquaredDifference2, inputs, attrs);
        }
        var squaredDifference3 = op2({ squaredDifference_ });
        function squeeze_(x, axis) {
          var $x = convertToTensor2(x, "x", "squeeze");
          return reshape4($x, squeezeShape2($x.shape, axis).newShape);
        }
        var squeeze2 = op2({ squeeze_ });
        function stack_(tensors, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
          assert2($tensors.length >= 1, function() {
            return "Pass at least one tensor to tf.stack";
          });
          if ($tensors.length > 0) {
            assert2(axis <= $tensors[0].rank, function() {
              return "Axis must be <= rank of the tensor";
            });
          }
          var inputs = $tensors;
          var attrs = { axis };
          return ENGINE2.runKernel(Pack2, inputs, attrs);
        }
        var stack = op2({ stack_ });
        function step_2(x, alpha) {
          if (alpha === void 0) {
            alpha = 0;
          }
          var $x = convertToTensor2(x, "x", "step");
          var inputs = { x: $x };
          var attrs = { alpha };
          return ENGINE2.runKernel(Step2, inputs, attrs);
        }
        var step3 = op2({ step_: step_2 });
        function stridedSlice_(x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
          if (beginMask === void 0) {
            beginMask = 0;
          }
          if (endMask === void 0) {
            endMask = 0;
          }
          if (ellipsisMask === void 0) {
            ellipsisMask = 0;
          }
          if (newAxisMask === void 0) {
            newAxisMask = 0;
          }
          if (shrinkAxisMask === void 0) {
            shrinkAxisMask = 0;
          }
          var $x = convertToTensor2(x, "x", "stridedSlice");
          var inputs = { x: $x };
          var attrs = {
            begin,
            end,
            strides,
            beginMask,
            endMask,
            ellipsisMask,
            newAxisMask,
            shrinkAxisMask
          };
          return ENGINE2.runKernel(StridedSlice2, inputs, attrs);
        }
        var stridedSlice2 = op2({ stridedSlice_ });
        function tan_(x) {
          var $x = convertToTensor2(x, "x", "tan");
          var inputs = { x: $x };
          return ENGINE2.runKernel(Tan2, inputs);
        }
        var tan2 = op2({ tan_ });
        function tensor1d(values, dtype) {
          assertNonNull2(values);
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 1) {
            throw new Error("tensor1d() requires values to be a flat/TypedArray");
          }
          var shape = null;
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        function tensor2d2(values, shape, dtype) {
          assertNonNull2(values);
          if (shape != null && shape.length !== 2) {
            throw new Error("tensor2d() requires shape to have two numbers");
          }
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 2 && inferredShape.length !== 1) {
            throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
          }
          if (inferredShape.length === 1 && shape == null) {
            throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
          }
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        function tensor4d(values, shape, dtype) {
          assertNonNull2(values);
          if (shape != null && shape.length !== 4) {
            throw new Error("tensor4d() requires shape to have four numbers");
          }
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 4 && inferredShape.length !== 1) {
            throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
          }
          if (inferredShape.length === 1 && shape == null) {
            throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
          }
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        function tensor5d(values, shape, dtype) {
          assertNonNull2(values);
          if (shape != null && shape.length !== 5) {
            throw new Error("tensor5d() requires shape to have five numbers");
          }
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 5 && inferredShape.length !== 1) {
            throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
          }
          if (inferredShape.length === 1 && shape == null) {
            throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
          }
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        function tensor6d(values, shape, dtype) {
          assertNonNull2(values);
          if (shape != null && shape.length !== 6) {
            throw new Error("tensor6d() requires shape to have six numbers");
          }
          var inferredShape = inferShape2(values, dtype);
          if (inferredShape.length !== 6 && inferredShape.length !== 1) {
            throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
          }
          if (inferredShape.length === 1 && shape == null) {
            throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
          }
          shape = shape || inferredShape;
          return makeTensor2(values, shape, inferredShape, dtype);
        }
        function topk_(x, k, sorted) {
          if (k === void 0) {
            k = 1;
          }
          if (sorted === void 0) {
            sorted = true;
          }
          var $x = convertToTensor2(x, "x", "topk");
          if ($x.rank === 0) {
            throw new Error("topk() expects the input to be of rank 1 or higher");
          }
          var lastDim = $x.shape[$x.shape.length - 1];
          if (k > lastDim) {
            throw new Error("'k' passed to topk() must be <= the last dimension (" + lastDim + ") " + ("but got " + k));
          }
          var inputs = { x: $x };
          var attrs = { k, sorted };
          var _a = ENGINE2.runKernel(TopK2, inputs, attrs), values = _a[0], indices = _a[1];
          return { values, indices };
        }
        var topk = op2({ topk_ });
        function truncatedNormal_(shape, mean2, stdDev, dtype, seed) {
          if (mean2 === void 0) {
            mean2 = 0;
          }
          if (stdDev === void 0) {
            stdDev = 1;
          }
          if (dtype != null && dtype === "bool") {
            throw new Error("Unsupported data type $ { dtype }");
          }
          var randGauss = new MPRandGauss(mean2, stdDev, dtype, true, seed);
          var res = buffer2(shape, dtype);
          for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
          }
          return res.toTensor();
        }
        var truncatedNormal = op2({ truncatedNormal_ });
        function unique_(x, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "unique", "string_or_numeric");
          assert2($x.rank > 0, function() {
            return "The input tensor must be at least 1D";
          });
          var inputs = { x: $x };
          var attrs = { axis };
          var _a = ENGINE2.runKernel(Unique2, inputs, attrs), values = _a[0], indices = _a[1];
          return { values, indices };
        }
        var unique2 = op2({ unique_ });
        function unsortedSegmentSum_(x, segmentIds, numSegments) {
          var $x = convertToTensor2(x, "x", "unsortedSegmentSum");
          var $segmentIds = convertToTensor2(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
          assert2(isInt2(numSegments), function() {
            return "numSegments must be of dtype int";
          });
          var inputs = { x: $x, segmentIds: $segmentIds };
          var attrs = { numSegments };
          return ENGINE2.runKernel(UnsortedSegmentSum2, inputs, attrs);
        }
        var unsortedSegmentSum2 = op2({ unsortedSegmentSum_ });
        function unstack_(x, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var $x = convertToTensor2(x, "x", "unstack", "string_or_numeric");
          assert2(axis >= -$x.shape.length && axis < $x.shape.length, function() {
            return "Axis = " + axis + " is not in [-" + $x.shape.length + ", " + $x.shape.length + ")";
          });
          var inputs = { value: $x };
          var attrs = { axis };
          return ENGINE2.runKernel(Unpack2, inputs, attrs);
        }
        var unstack = op2({ unstack_ });
        function variable(initialValue, trainable, name, dtype) {
          if (trainable === void 0) {
            trainable = true;
          }
          return ENGINE2.makeVariable(initialValue, trainable, name, dtype);
        }
        function whereImpl3(condShape, condVals) {
          var indices = [];
          for (var i = 0; i < condVals.length; i++) {
            if (condVals[i]) {
              indices.push(i);
            }
          }
          var inBuffer = buffer2(condShape, "int32");
          var out = buffer2([indices.length, condShape.length], "int32");
          for (var i = 0; i < indices.length; i++) {
            var loc = inBuffer.indexToLoc(indices[i]);
            var offset = i * condShape.length;
            out.values.set(loc, offset);
          }
          return out.toTensor();
        }
        function whereAsync_(condition) {
          return __awaiter2(this, void 0, void 0, function() {
            var $condition, vals, res;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  $condition = convertToTensor2(condition, "condition", "whereAsync", "bool");
                  return [4, $condition.data()];
                case 1:
                  vals = _a.sent();
                  res = whereImpl3($condition.shape, vals);
                  if (condition !== $condition) {
                    $condition.dispose();
                  }
                  return [2, res];
              }
            });
          });
        }
        var whereAsync = whereAsync_;
        function booleanMaskAsync_(tensor2, mask, axis) {
          return __awaiter2(this, void 0, void 0, function() {
            var $tensor, $mask, axisFrom, maskDim, tensorShape, leadingSize, i, targetTensorShape, reshapedTensor, reshapedMask, positivePositions, indices, res;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  $tensor = convertToTensor2(tensor2, "tensor", "boolMask");
                  $mask = convertToTensor2(mask, "mask", "boolMask", "bool");
                  axisFrom = axis == null ? 0 : axis;
                  maskDim = $mask.rank;
                  tensorShape = $tensor.shape;
                  assert2(maskDim > 0, function() {
                    return "mask cannot be scalar";
                  });
                  assertShapesMatch2(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, "mask's shape must match the first K dimensions of tensor's shape,");
                  leadingSize = 1;
                  for (i = axisFrom; i < axisFrom + maskDim; i++) {
                    leadingSize *= tensorShape[i];
                  }
                  targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
                  reshapedTensor = reshape4($tensor, targetTensorShape);
                  reshapedMask = reshape4($mask, [-1]);
                  return [4, whereAsync(reshapedMask)];
                case 1:
                  positivePositions = _a.sent();
                  indices = squeeze2(positivePositions, [1]);
                  res = gather(reshapedTensor, indices, axisFrom);
                  if (tensor2 !== $tensor) {
                    $tensor.dispose();
                  }
                  if (mask !== $mask) {
                    $mask.dispose();
                  }
                  indices.dispose();
                  reshapedTensor.dispose();
                  reshapedMask.dispose();
                  positivePositions.dispose();
                  return [2, res];
              }
            });
          });
        }
        var booleanMaskAsync = booleanMaskAsync_;
        function norm_(x, ord, axis, keepDims) {
          if (ord === void 0) {
            ord = "euclidean";
          }
          if (axis === void 0) {
            axis = null;
          }
          if (keepDims === void 0) {
            keepDims = false;
          }
          x = convertToTensor2(x, "x", "norm");
          var norm2 = normImpl(x, ord, axis);
          var keepDimsShape = norm2.shape;
          if (keepDims) {
            var axes = parseAxisParam2(axis, x.shape);
            keepDimsShape = expandShapeToKeepDim2(norm2.shape, axes);
          }
          return reshape4(norm2, keepDimsShape);
        }
        function normImpl(x, p, axis) {
          if (axis === void 0) {
            axis = null;
          }
          if (x.rank === 0) {
            return abs2(x);
          }
          if (x.rank !== 1 && axis === null) {
            return normImpl(reshape4(x, [-1]), p, axis);
          }
          if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
            if (p === 1) {
              return sum$1(abs2(x), axis);
            }
            if (p === Infinity) {
              return max2(abs2(x), axis);
            }
            if (p === -Infinity) {
              return min2(abs2(x), axis);
            }
            if (p === "euclidean" || p === 2) {
              return sqrt2(sum$1(pow2(abs2(x), scalar3(2, "int32")), axis));
            }
            throw new Error("Error in norm: invalid ord value: " + p);
          }
          if (Array.isArray(axis) && axis.length === 2) {
            if (p === 1) {
              return max2(sum$1(abs2(x), axis[0]), axis[1] - 1);
            }
            if (p === Infinity) {
              return max2(sum$1(abs2(x), axis[1]), axis[0]);
            }
            if (p === -Infinity) {
              return min2(sum$1(abs2(x), axis[1]), axis[0]);
            }
            if (p === "fro" || p === "euclidean") {
              return sqrt2(sum$1(square2(x), axis));
            }
            throw new Error("Error in norm: invalid ord value: " + p);
          }
          throw new Error("Error in norm: invalid axis: " + axis);
        }
        var norm = op2({ norm_ });
        function movingAverage_(v, x, decay, step4, zeroDebias) {
          if (zeroDebias === void 0) {
            zeroDebias = true;
          }
          var $v = convertToTensor2(v, "v", "movingAverage");
          var $x = convertToTensor2(x, "x", "movingAverage");
          var $decay = convertToTensor2(decay, "decay", "movingAverage");
          assertTypesMatch($v, $x);
          assert2(arraysEqual2($v.shape, $x.shape), function() {
            return "Shape mismatch in v and x";
          });
          var one = scalar3(1);
          var oneMinusDecay = sub4(one, $decay);
          var update = mul3(sub4($x, $v), oneMinusDecay);
          if (zeroDebias) {
            assert2(step4 != null, function() {
              return "When using zeroDebias: true, step is required.";
            });
            var $step = convertToTensor2(step4, "step", "movingAverage");
            update = div2(update, sub4(one, pow2($decay, $step)));
          }
          return add$1($v, update);
        }
        var movingAverage = op2({ movingAverage_ });
        function scatterND_(indices, updates, shape) {
          var $indices = convertToTensor2(indices, "indices", "scatterND", "int32");
          var $updates = convertToTensor2(updates, "updates", "scatterND");
          validateInput2($updates, $indices, shape);
          var inputs = { indices: $indices, updates: $updates };
          var attrs = { shape };
          return ENGINE2.runKernel(ScatterNd2, inputs, attrs);
        }
        var scatterND = op2({ scatterND_ });
        function validateInput$1(sparseIndices, sparseValues, outputShape, defaultValues) {
          if (sparseIndices.dtype !== "int32") {
            throw new Error("tf.sparseToDense() expects the indices to be int32 type," + (" but the dtype was " + sparseIndices.dtype + "."));
          }
          if (sparseIndices.rank > 2) {
            throw new Error("sparseIndices should be a scalar, vector, or matrix," + (" but got shape " + sparseIndices.shape + "."));
          }
          var numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
          var numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
          if (outputShape.length !== numDims) {
            throw new Error("outputShape has incorrect number of elements:," + (" " + outputShape.length + ", should be: " + numDims + "."));
          }
          var numValues = sparseValues.size;
          if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
            throw new Error("sparseValues has incorrect shape " + (sparseValues.shape + ", should be [] or [" + numElems + "]"));
          }
          if (sparseValues.dtype !== defaultValues.dtype) {
            throw new Error("sparseValues.dtype must match defaultValues.dtype");
          }
        }
        function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = 0;
          }
          var $sparseIndices = convertToTensor2(sparseIndices, "sparseIndices", "sparseToDense", "int32");
          var $sparseValues = convertToTensor2(sparseValues, "sparseValues", "sparseToDense");
          var $defaultValue = convertToTensor2(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
          validateInput$1($sparseIndices, $sparseValues, outputShape, $defaultValue);
          var inputs = {
            sparseIndices: $sparseIndices,
            sparseValues: $sparseValues,
            defaultValue: $defaultValue
          };
          var attrs = { outputShape };
          return ENGINE2.runKernel(SparseToDense2, inputs, attrs);
        }
        var sparseToDense2 = op2({ sparseToDense_ });
        function gatherND_(x, indices) {
          var $indices = convertToTensor2(indices, "indices", "gatherND", "int32");
          var $x = convertToTensor2(x, "x", "gatherND");
          var inputs = { params: $x, indices: $indices };
          return ENGINE2.runKernel(GatherNd2, inputs);
        }
        var gatherND = op2({ gatherND_ });
        function getNoiseShape(x, noiseShape) {
          if (noiseShape == null) {
            return x.shape.slice();
          }
          if (arraysEqual2(x.shape, noiseShape)) {
            return noiseShape;
          }
          if (x.shape.length === noiseShape.length) {
            var newDimension = [];
            for (var i = 0; i < x.shape.length; i++) {
              if (noiseShape[i] == null && x.shape[i] != null) {
                newDimension.push(x.shape[i]);
              } else {
                newDimension.push(noiseShape[i]);
              }
            }
            return newDimension;
          }
          return noiseShape;
        }
        function dropout_(x, rate, noiseShape, seed) {
          var $x = convertToTensor2(x, "x", "dropout");
          assert2($x.dtype === "float32", function() {
            return "x has to be a floating point tensor since it's going to be " + ("scaled, but got a " + $x.dtype + " tensor instead.");
          });
          assert2(rate >= 0 && rate < 1, function() {
            return "rate must be a float in the range [0, 1), but got " + rate + ".";
          });
          if (rate === 0) {
            return x instanceof Tensor3 ? $x.clone() : $x;
          }
          var $noiseShape = getNoiseShape($x, noiseShape);
          var keepProb = 1 - rate;
          var multiplier = div2(floor3(add$1(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
          return mul3($x, multiplier);
        }
        var dropout = op2({ dropout_ });
        function enclosingPowerOfTwo(value) {
          return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
        }
        function cosineWindow(windowLength, a, b) {
          var even = 1 - windowLength % 2;
          var newValues = new Float32Array(windowLength);
          for (var i = 0; i < windowLength; ++i) {
            var cosArg = 2 * Math.PI * i / (windowLength + even - 1);
            newValues[i] = a - b * Math.cos(cosArg);
          }
          return tensor1d(newValues, "float32");
        }
        function inTopKAsync_(predictions, targets, k) {
          if (k === void 0) {
            k = 1;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var $predictions, $targets, lastDim, predictionsVals, targetsVals, _a, batch, size, precision, b, offset, vals, valAndInd, i, i;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  $predictions = convertToTensor2(predictions, "predictions", "inTopK");
                  $targets = convertToTensor2(targets, "targets", "inTopK");
                  assert2($predictions.rank > 1, function() {
                    return "inTopK() expects the predictions to be of rank 2 or higher, " + ("but got " + $predictions.rank);
                  });
                  assert2($predictions.rank - 1 === $targets.rank, function() {
                    return "predictions rank should be 1 larger than targets rank, but got predictions rank " + ($predictions.rank + " and targets rank " + $targets.rank);
                  });
                  assertShapesMatch2($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
                  lastDim = $predictions.shape[$predictions.shape.length - 1];
                  assert2(k > 0 && k <= lastDim, function() {
                    return "'k' passed to inTopK() must be > 0 && <= the predictions last " + ("dimension (" + lastDim + "), but got " + k);
                  });
                  return [4, $predictions.data()];
                case 1:
                  predictionsVals = _b.sent();
                  return [4, $targets.data()];
                case 2:
                  targetsVals = _b.sent();
                  _a = [predictionsVals.length / lastDim, lastDim], batch = _a[0], size = _a[1];
                  precision = getTypedArrayFromDType2("bool", batch);
                  for (b = 0; b < batch; b++) {
                    offset = b * size;
                    vals = predictionsVals.subarray(offset, offset + size);
                    valAndInd = [];
                    for (i = 0; i < vals.length; i++) {
                      valAndInd.push({ value: vals[i], index: i });
                    }
                    valAndInd.sort(function(a, b2) {
                      return b2.value - a.value;
                    });
                    precision[b] = 0;
                    for (i = 0; i < k; i++) {
                      if (valAndInd[i].index === targetsVals[b]) {
                        precision[b] = 1;
                        break;
                      }
                    }
                  }
                  if (predictions !== $predictions) {
                    $predictions.dispose();
                  }
                  if (targets !== $targets) {
                    $targets.dispose();
                  }
                  return [2, tensor(precision, $targets.shape, "bool")];
              }
            });
          });
        }
        var inTopKAsync = inTopKAsync_;
        function conv2DBackpropFilter_(x, dy, filterShape, strides, pad2, dataFormat, dimRoundingMode) {
          if (dataFormat === void 0) {
            dataFormat = "NHWC";
          }
          var x4D = x;
          if (x.rank === 3) {
            x4D = reshape4(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
          }
          var dy4D = dy;
          if (dy4D.rank === 3) {
            dy4D = reshape4(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in conv2dDerFilter: input must be rank 4, but got shape " + (x4D.shape + ".");
          });
          assert2(dy4D.rank === 4, function() {
            return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + (dy4D.shape + ".");
          });
          assert2(filterShape.length === 4, function() {
            return "Error in conv2dDerFilter: filterShape must be length 4, but got " + (filterShape + ".");
          });
          var inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
          var outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
          assert2(inDepth === filterShape[2], function() {
            return "Error in conv2dDerFilter: depth of input " + inDepth + ") must " + ("match input depth in filter (" + filterShape[2] + ".");
          });
          assert2(outDepth === filterShape[3], function() {
            return "Error in conv2dDerFilter: depth of dy (" + outDepth + ") must " + ("match output depth for filter (" + filterShape[3] + ").");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in conv2dDerFilter: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var inputs = { x: x4D, dy: dy4D };
          var attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape };
          return ENGINE2.runKernel(Conv2DBackpropFilter2, inputs, attrs);
        }
        var conv2DBackpropFilter2 = op2({ conv2DBackpropFilter_ });
        function getFusedDyActivation2(dy, y, activation) {
          if (activation == null || activation === "linear") {
            return dy;
          }
          if (activation === "relu") {
            return mul3(dy, step3(y));
          }
          throw new Error("Cannot compute gradient for fused activation " + activation + ".");
        }
        function getFusedBiasGradient2(bias, dyActivation) {
          var res = dyActivation;
          var reduceAxes = getReductionAxes2(bias.shape, dyActivation.shape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape4(res, bias.shape);
        }
        function applyActivation2(x, activation, preluActivationWeights, leakyreluAlpha) {
          if (activation === "linear") {
            return x;
          } else if (activation === "relu") {
            return relu3(x);
          } else if (activation === "elu") {
            return elu3(x);
          } else if (activation === "relu6") {
            return relu63(x);
          } else if (activation === "prelu") {
            return prelu3(x, preluActivationWeights);
          } else if (activation === "leakyrelu") {
            return leakyRelu3(x, leakyreluAlpha);
          } else if (activation === "sigmoid") {
            return sigmoid4(x);
          }
          throw new Error("Unknown fused activation " + activation + ".");
        }
        var shouldFuse2 = function(gradientDepth, activation) {
          var gradientMode = gradientDepth > 0;
          return !gradientMode || activation === "linear";
        };
        function fusedConv2d_(_a) {
          var x = _a.x, filter = _a.filter, strides = _a.strides, pad2 = _a.pad, _b = _a.dataFormat, dataFormat = _b === void 0 ? "NHWC" : _b, _c = _a.dilations, dilations = _c === void 0 ? [1, 1] : _c, dimRoundingMode = _a.dimRoundingMode, bias = _a.bias, _d = _a.activation, activation = _d === void 0 ? "linear" : _d, preluActivationWeights = _a.preluActivationWeights, leakyreluAlpha = _a.leakyreluAlpha;
          activation = activation || "linear";
          if (shouldFuse2(ENGINE2.state.gradientDepth, activation) === false) {
            var result2 = conv2d2(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
            if (bias != null) {
              result2 = add$1(result2, bias);
            }
            return applyActivation2(result2, activation, preluActivationWeights, leakyreluAlpha);
          }
          var $x = convertToTensor2(x, "x", "conv2d");
          var $filter = convertToTensor2(filter, "filter", "conv2d");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in fused conv2d: input must be rank 4, but got rank " + (x4D.rank + ".");
          });
          assert2($filter.rank === 4, function() {
            return "Error in fused conv2d: filter must be rank 4, but got rank " + ($filter.rank + ".");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in fused conv2d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          assert2(x4D.shape[3] === $filter.shape[2], function() {
            return "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match " + ("input depth for filter " + $filter.shape[2] + ".");
          });
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in conv2D: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'");
          });
          assert2(dataFormat === "NHWC", function() {
            return "Error in conv2d: got dataFormat of " + dataFormat + " but only NHWC is currently supported.";
          });
          var convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad2, dimRoundingMode);
          var $bias;
          if (bias != null) {
            $bias = convertToTensor2(bias, "bias", "fused conv2d");
            $bias = makeTypesMatch2($bias, $x)[0];
            assertAndGetBroadcastShape2(convInfo.outShape, $bias.shape);
          }
          var $preluActivationWeights;
          if (preluActivationWeights != null) {
            $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused conv2d");
          }
          var grad2 = function(dy, saved) {
            var _a2 = saved, $filter2 = _a2[0], x4D2 = _a2[1], y = _a2[2], $bias2 = _a2[3];
            var dyActivation = getFusedDyActivation2(dy, y, activation);
            assert2(tupleValuesAreOne2(dilations), function() {
              return "Error in gradient of fused conv2D: dilation rates greater than 1 " + ("are not yet supported in gradients. Got dilations '" + dilations + "'");
            });
            var xDer = conv2DBackpropInput2(x4D2.shape, dyActivation, $filter2, strides, pad2);
            var filterDer = conv2DBackpropFilter2(x4D2, dyActivation, $filter2.shape, strides, pad2);
            var der = [xDer, filterDer];
            if ($bias2 != null) {
              var biasDer = getFusedBiasGradient2($bias2, dyActivation);
              der.push(biasDer);
            }
            return der;
          };
          var inputs = {
            x: x4D,
            filter: $filter,
            bias: $bias,
            preluActivationWeights: $preluActivationWeights
          };
          var attrs = {
            strides,
            pad: pad2,
            dataFormat,
            dilations,
            dimRoundingMode,
            activation,
            leakyreluAlpha
          };
          if (bias == null) {
            var customOp = customGrad(function(x4D2, filter2, save2) {
              var res = ENGINE2.runKernel(FusedConv2D2, inputs, attrs);
              save2([filter2, x4D2, res]);
              if (reshapedTo4D) {
                res = reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
              }
              return { value: res, gradFunc: grad2 };
            });
            return customOp(x4D, $filter);
          } else {
            var customOpWithBias = customGrad(function(x4D2, filter2, bias2, save2) {
              var res = ENGINE2.runKernel(FusedConv2D2, inputs, attrs);
              save2([filter2, x4D2, res, bias2]);
              if (reshapedTo4D) {
                res = reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
              }
              return { value: res, gradFunc: grad2 };
            });
            return customOpWithBias(x4D, $filter, $bias);
          }
        }
        var conv2d$1 = op2({ fusedConv2d_ });
        function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad2, dilations, dimRoundingMode) {
          if (dilations === void 0) {
            dilations = [1, 1];
          }
          var x4D = x;
          if (x.rank === 3) {
            x4D = reshape4(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
          }
          var dy4D = dy;
          if (dy4D.rank === 3) {
            dy4D = reshape4(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
          }
          var inputs = { x: x4D, dy: dy4D };
          var attrs = { strides, pad: pad2, dimRoundingMode, dilations, filterShape };
          return ENGINE2.runKernel(DepthwiseConv2dNativeBackpropFilter2, inputs, attrs);
        }
        var depthwiseConv2dNativeBackpropFilter2 = op2({ depthwiseConv2dNativeBackpropFilter_ });
        function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad2, dilations, dimRoundingMode) {
          if (dilations === void 0) {
            dilations = [1, 1];
          }
          var dy4D = dy;
          var reshapedTo4D = false;
          if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = reshape4(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
          }
          var inputs = { dy: dy4D, filter };
          var attrs = { strides, pad: pad2, dimRoundingMode, dilations, inputShape: xShape };
          var res = ENGINE2.runKernel(DepthwiseConv2dNativeBackpropInput2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var depthwiseConv2dNativeBackpropInput2 = op2({ depthwiseConv2dNativeBackpropInput_ });
        function fusedDepthwiseConv2d_(_a) {
          var x = _a.x, filter = _a.filter, strides = _a.strides, pad2 = _a.pad, _b = _a.dataFormat, dataFormat = _b === void 0 ? "NHWC" : _b, _c = _a.dilations, dilations = _c === void 0 ? [1, 1] : _c, dimRoundingMode = _a.dimRoundingMode, bias = _a.bias, _d = _a.activation, activation = _d === void 0 ? "linear" : _d, preluActivationWeights = _a.preluActivationWeights, leakyreluAlpha = _a.leakyreluAlpha;
          if (shouldFuse2(ENGINE2.state.gradientDepth, activation) === false) {
            var result2 = depthwiseConv2d(x, filter, strides, pad2, dataFormat, dilations, dimRoundingMode);
            if (bias != null) {
              result2 = add$1(result2, bias);
            }
            return applyActivation2(result2, activation, preluActivationWeights, leakyreluAlpha);
          }
          var $x = convertToTensor2(x, "x", "depthwiseConv2d");
          var $filter = convertToTensor2(filter, "filter", "depthwiseConv2d");
          var x4D = $x;
          var reshapedTo4D = false;
          if ($x.rank === 3) {
            reshapedTo4D = true;
            x4D = reshape4($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
          }
          assert2(x4D.rank === 4, function() {
            return "Error in fused depthwiseConv2d: input must be rank 4, but got " + ("rank " + x4D.rank + ".");
          });
          assert2($filter.rank === 4, function() {
            return "Error in fused depthwiseConv2d: filter must be rank 4, " + ("but got rank " + $filter.rank + ".");
          });
          assert2(x4D.shape[3] === $filter.shape[2], function() {
            return "Error in fused depthwiseConv2d: number of input channels " + ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") + ("filter " + $filter.shape[2] + ".");
          });
          if (dilations == null) {
            dilations = [1, 1];
          }
          assert2(eitherStridesOrDilationsAreOne2(strides, dilations), function() {
            return "Error in fused depthwiseConv2d: Either strides or dilations must " + ("be 1. Got strides " + strides + " and dilations '" + dilations + "'");
          });
          if (dimRoundingMode != null) {
            assert2(isInt2(pad2), function() {
              return "Error in fused depthwiseConv2d: pad must be an integer when " + ("using dimRoundingMode " + dimRoundingMode + " but got pad " + pad2 + ".");
            });
          }
          var convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad2, dimRoundingMode, true);
          var $bias;
          if (bias != null) {
            $bias = convertToTensor2(bias, "bias", "fused conv2d");
            $bias = makeTypesMatch2($bias, $x)[0];
            assertAndGetBroadcastShape2(convInfo.outShape, $bias.shape);
          }
          var $preluActivationWeights;
          if (preluActivationWeights != null) {
            $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
          }
          var grad2 = function(dy, saved) {
            assert2(tupleValuesAreOne2(dilations), function() {
              return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations " + ("'" + dilations + "'");
            });
            var $filter2 = saved[0], x4D2 = saved[1], y = saved[2], bias2 = saved[3];
            var dyActivation = getFusedDyActivation2(dy, y, activation);
            var xDer = depthwiseConv2dNativeBackpropInput2(x4D2.shape, dyActivation, $filter2, strides, pad2, dilations, dimRoundingMode);
            var filterDer = depthwiseConv2dNativeBackpropFilter2(x4D2, dyActivation, $filter2.shape, strides, pad2, dilations, dimRoundingMode);
            if (bias2 != null) {
              var biasDer = getFusedBiasGradient2($bias, dyActivation);
              return [xDer, filterDer, biasDer];
            }
            return [xDer, filterDer];
          };
          var inputs = {
            x: x4D,
            filter: $filter,
            bias: $bias,
            preluActivationWeights: $preluActivationWeights
          };
          var attrs = {
            strides,
            pad: pad2,
            dataFormat,
            dilations,
            dimRoundingMode,
            activation,
            leakyreluAlpha
          };
          if (bias == null) {
            var customOp = customGrad(function(x4D2, filter2, save2) {
              var res = ENGINE2.runKernel(FusedDepthwiseConv2D2, inputs, attrs);
              save2([filter2, x4D2, res]);
              if (reshapedTo4D) {
                res = reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
              }
              return { value: res, gradFunc: grad2 };
            });
            return customOp(x4D, $filter);
          } else {
            var customOpWithBias = customGrad(function(x4D2, filter2, bias2, save2) {
              var res = ENGINE2.runKernel(FusedDepthwiseConv2D2, inputs, attrs);
              save2([filter2, x4D2, res, bias2]);
              if (reshapedTo4D) {
                res = reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
              }
              return { value: res, gradFunc: grad2 };
            });
            return customOpWithBias(x4D, $filter, $bias);
          }
        }
        var depthwiseConv2d$1 = op2({ fusedDepthwiseConv2d_ });
        function fusedMatMul_(_a) {
          var _b;
          var a = _a.a, b = _a.b, _c = _a.transposeA, transposeA = _c === void 0 ? false : _c, _d = _a.transposeB, transposeB = _d === void 0 ? false : _d, bias = _a.bias, _e = _a.activation, activation = _e === void 0 ? "linear" : _e, preluActivationWeights = _a.preluActivationWeights, leakyreluAlpha = _a.leakyreluAlpha;
          if (shouldFuse2(ENGINE2.state.gradientDepth, activation) === false) {
            var result2 = matMul(a, b, transposeA, transposeB);
            if (bias != null) {
              result2 = add$1(result2, bias);
            }
            return applyActivation2(result2, activation, preluActivationWeights, leakyreluAlpha);
          }
          var $a = convertToTensor2(a, "a", "fused matMul");
          var $b = convertToTensor2(b, "b", "fused matMul");
          _b = makeTypesMatch2($a, $b), $a = _b[0], $b = _b[1];
          var innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
          var innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
          var outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
          var outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
          var outerDimsA = $a.shape.slice(0, -2);
          var outerDimsB = $b.shape.slice(0, -2);
          var batchDimA = sizeFromShape2(outerDimsA);
          var batchDimB = sizeFromShape2(outerDimsB);
          assert2($a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank, function() {
            return "Error in fused matMul: inputs must have the same rank of at " + ("least 2, got ranks " + $a.rank + " and " + $b.rank + ".");
          });
          assert2(arraysEqual2(outerDimsA, outerDimsB), function() {
            return "Error in fused matMul: outer dimensions (" + outerDimsA + ") and (" + (outerDimsB + ") of Tensors with shapes " + $a.shape + " and ") + ($b.shape + " must match.");
          });
          assert2(innerShapeA === innerShapeB, function() {
            return "Error in fused matMul: inner shapes (" + innerShapeA + ") and (" + (innerShapeB + ") of Tensors with shapes " + $a.shape + " and ") + ($b.shape + " and transposeA=" + transposeA) + (" and transposeB=" + transposeB + " must match.");
          });
          var outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);
          var a3D = transposeA ? reshape4($a, [batchDimA, innerShapeA, outerShapeA]) : reshape4($a, [batchDimA, outerShapeA, innerShapeA]);
          var b3D = transposeB ? reshape4($b, [batchDimB, outerShapeB, innerShapeB]) : reshape4($b, [batchDimB, innerShapeB, outerShapeB]);
          var $bias;
          if (bias != null) {
            $bias = convertToTensor2(bias, "bias", "fused matMul");
            $bias = makeTypesMatch2($bias, $a)[0];
            assertAndGetBroadcastShape2(outShape, $bias.shape);
          }
          var $preluActivationWeights;
          if (preluActivationWeights != null) {
            $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused matMul");
          }
          var grad2 = function(dy, saved) {
            var a3D2 = saved[0], b3D2 = saved[1], y = saved[2], $bias2 = saved[3];
            var dyActivation = getFusedDyActivation2(reshape4(dy, y.shape), y, activation);
            var aDer;
            var bDer;
            if (!transposeA && !transposeB) {
              aDer = matMul(dyActivation, b3D2, false, true);
              bDer = matMul(a3D2, dyActivation, true, false);
            } else if (!transposeA && transposeB) {
              aDer = matMul(dyActivation, b3D2, false, false);
              bDer = matMul(dyActivation, a3D2, true, false);
            } else if (transposeA && !transposeB) {
              aDer = matMul(b3D2, dyActivation, false, true);
              bDer = matMul(a3D2, dyActivation, false, false);
            } else {
              aDer = matMul(b3D2, dyActivation, true, true);
              bDer = matMul(dyActivation, a3D2, true, true);
            }
            if (bias != null) {
              var biasDer = getFusedBiasGradient2($bias2, dyActivation);
              return [aDer, bDer, biasDer];
            } else {
              return [aDer, bDer];
            }
          };
          var inputs = {
            a: a3D,
            b: b3D,
            bias: $bias,
            preluActivationWeights: $preluActivationWeights
          };
          var attrs = { transposeA, transposeB, activation, leakyreluAlpha };
          if (bias == null) {
            var customOp = customGrad(function(a3D2, b3D2, save2) {
              var res = ENGINE2.runKernel(_FusedMatMul2, inputs, attrs);
              save2([a3D2, b3D2, res]);
              return { value: reshape4(res, outShape), gradFunc: grad2 };
            });
            return customOp(a3D, b3D);
          } else {
            var customOpWithBias = customGrad(function(a3D2, b3D2, $bias2, save2) {
              var res = ENGINE2.runKernel(_FusedMatMul2, inputs, attrs);
              save2([a3D2, b3D2, res, $bias2]);
              return { value: reshape4(res, outShape), gradFunc: grad2 };
            });
            return customOpWithBias(a3D, b3D, $bias);
          }
        }
        var matMul$1 = op2({ fusedMatMul_ });
        var fused_ops = {
          __proto__: null,
          conv2d: conv2d$1,
          depthwiseConv2d: depthwiseConv2d$1,
          matMul: matMul$1
        };
        function hammingWindow_(windowLength) {
          return cosineWindow(windowLength, 0.54, 0.46);
        }
        var hammingWindow = op2({ hammingWindow_ });
        function hannWindow_(windowLength) {
          return cosineWindow(windowLength, 0.5, 0.5);
        }
        var hannWindow = op2({ hannWindow_ });
        function frame_(signal2, frameLength, frameStep, padEnd, padValue) {
          if (padEnd === void 0) {
            padEnd = false;
          }
          if (padValue === void 0) {
            padValue = 0;
          }
          var start = 0;
          var output = [];
          while (start + frameLength <= signal2.size) {
            output.push(slice2(signal2, start, frameLength));
            start += frameStep;
          }
          if (padEnd) {
            while (start < signal2.size) {
              var padLen = start + frameLength - signal2.size;
              var pad2 = concat3([
                slice2(signal2, start, frameLength - padLen),
                fill2([padLen], padValue)
              ]);
              output.push(pad2);
              start += frameStep;
            }
          }
          if (output.length === 0) {
            return tensor2d2([], [0, frameLength]);
          }
          return reshape4(concat3(output), [output.length, frameLength]);
        }
        var frame = op2({ frame_ });
        function stft_(signal2, frameLength, frameStep, fftLength, windowFn) {
          if (windowFn === void 0) {
            windowFn = hannWindow;
          }
          if (fftLength == null) {
            fftLength = enclosingPowerOfTwo(frameLength);
          }
          var framedSignal = frame(signal2, frameLength, frameStep);
          var windowedSignal = mul3(framedSignal, windowFn(frameLength));
          return rfft(windowedSignal, fftLength);
        }
        var stft = op2({ stft_ });
        function cropAndResize_(image3, boxes, boxInd, cropSize, method, extrapolationValue) {
          if (method === void 0) {
            method = "bilinear";
          }
          if (extrapolationValue === void 0) {
            extrapolationValue = 0;
          }
          var $image = convertToTensor2(image3, "image", "cropAndResize");
          var $boxes = convertToTensor2(boxes, "boxes", "cropAndResize", "float32");
          var $boxInd = convertToTensor2(boxInd, "boxInd", "cropAndResize", "int32");
          var numBoxes = $boxes.shape[0];
          assert2($image.rank === 4, function() {
            return "Error in cropAndResize: image must be rank 4," + ("but got rank " + $image.rank + ".");
          });
          assert2($boxes.rank === 2 && $boxes.shape[1] === 4, function() {
            return "Error in cropAndResize: boxes must be have size [" + numBoxes + ",4] " + ("but had shape " + $boxes.shape + ".");
          });
          assert2($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, function() {
            return "Error in cropAndResize: boxInd must be have size [" + numBoxes + "] " + ("but had shape " + $boxes.shape + ".");
          });
          assert2(cropSize.length === 2, function() {
            return "Error in cropAndResize: cropSize must be of length 2, but got " + ("length " + cropSize.length + ".");
          });
          assert2(cropSize[0] >= 1 && cropSize[1] >= 1, function() {
            return "cropSize must be atleast [1,1], but was " + cropSize;
          });
          assert2(method === "bilinear" || method === "nearest", function() {
            return "method must be bilinear or nearest, but was " + method;
          });
          var inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
          var attrs = { method, extrapolationValue, cropSize };
          var res = ENGINE2.runKernel(CropAndResize2, inputs, attrs);
          return res;
        }
        var cropAndResize2 = op2({ cropAndResize_ });
        function flipLeftRight_(image3) {
          var $image = convertToTensor2(image3, "image", "flipLeftRight", "float32");
          assert2($image.rank === 4, function() {
            return "Error in flipLeftRight: image must be rank 4," + ("but got rank " + $image.rank + ".");
          });
          var inputs = { image: $image };
          var res = ENGINE2.runKernel(FlipLeftRight2, inputs, {});
          return res;
        }
        var flipLeftRight = op2({ flipLeftRight_ });
        function rotateWithOffset_(image3, radians, fillValue, center) {
          if (fillValue === void 0) {
            fillValue = 0;
          }
          if (center === void 0) {
            center = 0.5;
          }
          var $image = convertToTensor2(image3, "image", "rotateWithOffset", "float32");
          assert2($image.rank === 4, function() {
            return "Error in rotateWithOffset: image must be rank 4," + ("but got rank " + $image.rank + ".");
          });
          var inputs = { image: $image };
          var attrs = { radians, fillValue, center };
          var res = ENGINE2.runKernel(RotateWithOffset2, inputs, attrs);
          return res;
        }
        var rotateWithOffset = op2({ rotateWithOffset_ });
        function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
          if (iouThreshold == null) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold == null) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          if (softNmsSigma == null) {
            softNmsSigma = 0;
          }
          var numBoxes = boxes.shape[0];
          maxOutputSize = Math.min(maxOutputSize, numBoxes);
          assert2(0 <= iouThreshold && iouThreshold <= 1, function() {
            return "iouThreshold must be in [0, 1], but was '" + iouThreshold + "'";
          });
          assert2(boxes.rank === 2, function() {
            return "boxes must be a 2D tensor, but was of rank '" + boxes.rank + "'";
          });
          assert2(boxes.shape[1] === 4, function() {
            return "boxes must have 4 columns, but 2nd dimension was " + boxes.shape[1];
          });
          assert2(scores.rank === 1, function() {
            return "scores must be a 1D tensor";
          });
          assert2(scores.shape[0] === numBoxes, function() {
            return "scores has incompatible shape with boxes. Expected " + numBoxes + ", " + ("but was " + scores.shape[0]);
          });
          assert2(0 <= softNmsSigma && softNmsSigma <= 1, function() {
            return "softNmsSigma must be in [0, 1], but was '" + softNmsSigma + "'";
          });
          return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
        }
        function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          var $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
          var $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
          var inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
          maxOutputSize = inputs.maxOutputSize;
          iouThreshold = inputs.iouThreshold;
          scoreThreshold = inputs.scoreThreshold;
          var attrs = { maxOutputSize, iouThreshold, scoreThreshold };
          return ENGINE2.runKernel(NonMaxSuppressionV32, { boxes: $boxes, scores: $scores }, attrs);
        }
        var nonMaxSuppression = op2({ nonMaxSuppression_ });
        function binaryInsert2(arr, element, comparator) {
          var index2 = binarySearch2(arr, element, comparator);
          var insertionPoint = index2 < 0 ? -(index2 + 1) : index2;
          arr.splice(insertionPoint, 0, element);
        }
        function binarySearch2(arr, target, comparator) {
          return binarySearch_2(arr, target, comparator || defaultComparator2);
        }
        function defaultComparator2(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function binarySearch_2(arr, target, comparator) {
          var left = 0;
          var right = arr.length;
          var middle = 0;
          var found = false;
          while (left < right) {
            middle = left + (right - left >>> 1);
            var compareResult = comparator(target, arr[middle]);
            if (compareResult > 0) {
              left = middle + 1;
            } else {
              right = middle;
              found = !compareResult;
            }
          }
          return found ? left : -left - 1;
        }
        function nonMaxSuppressionV3Impl3(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
          return nonMaxSuppressionImpl_2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);
        }
        function nonMaxSuppressionV4Impl3(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
          return nonMaxSuppressionImpl_2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
        }
        function nonMaxSuppressionV5Impl3(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
          return nonMaxSuppressionImpl_2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
        }
        function nonMaxSuppressionImpl_2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor, padToMaxOutputSize, returnValidOutputs) {
          if (returnScoresTensor === void 0) {
            returnScoresTensor = false;
          }
          if (padToMaxOutputSize === void 0) {
            padToMaxOutputSize = false;
          }
          if (returnValidOutputs === void 0) {
            returnValidOutputs = false;
          }
          var candidates = [];
          for (var i = 0; i < scores.length; i++) {
            if (scores[i] > scoreThreshold) {
              candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
            }
          }
          candidates.sort(ascendingComparator2);
          var scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
          var selectedIndices = [];
          var selectedScores = [];
          while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
            var candidate = candidates.pop();
            var originalScore = candidate.score, boxIndex = candidate.boxIndex, suppressBeginIndex = candidate.suppressBeginIndex;
            if (originalScore < scoreThreshold) {
              break;
            }
            var ignoreCandidate = false;
            for (var j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {
              var iou = intersectionOverUnion2(boxes, boxIndex, selectedIndices[j]);
              if (iou >= iouThreshold) {
                ignoreCandidate = true;
                break;
              }
              candidate.score = candidate.score * suppressWeight2(iouThreshold, scale, iou);
              if (candidate.score <= scoreThreshold) {
                break;
              }
            }
            candidate.suppressBeginIndex = selectedIndices.length;
            if (!ignoreCandidate) {
              if (candidate.score === originalScore) {
                selectedIndices.push(boxIndex);
                selectedScores.push(candidate.score);
              } else if (candidate.score > scoreThreshold) {
                binaryInsert2(candidates, candidate, ascendingComparator2);
              }
            }
          }
          var validOutputs = selectedIndices.length;
          var elemsToPad = maxOutputSize - validOutputs;
          if (padToMaxOutputSize && elemsToPad > 0) {
            selectedIndices.push.apply(selectedIndices, new Array(elemsToPad).fill(0));
            selectedScores.push.apply(selectedScores, new Array(elemsToPad).fill(0));
          }
          var result2 = { selectedIndices };
          if (returnScoresTensor) {
            result2["selectedScores"] = selectedScores;
          }
          if (returnValidOutputs) {
            result2["validOutputs"] = validOutputs;
          }
          return result2;
        }
        function intersectionOverUnion2(boxes, i, j) {
          var iCoord = boxes.subarray(i * 4, i * 4 + 4);
          var jCoord = boxes.subarray(j * 4, j * 4 + 4);
          var yminI = Math.min(iCoord[0], iCoord[2]);
          var xminI = Math.min(iCoord[1], iCoord[3]);
          var ymaxI = Math.max(iCoord[0], iCoord[2]);
          var xmaxI = Math.max(iCoord[1], iCoord[3]);
          var yminJ = Math.min(jCoord[0], jCoord[2]);
          var xminJ = Math.min(jCoord[1], jCoord[3]);
          var ymaxJ = Math.max(jCoord[0], jCoord[2]);
          var xmaxJ = Math.max(jCoord[1], jCoord[3]);
          var areaI = (ymaxI - yminI) * (xmaxI - xminI);
          var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
          if (areaI <= 0 || areaJ <= 0) {
            return 0;
          }
          var intersectionYmin = Math.max(yminI, yminJ);
          var intersectionXmin = Math.max(xminI, xminJ);
          var intersectionYmax = Math.min(ymaxI, ymaxJ);
          var intersectionXmax = Math.min(xmaxI, xmaxJ);
          var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
          return intersectionArea / (areaI + areaJ - intersectionArea);
        }
        function suppressWeight2(iouThreshold, scale, iou) {
          var weight = Math.exp(scale * iou * iou);
          return iou <= iouThreshold ? weight : 0;
        }
        function ascendingComparator2(c1, c2) {
          return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
        }
        function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var $boxes, $scores, inputs, boxesAndScores, boxesVals, scoresVals, selectedIndices;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
                  $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
                  inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
                  maxOutputSize = inputs.maxOutputSize;
                  iouThreshold = inputs.iouThreshold;
                  scoreThreshold = inputs.scoreThreshold;
                  return [4, Promise.all([$boxes.data(), $scores.data()])];
                case 1:
                  boxesAndScores = _a.sent();
                  boxesVals = boxesAndScores[0];
                  scoresVals = boxesAndScores[1];
                  selectedIndices = nonMaxSuppressionV3Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold).selectedIndices;
                  if ($boxes !== boxes) {
                    $boxes.dispose();
                  }
                  if ($scores !== scores) {
                    $scores.dispose();
                  }
                  return [2, tensor1d(selectedIndices, "int32")];
              }
            });
          });
        }
        var nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
        function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          if (softNmsSigma === void 0) {
            softNmsSigma = 0;
          }
          var $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
          var $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
          var params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
          maxOutputSize = params.maxOutputSize;
          iouThreshold = params.iouThreshold;
          scoreThreshold = params.scoreThreshold;
          softNmsSigma = params.softNmsSigma;
          var inputs = { boxes: $boxes, scores: $scores };
          var attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
          var result2 = ENGINE2.runKernel(NonMaxSuppressionV52, inputs, attrs);
          return { selectedIndices: result2[0], selectedScores: result2[1] };
        }
        var nonMaxSuppressionWithScore = op2({ nonMaxSuppressionWithScore_ });
        function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          if (softNmsSigma === void 0) {
            softNmsSigma = 0;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var $boxes, $scores, params, boxesAndScores, boxesVals, scoresVals, _a, selectedIndices, selectedScores;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
                  $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
                  params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
                  maxOutputSize = params.maxOutputSize;
                  iouThreshold = params.iouThreshold;
                  scoreThreshold = params.scoreThreshold;
                  softNmsSigma = params.softNmsSigma;
                  return [4, Promise.all([$boxes.data(), $scores.data()])];
                case 1:
                  boxesAndScores = _b.sent();
                  boxesVals = boxesAndScores[0];
                  scoresVals = boxesAndScores[1];
                  _a = nonMaxSuppressionV5Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma), selectedIndices = _a.selectedIndices, selectedScores = _a.selectedScores;
                  if ($boxes !== boxes) {
                    $boxes.dispose();
                  }
                  if ($scores !== scores) {
                    $scores.dispose();
                  }
                  return [2, {
                    selectedIndices: tensor1d(selectedIndices, "int32"),
                    selectedScores: tensor1d(selectedScores)
                  }];
              }
            });
          });
        }
        var nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
        function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          if (padToMaxOutputSize === void 0) {
            padToMaxOutputSize = false;
          }
          var $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
          var $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
          var params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
          var $maxOutputSize = params.maxOutputSize;
          var $iouThreshold = params.iouThreshold;
          var $scoreThreshold = params.scoreThreshold;
          var inputs = { boxes: $boxes, scores: $scores };
          var attrs = {
            maxOutputSize: $maxOutputSize,
            iouThreshold: $iouThreshold,
            scoreThreshold: $scoreThreshold,
            padToMaxOutputSize
          };
          var result2 = ENGINE2.runKernel(NonMaxSuppressionV42, inputs, attrs);
          return { selectedIndices: result2[0], validOutputs: result2[1] };
        }
        var nonMaxSuppressionPadded = op2({ nonMaxSuppressionPadded_ });
        function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
          if (iouThreshold === void 0) {
            iouThreshold = 0.5;
          }
          if (scoreThreshold === void 0) {
            scoreThreshold = Number.NEGATIVE_INFINITY;
          }
          if (padToMaxOutputSize === void 0) {
            padToMaxOutputSize = false;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var $boxes, $scores, params, $maxOutputSize, $iouThreshold, $scoreThreshold, _a, boxesVals, scoresVals, _b, selectedIndices, validOutputs;
            return __generator2(this, function(_c) {
              switch (_c.label) {
                case 0:
                  $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
                  $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
                  params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
                  $maxOutputSize = params.maxOutputSize;
                  $iouThreshold = params.iouThreshold;
                  $scoreThreshold = params.scoreThreshold;
                  return [4, Promise.all([$boxes.data(), $scores.data()])];
                case 1:
                  _a = _c.sent(), boxesVals = _a[0], scoresVals = _a[1];
                  _b = nonMaxSuppressionV4Impl3(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize), selectedIndices = _b.selectedIndices, validOutputs = _b.validOutputs;
                  if ($boxes !== boxes) {
                    $boxes.dispose();
                  }
                  if ($scores !== scores) {
                    $scores.dispose();
                  }
                  return [2, {
                    selectedIndices: tensor1d(selectedIndices, "int32"),
                    validOutputs: scalar3(validOutputs, "int32")
                  }];
              }
            });
          });
        }
        var nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
        function resizeBilinear_(images, size, alignCorners, halfPixelCenters) {
          if (alignCorners === void 0) {
            alignCorners = false;
          }
          if (halfPixelCenters === void 0) {
            halfPixelCenters = false;
          }
          var $images = convertToTensor2(images, "images", "resizeBilinear");
          assert2($images.rank === 3 || $images.rank === 4, function() {
            return "Error in resizeBilinear: x must be rank 3 or 4, but got " + ("rank " + $images.rank + ".");
          });
          assert2(size.length === 2, function() {
            return "Error in resizeBilinear: new shape must 2D, but got shape " + (size + ".");
          });
          assert2(halfPixelCenters === false || alignCorners === false, function() {
            return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.";
          });
          var batchImages = $images;
          var reshapedTo4D = false;
          if ($images.rank === 3) {
            reshapedTo4D = true;
            batchImages = reshape4($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
          }
          var inputs = { images: batchImages };
          var attrs = { alignCorners, halfPixelCenters, size };
          var res = ENGINE2.runKernel(ResizeBilinear2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var resizeBilinear2 = op2({ resizeBilinear_ });
        function resizeNearestNeighbor_(images, size, alignCorners, halfPixelCenters) {
          if (alignCorners === void 0) {
            alignCorners = false;
          }
          if (halfPixelCenters === void 0) {
            halfPixelCenters = false;
          }
          var $images = convertToTensor2(images, "images", "resizeNearestNeighbor");
          assert2($images.rank === 3 || $images.rank === 4, function() {
            return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " + ("rank " + $images.rank + ".");
          });
          assert2(size.length === 2, function() {
            return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + (size + ".");
          });
          assert2($images.dtype === "float32" || $images.dtype === "int32", function() {
            return "`images` must have `int32` or `float32` as dtype";
          });
          assert2(halfPixelCenters === false || alignCorners === false, function() {
            return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.";
          });
          var batchImages = $images;
          var reshapedTo4D = false;
          if ($images.rank === 3) {
            reshapedTo4D = true;
            batchImages = reshape4($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
          }
          var inputs = { images: batchImages };
          var attrs = { alignCorners, halfPixelCenters, size };
          var res = ENGINE2.runKernel(ResizeNearestNeighbor2, inputs, attrs);
          if (reshapedTo4D) {
            return reshape4(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return res;
        }
        var resizeNearestNeighbor2 = op2({ resizeNearestNeighbor_ });
        function threshold_(image3, method, inverted, threshValue) {
          var _a;
          if (method === void 0) {
            method = "binary";
          }
          if (inverted === void 0) {
            inverted = false;
          }
          if (threshValue === void 0) {
            threshValue = 0.5;
          }
          var $image = convertToTensor2(image3, "image", "threshold");
          var RED_INTENCITY_COEF = 0.2989;
          var GREEN_INTENCITY_COEF = 0.587;
          var BLUE_INTENCITY_COEF = 0.114;
          var totalPixelsInImage = $image.shape[0] * $image.shape[1];
          var $threshold = mul3(tensor1d([threshValue]), 255);
          var r, g, b, grayscale;
          assert2($image.rank === 3, function() {
            return "Error in threshold: image must be rank 3," + ("but got rank " + $image.rank + ".");
          });
          assert2($image.shape[2] === 3 || $image.shape[2] === 1, function() {
            return "Error in threshold: image color channel must be equal to 3 or 1" + ("but got " + $image.shape[2] + ".");
          });
          assert2($image.dtype === "int32" || $image.dtype === "float32", function() {
            return "Error in dtype: image dtype must be int32 or float32," + ("but got dtype " + $image.dtype + ".");
          });
          assert2(method === "otsu" || method === "binary", function() {
            return "Method must be binary or otsu, but was " + method;
          });
          if ($image.shape[2] === 3) {
            _a = split2($image, [1, 1, 1], -1), r = _a[0], g = _a[1], b = _a[2];
            var $r = mul3(r, RED_INTENCITY_COEF);
            var $g = mul3(g, GREEN_INTENCITY_COEF);
            var $b = mul3(b, BLUE_INTENCITY_COEF);
            grayscale = add$1(add$1($r, $g), $b);
          } else {
            grayscale = image3;
          }
          if (method === "otsu") {
            var $histogram = bincount2(cast5(round$1(grayscale), "int32"), tensor([]), 256);
            $threshold = otsu($histogram, totalPixelsInImage);
          }
          var invCondition = inverted ? lessEqual3(grayscale, $threshold) : greater3(grayscale, $threshold);
          var result2 = cast5(mul3(invCondition, 255), "int32");
          return result2;
        }
        function otsu(histogram, total) {
          var bestThresh = tensor1d([-1]);
          var bestInBetVar = tensor1d([0]);
          var cInBetVar = tensor1d([0]);
          var classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
          for (var index2 = 0; index2 < histogram.size - 1; index2++) {
            classFirst = slice2(histogram, 0, index2 + 1);
            classSecond = slice2(histogram, index2 + 1);
            weightForeground = div2(sum$1(classFirst), total);
            weightBack = div2(sum$1(classSecond), total);
            var meanFirstDivA = sum$1(mul3(classFirst, range2(0, classFirst.size)));
            meanFirst = div2(meanFirstDivA, sum$1(classFirst));
            var meanSecFill = fill2(classSecond.shape, classFirst.size);
            var meanSecAdd = add$1(range2(0, classSecond.size), meanSecFill);
            var meanSecMul = mul3(classSecond, meanSecAdd);
            meanSec = div2(sum$1(meanSecMul), sum$1(classSecond));
            var cInBetVarSubA = sub4(meanFirst, meanSec);
            var cInBetVarSubB = sub4(meanFirst, meanSec);
            var cInBetVarMul = mul3(weightForeground, weightBack);
            cInBetVar = mul3(mul3(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
            var condition = greater3(cInBetVar, bestInBetVar);
            bestInBetVar = where(condition, cInBetVar, bestInBetVar);
            bestThresh = where(condition, tensor1d([index2]), bestThresh);
          }
          return bestThresh;
        }
        var threshold = op2({ threshold_ });
        function transform_(image3, transforms, interpolation, fillMode, fillValue, outputShape) {
          if (interpolation === void 0) {
            interpolation = "nearest";
          }
          if (fillMode === void 0) {
            fillMode = "constant";
          }
          if (fillValue === void 0) {
            fillValue = 0;
          }
          var $image = convertToTensor2(image3, "image", "transform", "float32");
          var $transforms = convertToTensor2(transforms, "transforms", "transform", "float32");
          assert2($image.rank === 4, function() {
            return "Error in transform: image must be rank 4," + ("but got rank " + $image.rank + ".");
          });
          assert2($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, function() {
            return "Error in transform: Input transform should be batch x 8 or 1 x 8";
          });
          assert2(outputShape == null || outputShape.length === 2, function() {
            return "Error in transform: outputShape must be [height, width] or null, " + ("but got " + outputShape + ".");
          });
          var inputs = { image: $image, transforms: $transforms };
          var attrs = { interpolation, fillMode, fillValue, outputShape };
          return ENGINE2.runKernel(Transform2, inputs, attrs);
        }
        var transform2 = op2({ transform_ });
        function bandPart_(a, numLower, numUpper) {
          assert2(numLower % 1 === 0, function() {
            return "bandPart(): numLower must be an integer, got " + numLower + ".";
          });
          assert2(numUpper % 1 === 0, function() {
            return "bandPart(): numUpper must be an integer, got " + numUpper + ".";
          });
          var $a = convertToTensor2(a, "a", "bandPart");
          assert2($a.rank >= 2, function() {
            return "bandPart(): Rank must be at least 2, got " + $a.rank + ".";
          });
          var shape = $a.shape;
          var _a = $a.shape.slice(-2), M = _a[0], N = _a[1];
          if (!(numLower <= M)) {
            throw new Error("bandPart(): numLower (" + numLower + ")" + (" must not be greater than the number of rows (" + M + ")."));
          }
          if (!(numUpper <= N)) {
            throw new Error("bandPart(): numUpper (" + numUpper + ")" + (" must not be greater than the number of columns (" + N + ")."));
          }
          if (numLower < 0) {
            numLower = M;
          }
          if (numUpper < 0) {
            numUpper = N;
          }
          var i = reshape4(range2(0, M, 1, "int32"), [-1, 1]);
          var j = range2(0, N, 1, "int32");
          var ij = sub4(i, j);
          var inBand = logicalAnd2(lessEqual3(ij, scalar3(+numLower, "int32")), greaterEqual3(ij, scalar3(-numUpper, "int32")));
          var zero = zeros3([M, N], $a.dtype);
          return reshape4(stack(unstack(reshape4($a, [-1, M, N])).map(function(mat) {
            return where(inBand, mat, zero);
          })), shape);
        }
        var bandPart = op2({ bandPart_ });
        function gramSchmidt_(xs) {
          var inputIsTensor2D;
          if (Array.isArray(xs)) {
            inputIsTensor2D = false;
            assert2(xs != null && xs.length > 0, function() {
              return "Gram-Schmidt process: input must not be null, undefined, or empty";
            });
            var dim_1 = xs[0].shape[0];
            var _loop_1 = function(i2) {
              assert2(xs[i2].shape[0] === dim_1, function() {
                return "Gram-Schmidt: Non-unique lengths found in the input vectors: " + ("(" + xs[i2].shape[0] + " vs. " + dim_1 + ")");
              });
            };
            for (var i = 1; i < xs.length; ++i) {
              _loop_1(i);
            }
          } else {
            inputIsTensor2D = true;
            xs = split2(xs, xs.shape[0], 0).map(function(x) {
              return squeeze2(x, [0]);
            });
          }
          assert2(xs.length <= xs[0].shape[0], function() {
            return "Gram-Schmidt: Number of vectors (" + xs.length + ") exceeds " + ("number of dimensions (" + xs[0].shape[0] + ").");
          });
          var ys = [];
          var xs1d = xs;
          var _loop_2 = function(i2) {
            ys.push(ENGINE2.tidy(function() {
              var x = xs1d[i2];
              if (i2 > 0) {
                for (var j = 0; j < i2; ++j) {
                  var proj = mul3(sum$1(mul3(ys[j], x)), ys[j]);
                  x = sub4(x, proj);
                }
              }
              return div2(x, norm(x, "euclidean"));
            }));
          };
          for (var i = 0; i < xs.length; ++i) {
            _loop_2(i);
          }
          if (inputIsTensor2D) {
            return stack(ys, 0);
          } else {
            return ys;
          }
        }
        var gramSchmidt = op2({ gramSchmidt_ });
        function qr_(x, fullMatrices) {
          if (fullMatrices === void 0) {
            fullMatrices = false;
          }
          assert2(x.rank >= 2, function() {
            return "qr() requires input tensor to have a rank >= 2, but got rank " + x.rank;
          });
          if (x.rank === 2) {
            return qr2d(x, fullMatrices);
          } else {
            var outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce(function(value, prev) {
              return value * prev;
            });
            var x2ds = unstack(reshape4(x, [
              outerDimsProd,
              x.shape[x.shape.length - 2],
              x.shape[x.shape.length - 1]
            ]), 0);
            var q2ds_1 = [];
            var r2ds_1 = [];
            x2ds.forEach(function(x2d) {
              var _a = qr2d(x2d, fullMatrices), q2d = _a[0], r2d = _a[1];
              q2ds_1.push(q2d);
              r2ds_1.push(r2d);
            });
            var q = reshape4(stack(q2ds_1, 0), x.shape);
            var r = reshape4(stack(r2ds_1, 0), x.shape);
            return [q, r];
          }
        }
        function qr2d(x, fullMatrices) {
          if (fullMatrices === void 0) {
            fullMatrices = false;
          }
          return ENGINE2.tidy(function() {
            assert2(x.shape.length === 2, function() {
              return "qr2d() requires a 2D Tensor, but got a " + x.shape.length + "D Tensor.";
            });
            var m = x.shape[0];
            var n = x.shape[1];
            var q = eye(m);
            var r = clone2(x);
            var one2D = tensor2d2([[1]], [1, 1]);
            var w = clone2(one2D);
            var iters = m >= n ? n : m;
            var _loop_1 = function(j2) {
              var _a;
              var rTemp = r;
              var wTemp = w;
              var qTemp = q;
              _a = ENGINE2.tidy(function() {
                var rjEnd1 = slice2(r, [j2, j2], [m - j2, 1]);
                var normX = norm(rjEnd1);
                var rjj = slice2(r, [j2, j2], [1, 1]);
                var s = where(greater3(rjj, 0), tensor2d2([[-1]]), tensor2d2([[1]]));
                var u1 = sub4(rjj, mul3(s, normX));
                var wPre = div2(rjEnd1, u1);
                if (wPre.shape[0] === 1) {
                  w = clone2(one2D);
                } else {
                  w = concat3([
                    one2D,
                    slice2(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
                  ], 0);
                }
                var tau = neg2(div2(matMul(s, u1), normX));
                var rjEndAll = slice2(r, [j2, 0], [m - j2, n]);
                var tauTimesW = mul3(tau, w);
                var wT = transpose2(w);
                if (j2 === 0) {
                  r = sub4(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
                } else {
                  var rTimesTau = sub4(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
                  r = concat3([slice2(r, [0, 0], [j2, n]), rTimesTau], 0);
                }
                var tawTimesWT = transpose2(tauTimesW);
                var qAllJEnd = slice2(q, [0, j2], [m, q.shape[1] - j2]);
                if (j2 === 0) {
                  q = sub4(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
                } else {
                  var qTimesTau = sub4(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
                  q = concat3([slice2(q, [0, 0], [m, j2]), qTimesTau], 1);
                }
                return [w, r, q];
              }), w = _a[0], r = _a[1], q = _a[2];
              dispose([rTemp, wTemp, qTemp]);
            };
            for (var j = 0; j < iters; ++j) {
              _loop_1(j);
            }
            if (!fullMatrices && m > n) {
              q = slice2(q, [0, 0], [m, n]);
              r = slice2(r, [0, 0], [n, n]);
            }
            return [q, r];
          });
        }
        var qr = op2({ qr_ });
        (function(Reduction) {
          Reduction[Reduction["NONE"] = 0] = "NONE";
          Reduction[Reduction["MEAN"] = 1] = "MEAN";
          Reduction[Reduction["SUM"] = 2] = "SUM";
          Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
        })(exports.Reduction || (exports.Reduction = {}));
        function computeWeightedLoss_(losses2, weights, reduction) {
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $losses = convertToTensor2(losses2, "losses", "computeWeightedLoss");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "computeWeightedLoss");
          }
          var weightedLoss = $weights == null ? $losses : mul3($losses, $weights);
          if (reduction === exports.Reduction.NONE) {
            return weightedLoss;
          }
          if (reduction === exports.Reduction.SUM) {
            return sum$1(weightedLoss);
          }
          if (reduction === exports.Reduction.MEAN) {
            if ($weights == null) {
              return mean(weightedLoss);
            } else {
              var broadcastFactor = $losses.size / $weights.size;
              var result2 = div2(sum$1(weightedLoss), sum$1($weights));
              return broadcastFactor > 1 ? div2(result2, scalar3(broadcastFactor)) : result2;
            }
          }
          if (reduction === exports.Reduction.SUM_BY_NONZERO_WEIGHTS) {
            if ($weights == null) {
              return div2(sum$1(weightedLoss), scalar3($losses.size));
            } else {
              var broadcastedWeights = mul3($weights, ones$1($losses.shape));
              var numNonZeros = cast5(sum$1(notEqual3(broadcastedWeights, scalar3(0))), "float32");
              return div2(sum$1(weightedLoss), numNonZeros);
            }
          }
          throw Error("Unknown reduction: " + reduction);
        }
        var computeWeightedLoss = op2({ computeWeightedLoss_ });
        function absoluteDifference_(labels, predictions, weights, reduction) {
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "absoluteDifference");
          var $predictions = convertToTensor2(predictions, "predictions", "absoluteDifference");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "absoluteDifference");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
          var losses2 = abs2(sub4($labels, $predictions));
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var absoluteDifference = op2({ absoluteDifference_ });
        function cosineDistance_(labels, predictions, axis, weights, reduction) {
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "cosineDistance");
          var $predictions = convertToTensor2(predictions, "predictions", "cosineDistance");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "cosineDistance");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in cosineDistance: ");
          var one = scalar3(1);
          var losses2 = sub4(one, sum$1(mul3($labels, $predictions), axis, true));
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var cosineDistance = op2({ cosineDistance_ });
        function hingeLoss_(labels, predictions, weights, reduction) {
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "hingeLoss");
          var $predictions = convertToTensor2(predictions, "predictions", "hingeLoss");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "hingeLoss");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in hingeLoss: ");
          var one = scalar3(1);
          $labels = sub4(mul3(scalar3(2), $labels), one);
          var losses2 = relu3(sub4(one, mul3($labels, $predictions)));
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var hingeLoss = op2({ hingeLoss_ });
        function huberLoss_(labels, predictions, weights, delta, reduction) {
          if (delta === void 0) {
            delta = 1;
          }
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "huberLoss");
          var $predictions = convertToTensor2(predictions, "predictions", "huberLoss");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "huberLoss");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in huberLoss: ");
          var deltaScalar = scalar3(delta);
          var error = abs2(sub4($predictions, $labels));
          var quadratic = minimum3(error, deltaScalar);
          var linear = sub4(error, quadratic);
          var losses2 = add$1(mul3(scalar3(0.5), square2(quadratic)), mul3(deltaScalar, linear));
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var huberLoss = op2({ huberLoss_ });
        function logLoss_(labels, predictions, weights, epsilon, reduction) {
          if (epsilon === void 0) {
            epsilon = 1e-7;
          }
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "logLoss");
          var $predictions = convertToTensor2(predictions, "predictions", "logLoss");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "logLoss");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in logLoss: ");
          var one = scalar3(1);
          var epsilonScalar = scalar3(epsilon);
          var l1 = neg2(mul3($labels, log4(add$1($predictions, epsilonScalar))));
          var l2 = mul3(sub4(one, $labels), log4(add$1(sub4(one, $predictions), epsilonScalar)));
          var losses2 = sub4(l1, l2);
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var logLoss = op2({ logLoss_ });
        function meanSquaredError_(labels, predictions, weights, reduction) {
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $labels = convertToTensor2(labels, "labels", "meanSquaredError");
          var $predictions = convertToTensor2(predictions, "predictions", "meanSquaredError");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "meanSquaredError");
          }
          assertShapesMatch2($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
          var losses2 = squaredDifference3($labels, $predictions);
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var meanSquaredError = op2({ meanSquaredError_ });
        function sigmoidCrossEntropyWithLogits_(labels, logits) {
          var $labels = convertToTensor2(labels, "labels", "sigmoidCrossEntropyWithLogits");
          var $logits = convertToTensor2(logits, "logits", "sigmoidCrossEntropyWithLogits");
          assertShapesMatch2($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
          var maxOutput = relu3($logits);
          var outputXTarget = mul3($logits, $labels);
          var sigmoidOutput = log1p2(exp3(neg2(abs2($logits))));
          return add$1(sub4(maxOutput, outputXTarget), sigmoidOutput);
        }
        function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing, reduction) {
          if (labelSmoothing === void 0) {
            labelSmoothing = 0;
          }
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $multiClassLabels = convertToTensor2(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
          var $logits = convertToTensor2(logits, "logits", "sigmoidCrossEntropy");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "sigmoidCrossEntropy");
          }
          assertShapesMatch2($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
          if (labelSmoothing > 0) {
            var labelSmoothingScalar = scalar3(labelSmoothing);
            var one = scalar3(1);
            var half2 = scalar3(0.5);
            $multiClassLabels = add$1(mul3($multiClassLabels, sub4(one, labelSmoothingScalar)), mul3(half2, labelSmoothingScalar));
          }
          var losses2 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var sigmoidCrossEntropy = op2({ sigmoidCrossEntropy_ });
        function softmaxCrossEntropyWithLogits_(labels, logits, dim) {
          if (dim === void 0) {
            dim = -1;
          }
          if (dim === -1) {
            dim = logits.rank - 1;
          }
          if (dim !== logits.rank - 1) {
            throw Error("Softmax cross entropy along a non-last dimension is not yet " + ("supported. Labels / logits was rank " + logits.rank + " ") + ("and dim was " + dim));
          }
          var customOp = customGrad(function(labels2, logits2, save2) {
            var keepDims = true;
            var lse = logSumExp(logits2, [dim], keepDims);
            var logResult = sub4(cast5(logits2, "float32"), lse);
            save2([labels2, logResult]);
            var costVector = neg2(mul3(logResult, labels2));
            var value = sum$1(costVector, [dim]);
            var gradFunc = function(dy, saved) {
              var labels3 = saved[0], logResult2 = saved[1];
              var dyShape = expandShapeToKeepDim2(dy.shape, [dim]);
              return [
                mul3(reshape4(dy, dyShape), sub4(cast5(labels3, "float32"), exp3(logResult2))),
                mul3(reshape4(dy, dyShape), sub4(exp3(logResult2), cast5(labels3, "float32")))
              ];
            };
            return { value, gradFunc };
          });
          return customOp(labels, logits);
        }
        function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing, reduction) {
          if (labelSmoothing === void 0) {
            labelSmoothing = 0;
          }
          if (reduction === void 0) {
            reduction = exports.Reduction.SUM_BY_NONZERO_WEIGHTS;
          }
          var $onehotLabels = convertToTensor2(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
          var $logits = convertToTensor2(logits, "logits", "softmaxCrossEntropy");
          var $weights = null;
          if (weights != null) {
            $weights = convertToTensor2(weights, "weights", "softmaxCrossEntropy");
          }
          assertShapesMatch2($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
          if (labelSmoothing > 0) {
            var labelSmoothingScalar = scalar3(labelSmoothing);
            var one = scalar3(1);
            var numClasses = scalar3($onehotLabels.shape[1]);
            $onehotLabels = add$1(mul3($onehotLabels, sub4(one, labelSmoothingScalar)), div2(labelSmoothingScalar, numClasses));
          }
          var losses2 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
          return computeWeightedLoss(losses2, $weights, reduction);
        }
        var softmaxCrossEntropy = op2({ softmaxCrossEntropy_ });
        function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
          var $indices = convertToTensor2(indices, "indices", "sparseFillEmptyRows");
          var $values = convertToTensor2(values, "values", "sparseFillEmptyRows");
          var $denseShape = convertToTensor2(denseShape, "denseShape", "sparseFillEmptyRows");
          var $defaultValue = convertToTensor2(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
          if ($indices.rank !== 2) {
            throw new Error("Indices should be Tensor2D but received shape\n        " + $indices.shape);
          }
          if ($values.rank !== 1) {
            throw new Error("Values should be Tensor1D but received shape " + $values.shape);
          }
          if ($denseShape.rank !== 1) {
            throw new Error("Dense shape should be Tensor1D but received shape " + $denseShape.shape);
          }
          if ($defaultValue.rank !== 0) {
            throw new Error("Default value should be a scalar but received shape " + $defaultValue.shape);
          }
          var inputs = {
            indices: $indices,
            values: $values,
            denseShape: $denseShape,
            defaultValue: $defaultValue
          };
          var result2 = ENGINE2.runKernel(SparseFillEmptyRows2, inputs);
          return {
            outputIndices: result2[0],
            outputValues: result2[1],
            emptyRowIndicator: result2[2],
            reverseIndexMap: result2[3]
          };
        }
        var sparseFillEmptyRows2 = op2({ sparseFillEmptyRows_ });
        function sparseReshape_(inputIndices, inputShape, newShape) {
          var $inputIndices = convertToTensor2(inputIndices, "inputIndices", "sparseReshape");
          var $inputShape = convertToTensor2(inputShape, "inputShape", "sparseReshape");
          var $newShape = convertToTensor2(newShape, "newShape", "sparseReshape");
          if ($inputIndices.rank !== 2) {
            throw new Error("Input indices should be Tensor2D but received shape\n        " + $inputIndices.shape);
          }
          if ($inputShape.rank !== 1) {
            throw new Error("Input shape should be Tensor1D but received shape " + $inputShape.shape);
          }
          if ($newShape.rank !== 1) {
            throw new Error("New shape should be Tensor1D but received shape " + $newShape.shape);
          }
          var inputs = {
            inputIndices: $inputIndices,
            inputShape: $inputShape,
            newShape: $newShape
          };
          var result2 = ENGINE2.runKernel(SparseReshape2, inputs);
          return { outputIndices: result2[0], outputShape: result2[1] };
        }
        var sparseReshape2 = op2({ sparseReshape_ });
        var spectral2 = {
          fft: fft2,
          ifft: ifft2,
          rfft,
          irfft
        };
        var signal = {
          hammingWindow,
          hannWindow,
          frame,
          stft
        };
        var image2 = {
          flipLeftRight,
          resizeNearestNeighbor: resizeNearestNeighbor2,
          resizeBilinear: resizeBilinear2,
          rotateWithOffset,
          cropAndResize: cropAndResize2,
          nonMaxSuppression,
          nonMaxSuppressionAsync,
          nonMaxSuppressionWithScore,
          nonMaxSuppressionWithScoreAsync,
          nonMaxSuppressionPadded,
          nonMaxSuppressionPaddedAsync,
          threshold,
          transform: transform2
        };
        var linalg = {
          bandPart,
          gramSchmidt,
          qr
        };
        var losses = {
          absoluteDifference,
          computeWeightedLoss,
          cosineDistance,
          hingeLoss,
          huberLoss,
          logLoss,
          meanSquaredError,
          sigmoidCrossEntropy,
          softmaxCrossEntropy
        };
        var sparse = {
          sparseFillEmptyRows: sparseFillEmptyRows2,
          sparseReshape: sparseReshape2
        };
        var Optimizer = function(_super) {
          __extends2(Optimizer2, _super);
          function Optimizer2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          Optimizer2.prototype.minimize = function(f, returnCost, varList) {
            if (returnCost === void 0) {
              returnCost = false;
            }
            var _a = this.computeGradients(f, varList), value = _a.value, grads2 = _a.grads;
            if (varList != null) {
              var gradArray = varList.map(function(v) {
                return { name: v.name, tensor: grads2[v.name] };
              });
              this.applyGradients(gradArray);
            } else {
              this.applyGradients(grads2);
            }
            dispose(grads2);
            if (returnCost) {
              return value;
            } else {
              value.dispose();
              return null;
            }
          };
          Object.defineProperty(Optimizer2.prototype, "iterations", {
            get: function() {
              if (this.iterations_ == null) {
                this.iterations_ = 0;
              }
              return this.iterations_;
            },
            enumerable: true,
            configurable: true
          });
          Optimizer2.prototype.incrementIterations = function() {
            this.iterations_ = this.iterations + 1;
          };
          Optimizer2.prototype.computeGradients = function(f, varList) {
            return variableGrads(f, varList);
          };
          Optimizer2.prototype.dispose = function() {
            if (this.iterations_ != null) {
              dispose(this.iterations_);
            }
          };
          Optimizer2.prototype.saveIterations = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                if (this.iterations_ == null) {
                  this.iterations_ = 0;
                }
                return [2, {
                  name: "iter",
                  tensor: scalar3(this.iterations_, "int32")
                }];
              });
            });
          };
          Optimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                throw new Error("getWeights() is not implemented for this optimizer yet.");
              });
            });
          };
          Optimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                throw new Error("setWeights() is not implemented for this optimizer class " + ("" + this.getClassName()));
              });
            });
          };
          Optimizer2.prototype.extractIterations = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var _a;
              return __generator2(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _a = this;
                    return [4, weightValues[0].tensor.data()];
                  case 1:
                    _a.iterations_ = _b.sent()[0];
                    return [2, weightValues.slice(1)];
                }
              });
            });
          };
          return Optimizer2;
        }(Serializable);
        Object.defineProperty(Optimizer, Symbol.hasInstance, {
          value: function(instance) {
            return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
          }
        });
        var AdadeltaOptimizer = function(_super) {
          __extends2(AdadeltaOptimizer2, _super);
          function AdadeltaOptimizer2(learningRate, rho, epsilon) {
            if (epsilon === void 0) {
              epsilon = null;
            }
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.rho = rho;
            _this.epsilon = epsilon;
            _this.accumulatedGrads = [];
            _this.accumulatedUpdates = [];
            if (epsilon == null) {
              _this.epsilon = ENGINE2.backend.epsilon();
            }
            return _this;
          }
          AdadeltaOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var variableNames = Array.isArray(variableGradients) ? variableGradients.map(function(item) {
              return item.name;
            }) : Object.keys(variableGradients);
            variableNames.forEach(function(name, i) {
              var value = ENGINE2.registeredVariables[name];
              var trainable = false;
              if (_this.accumulatedGrads[i] == null) {
                _this.accumulatedGrads[i] = {
                  originalName: name + "/accum_grad",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable);
                  })
                };
              }
              if (_this.accumulatedUpdates[i] == null) {
                _this.accumulatedUpdates[i] = {
                  originalName: name + "/accum_var",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable);
                  })
                };
              }
              var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
              if (gradient == null) {
                return;
              }
              var accumulatedGrad = _this.accumulatedGrads[i].variable;
              var accumulatedUpdate = _this.accumulatedUpdates[i].variable;
              tidy3(function() {
                var newAccumulatedGrad = add$1(mul3(accumulatedGrad, _this.rho), mul3(square2(gradient), 1 - _this.rho));
                var updates = mul3(div2(sqrt2(add$1(accumulatedUpdate, _this.epsilon)), sqrt2(add$1(accumulatedGrad, _this.epsilon))), gradient);
                var newAccumulatedUpdate = add$1(mul3(accumulatedUpdate, _this.rho), mul3(square2(updates), 1 - _this.rho));
                accumulatedGrad.assign(newAccumulatedGrad);
                accumulatedUpdate.assign(newAccumulatedUpdate);
                var newValue = add$1(mul3(updates, -_this.learningRate), value);
                value.assign(newValue);
              });
            });
            this.incrementIterations();
          };
          AdadeltaOptimizer2.prototype.dispose = function() {
            if (this.accumulatedUpdates != null) {
              dispose(this.accumulatedGrads.map(function(v) {
                return v.variable;
              }));
              dispose(this.accumulatedUpdates.map(function(v) {
                return v.variable;
              }));
            }
          };
          AdadeltaOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var variables;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    variables = this.accumulatedGrads.concat(this.accumulatedUpdates);
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()].concat(variables.map(function(v) {
                      return { name: v.originalName, tensor: v.variable };
                    }))];
                }
              });
            });
          };
          AdadeltaOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var variableCount, trainable;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    variableCount = weightValues.length / 2;
                    trainable = false;
                    this.accumulatedGrads = weightValues.slice(0, variableCount).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    return [2];
                }
              });
            });
          };
          AdadeltaOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "rho": this.rho,
              "epsilon": this.epsilon
            };
          };
          AdadeltaOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["rho"], config["epsilon"]);
          };
          AdadeltaOptimizer2.className = "Adadelta";
          return AdadeltaOptimizer2;
        }(Optimizer);
        registerClass(AdadeltaOptimizer);
        var AdagradOptimizer = function(_super) {
          __extends2(AdagradOptimizer2, _super);
          function AdagradOptimizer2(learningRate, initialAccumulatorValue) {
            if (initialAccumulatorValue === void 0) {
              initialAccumulatorValue = 0.1;
            }
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.initialAccumulatorValue = initialAccumulatorValue;
            _this.accumulatedGrads = [];
            return _this;
          }
          AdagradOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var variableNames = Array.isArray(variableGradients) ? variableGradients.map(function(item) {
              return item.name;
            }) : Object.keys(variableGradients);
            variableNames.forEach(function(name, i) {
              var value = ENGINE2.registeredVariables[name];
              if (_this.accumulatedGrads[i] == null) {
                var trainable_1 = false;
                _this.accumulatedGrads[i] = {
                  originalName: name + "/accumulator",
                  variable: tidy3(function() {
                    return fill2(value.shape, _this.initialAccumulatorValue).variable(trainable_1);
                  })
                };
              }
              var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
              if (gradient == null) {
                return;
              }
              var accumulatedGrad = _this.accumulatedGrads[i].variable;
              tidy3(function() {
                var newAccumulatedGrad = add$1(accumulatedGrad, square2(gradient));
                accumulatedGrad.assign(newAccumulatedGrad);
                var newValue = add$1(mul3(div2(gradient, sqrt2(add$1(newAccumulatedGrad, ENGINE2.backend.epsilon()))), -_this.learningRate), value);
                value.assign(newValue);
              });
            });
            this.incrementIterations();
          };
          AdagradOptimizer2.prototype.dispose = function() {
            if (this.accumulatedGrads != null) {
              dispose(this.accumulatedGrads.map(function(v) {
                return v.variable;
              }));
            }
          };
          AdagradOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()].concat(this.accumulatedGrads.map(function(v) {
                      return { name: v.originalName, tensor: v.variable };
                    }))];
                }
              });
            });
          };
          AdagradOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var trainable;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    trainable = false;
                    this.accumulatedGrads = weightValues.map(function(v) {
                      return { originalName: v.name, variable: v.tensor.variable(trainable) };
                    });
                    return [2];
                }
              });
            });
          };
          AdagradOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "initialAccumulatorValue": this.initialAccumulatorValue
            };
          };
          AdagradOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["initialAccumulatorValue"]);
          };
          AdagradOptimizer2.className = "Adagrad";
          return AdagradOptimizer2;
        }(Optimizer);
        registerClass(AdagradOptimizer);
        var AdamOptimizer = function(_super) {
          __extends2(AdamOptimizer2, _super);
          function AdamOptimizer2(learningRate, beta1, beta2, epsilon) {
            if (epsilon === void 0) {
              epsilon = null;
            }
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.beta1 = beta1;
            _this.beta2 = beta2;
            _this.epsilon = epsilon;
            _this.accumulatedFirstMoment = [];
            _this.accumulatedSecondMoment = [];
            tidy3(function() {
              _this.accBeta1 = scalar3(beta1).variable();
              _this.accBeta2 = scalar3(beta2).variable();
            });
            if (epsilon == null) {
              _this.epsilon = ENGINE2.backend.epsilon();
            }
            return _this;
          }
          AdamOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var varNames = Array.isArray(variableGradients) ? variableGradients.map(function(v) {
              return v.name;
            }) : Object.keys(variableGradients);
            tidy3(function() {
              var oneMinusAccBeta1 = sub4(1, _this.accBeta1);
              var oneMinusAccBeta2 = sub4(1, _this.accBeta2);
              varNames.forEach(function(name, i) {
                var value = ENGINE2.registeredVariables[name];
                var trainable = false;
                if (_this.accumulatedFirstMoment[i] == null) {
                  _this.accumulatedFirstMoment[i] = {
                    originalName: name + "/m",
                    variable: tidy3(function() {
                      return zerosLike2(value).variable(trainable);
                    })
                  };
                }
                if (_this.accumulatedSecondMoment[i] == null) {
                  _this.accumulatedSecondMoment[i] = {
                    originalName: name + "/v",
                    variable: tidy3(function() {
                      return zerosLike2(value).variable(trainable);
                    })
                  };
                }
                var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
                if (gradient == null) {
                  return;
                }
                var firstMoment = _this.accumulatedFirstMoment[i].variable;
                var secondMoment = _this.accumulatedSecondMoment[i].variable;
                var newFirstMoment = add$1(mul3(firstMoment, _this.beta1), mul3(gradient, 1 - _this.beta1));
                var newSecondMoment = add$1(mul3(secondMoment, _this.beta2), mul3(square2(gradient), 1 - _this.beta2));
                var biasCorrectedFirstMoment = div2(newFirstMoment, oneMinusAccBeta1);
                var biasCorrectedSecondMoment = div2(newSecondMoment, oneMinusAccBeta2);
                firstMoment.assign(newFirstMoment);
                secondMoment.assign(newSecondMoment);
                var newValue = add$1(mul3(div2(biasCorrectedFirstMoment, add$1(sqrt2(biasCorrectedSecondMoment), _this.epsilon)), -_this.learningRate), value);
                value.assign(newValue);
              });
              _this.accBeta1.assign(mul3(_this.accBeta1, _this.beta1));
              _this.accBeta2.assign(mul3(_this.accBeta2, _this.beta2));
            });
            this.incrementIterations();
          };
          AdamOptimizer2.prototype.dispose = function() {
            this.accBeta1.dispose();
            this.accBeta2.dispose();
            if (this.accumulatedFirstMoment != null) {
              dispose(this.accumulatedFirstMoment.map(function(v) {
                return v.variable;
              }));
            }
            if (this.accumulatedSecondMoment != null) {
              dispose(this.accumulatedSecondMoment.map(function(v) {
                return v.variable;
              }));
            }
          };
          AdamOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var variables;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    variables = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment);
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()].concat(variables.map(function(v) {
                      return { name: v.originalName, tensor: v.variable };
                    }))];
                }
              });
            });
          };
          AdamOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var variableCount, trainable;
              var _this = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    tidy3(function() {
                      _this.accBeta1.assign(pow2(_this.beta1, _this.iterations_ + 1));
                      _this.accBeta2.assign(pow2(_this.beta2, _this.iterations_ + 1));
                    });
                    variableCount = weightValues.length / 2;
                    trainable = false;
                    this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    return [2];
                }
              });
            });
          };
          AdamOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "beta1": this.beta1,
              "beta2": this.beta2,
              "epsilon": this.epsilon
            };
          };
          AdamOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"]);
          };
          AdamOptimizer2.className = "Adam";
          return AdamOptimizer2;
        }(Optimizer);
        registerClass(AdamOptimizer);
        var AdamaxOptimizer = function(_super) {
          __extends2(AdamaxOptimizer2, _super);
          function AdamaxOptimizer2(learningRate, beta1, beta2, epsilon, decay) {
            if (epsilon === void 0) {
              epsilon = null;
            }
            if (decay === void 0) {
              decay = 0;
            }
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.beta1 = beta1;
            _this.beta2 = beta2;
            _this.epsilon = epsilon;
            _this.decay = decay;
            _this.accumulatedFirstMoment = [];
            _this.accumulatedWeightedInfNorm = [];
            tidy3(function() {
              _this.iteration = scalar3(0).variable();
              _this.accBeta1 = scalar3(beta1).variable();
            });
            if (epsilon == null) {
              _this.epsilon = ENGINE2.backend.epsilon();
            }
            return _this;
          }
          AdamaxOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var variableNames = Array.isArray(variableGradients) ? variableGradients.map(function(item) {
              return item.name;
            }) : Object.keys(variableGradients);
            tidy3(function() {
              var oneMinusAccBeta1 = sub4(1, _this.accBeta1);
              var lr = div2(-_this.learningRate, add$1(mul3(_this.iteration, _this.decay), 1));
              variableNames.forEach(function(name, i) {
                var value = ENGINE2.registeredVariables[name];
                var trainable = false;
                if (_this.accumulatedFirstMoment[i] == null) {
                  _this.accumulatedFirstMoment[i] = {
                    originalName: name + "/m",
                    variable: zerosLike2(value).variable(trainable)
                  };
                }
                if (_this.accumulatedWeightedInfNorm[i] == null) {
                  _this.accumulatedWeightedInfNorm[i] = {
                    originalName: name + "/v",
                    variable: zerosLike2(value).variable(trainable)
                  };
                }
                var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
                if (gradient == null) {
                  return;
                }
                var firstMoment = _this.accumulatedFirstMoment[i].variable;
                var weightedInfNorm = _this.accumulatedWeightedInfNorm[i].variable;
                var newFirstMoment = add$1(mul3(firstMoment, _this.beta1), mul3(gradient, 1 - _this.beta1));
                var ut0 = mul3(weightedInfNorm, _this.beta2);
                var ut1 = abs2(gradient);
                var newWeightedInfNorm = maximum3(ut0, ut1);
                firstMoment.assign(newFirstMoment);
                weightedInfNorm.assign(newWeightedInfNorm);
                var newValue = add$1(mul3(div2(lr, oneMinusAccBeta1), div2(newFirstMoment, add$1(newWeightedInfNorm, _this.epsilon))), value);
                value.assign(newValue);
              });
              _this.iteration.assign(add$1(_this.iteration, 1));
              _this.accBeta1.assign(mul3(_this.accBeta1, _this.beta1));
            });
            this.incrementIterations();
          };
          AdamaxOptimizer2.prototype.dispose = function() {
            this.accBeta1.dispose();
            this.iteration.dispose();
            if (this.accumulatedFirstMoment != null) {
              dispose(this.accumulatedFirstMoment.map(function(v) {
                return v.variable;
              }));
            }
            if (this.accumulatedWeightedInfNorm != null) {
              dispose(this.accumulatedWeightedInfNorm.map(function(v) {
                return v.variable;
              }));
            }
          };
          AdamaxOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                throw new Error("getWeights() is not implemented for Adamax yet.");
              });
            });
          };
          AdamaxOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                throw new Error("setWeights() is not implemented for Adamax yet.");
              });
            });
          };
          AdamaxOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "beta1": this.beta1,
              "beta2": this.beta2,
              "epsilon": this.epsilon,
              "decay": this.decay
            };
          };
          AdamaxOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"], config["decay"]);
          };
          AdamaxOptimizer2.className = "Adamax";
          return AdamaxOptimizer2;
        }(Optimizer);
        registerClass(AdamaxOptimizer);
        var SGDOptimizer = function(_super) {
          __extends2(SGDOptimizer2, _super);
          function SGDOptimizer2(learningRate) {
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.setLearningRate(learningRate);
            return _this;
          }
          SGDOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var varNames = Array.isArray(variableGradients) ? variableGradients.map(function(v) {
              return v.name;
            }) : Object.keys(variableGradients);
            varNames.forEach(function(name, i) {
              var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
              if (gradient == null) {
                return;
              }
              var value = ENGINE2.registeredVariables[name];
              tidy3(function() {
                var newValue = add$1(mul3(_this.c, gradient), value);
                value.assign(newValue);
              });
            });
            this.incrementIterations();
          };
          SGDOptimizer2.prototype.setLearningRate = function(learningRate) {
            this.learningRate = learningRate;
            if (this.c != null) {
              this.c.dispose();
            }
            this.c = keep(scalar3(-learningRate));
          };
          SGDOptimizer2.prototype.dispose = function() {
            this.c.dispose();
          };
          SGDOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()]];
                }
              });
            });
          };
          SGDOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    if (weightValues.length !== 0) {
                      throw new Error("SGD optimizer does not have settable weights.");
                    }
                    return [2];
                }
              });
            });
          };
          SGDOptimizer2.prototype.getConfig = function() {
            return { "learningRate": this.learningRate };
          };
          SGDOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"]);
          };
          SGDOptimizer2.className = "SGD";
          return SGDOptimizer2;
        }(Optimizer);
        registerClass(SGDOptimizer);
        var MomentumOptimizer = function(_super) {
          __extends2(MomentumOptimizer2, _super);
          function MomentumOptimizer2(learningRate, momentum, useNesterov) {
            if (useNesterov === void 0) {
              useNesterov = false;
            }
            var _this = _super.call(this, learningRate) || this;
            _this.learningRate = learningRate;
            _this.momentum = momentum;
            _this.useNesterov = useNesterov;
            _this.accumulations = [];
            _this.m = scalar3(_this.momentum);
            return _this;
          }
          MomentumOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var variableNames = Array.isArray(variableGradients) ? variableGradients.map(function(item) {
              return item.name;
            }) : Object.keys(variableGradients);
            variableNames.forEach(function(name, i) {
              var value = ENGINE2.registeredVariables[name];
              if (_this.accumulations[i] == null) {
                var trainable_1 = false;
                _this.accumulations[i] = {
                  originalName: name + "/momentum",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable_1);
                  })
                };
              }
              var accumulation = _this.accumulations[i].variable;
              var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
              if (gradient == null) {
                return;
              }
              tidy3(function() {
                var newValue;
                var newAccumulation = add$1(mul3(_this.m, accumulation), gradient);
                if (_this.useNesterov) {
                  newValue = add$1(mul3(_this.c, add$1(gradient, mul3(newAccumulation, _this.m))), value);
                } else {
                  newValue = add$1(mul3(_this.c, newAccumulation), value);
                }
                accumulation.assign(newAccumulation);
                value.assign(newValue);
              });
            });
            this.incrementIterations();
          };
          MomentumOptimizer2.prototype.dispose = function() {
            this.m.dispose();
            if (this.accumulations != null) {
              dispose(this.accumulations.map(function(v) {
                return v.variable;
              }));
            }
          };
          MomentumOptimizer2.prototype.setMomentum = function(momentum) {
            this.momentum = momentum;
          };
          MomentumOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()].concat(this.accumulations.map(function(v) {
                      return { name: v.originalName, tensor: v.variable };
                    }))];
                }
              });
            });
          };
          MomentumOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var trainable;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    trainable = false;
                    this.accumulations = weightValues.map(function(v) {
                      return { originalName: v.name, variable: v.tensor.variable(trainable) };
                    });
                    return [2];
                }
              });
            });
          };
          MomentumOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "momentum": this.momentum,
              "useNesterov": this.useNesterov
            };
          };
          MomentumOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["momentum"], config["useNesterov"]);
          };
          MomentumOptimizer2.className = "Momentum";
          return MomentumOptimizer2;
        }(SGDOptimizer);
        registerClass(MomentumOptimizer);
        var RMSPropOptimizer = function(_super) {
          __extends2(RMSPropOptimizer2, _super);
          function RMSPropOptimizer2(learningRate, decay, momentum, epsilon, centered) {
            if (decay === void 0) {
              decay = 0.9;
            }
            if (momentum === void 0) {
              momentum = 0;
            }
            if (epsilon === void 0) {
              epsilon = null;
            }
            if (centered === void 0) {
              centered = false;
            }
            var _this = _super.call(this) || this;
            _this.learningRate = learningRate;
            _this.decay = decay;
            _this.momentum = momentum;
            _this.epsilon = epsilon;
            _this.accumulatedMeanSquares = [];
            _this.accumulatedMoments = [];
            _this.accumulatedMeanGrads = [];
            _this.centered = centered;
            if (epsilon == null) {
              _this.epsilon = ENGINE2.backend.epsilon();
            }
            if (learningRate == null) {
              throw new Error("learningRate for RMSPropOptimizer must be defined.");
            }
            return _this;
          }
          RMSPropOptimizer2.prototype.applyGradients = function(variableGradients) {
            var _this = this;
            var variableNames = Array.isArray(variableGradients) ? variableGradients.map(function(item) {
              return item.name;
            }) : Object.keys(variableGradients);
            variableNames.forEach(function(name, i) {
              var value = ENGINE2.registeredVariables[name];
              var trainable = false;
              if (_this.accumulatedMeanSquares[i] == null) {
                _this.accumulatedMeanSquares[i] = {
                  originalName: name + "/rms",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable);
                  })
                };
              }
              if (_this.accumulatedMoments[i] == null) {
                _this.accumulatedMoments[i] = {
                  originalName: name + "/momentum",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable);
                  })
                };
              }
              if (_this.accumulatedMeanGrads[i] == null && _this.centered) {
                _this.accumulatedMeanGrads[i] = {
                  originalName: name + "/mg",
                  variable: tidy3(function() {
                    return zerosLike2(value).variable(trainable);
                  })
                };
              }
              var gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
              if (gradient == null) {
                return;
              }
              var accumulatedMeanSquare = _this.accumulatedMeanSquares[i].variable;
              var accumulatedMoments = _this.accumulatedMoments[i].variable;
              tidy3(function() {
                var newAccumulatedMeanSquare = add$1(mul3(accumulatedMeanSquare, _this.decay), mul3(square2(gradient), 1 - _this.decay));
                if (_this.centered) {
                  var accumulatedMeanGrad = _this.accumulatedMeanGrads[i].variable;
                  var newAccumulatedMeanGrad = add$1(mul3(accumulatedMeanGrad, _this.decay), mul3(gradient, 1 - _this.decay));
                  var gradContribution = div2(mul3(gradient, _this.learningRate), sqrt2(sub4(newAccumulatedMeanSquare, add$1(square2(newAccumulatedMeanGrad), _this.epsilon))));
                  var newAccumulatedMoments = add$1(mul3(accumulatedMoments, _this.momentum), gradContribution);
                  accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
                  accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
                  accumulatedMoments.assign(newAccumulatedMoments);
                  var newValue = sub4(value, newAccumulatedMoments);
                  value.assign(newValue);
                } else {
                  var newAccumulatedMeanSquare_1 = add$1(mul3(accumulatedMeanSquare, _this.decay), mul3(square2(gradient), 1 - _this.decay));
                  var newAccumulatedMoments = add$1(mul3(accumulatedMoments, _this.momentum), div2(mul3(gradient, _this.learningRate), sqrt2(add$1(newAccumulatedMeanSquare_1, _this.epsilon))));
                  accumulatedMeanSquare.assign(newAccumulatedMeanSquare_1);
                  accumulatedMoments.assign(newAccumulatedMoments);
                  var newValue = sub4(value, newAccumulatedMoments);
                  value.assign(newValue);
                }
              });
            });
            this.incrementIterations();
          };
          RMSPropOptimizer2.prototype.dispose = function() {
            if (this.accumulatedMeanSquares != null) {
              dispose(this.accumulatedMeanSquares.map(function(v) {
                return v.variable;
              }));
            }
            if (this.accumulatedMeanGrads != null && this.centered) {
              dispose(this.accumulatedMeanGrads.map(function(v) {
                return v.variable;
              }));
            }
            if (this.accumulatedMoments != null) {
              dispose(this.accumulatedMoments.map(function(v) {
                return v.variable;
              }));
            }
          };
          RMSPropOptimizer2.prototype.getWeights = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var variables;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    variables = this.accumulatedMeanSquares.concat(this.accumulatedMoments);
                    if (this.centered) {
                      variables.push.apply(variables, this.accumulatedMeanGrads);
                    }
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [_a.sent()].concat(variables.map(function(v) {
                      return { name: v.originalName, tensor: v.variable };
                    }))];
                }
              });
            });
          };
          RMSPropOptimizer2.prototype.setWeights = function(weightValues) {
            return __awaiter2(this, void 0, void 0, function() {
              var variableCount, trainable;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.extractIterations(weightValues)];
                  case 1:
                    weightValues = _a.sent();
                    variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
                    trainable = false;
                    this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map(function(v) {
                      return {
                        originalName: v.name,
                        variable: v.tensor.variable(trainable)
                      };
                    });
                    if (this.centered) {
                      this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map(function(v) {
                        return {
                          originalName: v.name,
                          variable: v.tensor.variable(trainable)
                        };
                      });
                    }
                    return [2];
                }
              });
            });
          };
          RMSPropOptimizer2.prototype.getConfig = function() {
            return {
              "learningRate": this.learningRate,
              "decay": this.decay,
              "momentum": this.momentum,
              "epsilon": this.epsilon,
              "centered": this.centered
            };
          };
          RMSPropOptimizer2.fromConfig = function(cls, config) {
            return new cls(config["learningRate"], config["decay"], config["momentum"], config["epsilon"], config["centered"]);
          };
          RMSPropOptimizer2.className = "RMSProp";
          return RMSPropOptimizer2;
        }(Optimizer);
        registerClass(RMSPropOptimizer);
        var OptimizerConstructors = function() {
          function OptimizerConstructors2() {
          }
          OptimizerConstructors2.sgd = function(learningRate) {
            return new SGDOptimizer(learningRate);
          };
          OptimizerConstructors2.momentum = function(learningRate, momentum, useNesterov) {
            if (useNesterov === void 0) {
              useNesterov = false;
            }
            return new MomentumOptimizer(learningRate, momentum, useNesterov);
          };
          OptimizerConstructors2.rmsprop = function(learningRate, decay, momentum, epsilon, centered) {
            if (decay === void 0) {
              decay = 0.9;
            }
            if (momentum === void 0) {
              momentum = 0;
            }
            if (epsilon === void 0) {
              epsilon = null;
            }
            if (centered === void 0) {
              centered = false;
            }
            return new RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
          };
          OptimizerConstructors2.adam = function(learningRate, beta1, beta2, epsilon) {
            if (learningRate === void 0) {
              learningRate = 1e-3;
            }
            if (beta1 === void 0) {
              beta1 = 0.9;
            }
            if (beta2 === void 0) {
              beta2 = 0.999;
            }
            if (epsilon === void 0) {
              epsilon = null;
            }
            return new AdamOptimizer(learningRate, beta1, beta2, epsilon);
          };
          OptimizerConstructors2.adadelta = function(learningRate, rho, epsilon) {
            if (learningRate === void 0) {
              learningRate = 1e-3;
            }
            if (rho === void 0) {
              rho = 0.95;
            }
            if (epsilon === void 0) {
              epsilon = null;
            }
            return new AdadeltaOptimizer(learningRate, rho, epsilon);
          };
          OptimizerConstructors2.adamax = function(learningRate, beta1, beta2, epsilon, decay) {
            if (learningRate === void 0) {
              learningRate = 2e-3;
            }
            if (beta1 === void 0) {
              beta1 = 0.9;
            }
            if (beta2 === void 0) {
              beta2 = 0.999;
            }
            if (epsilon === void 0) {
              epsilon = null;
            }
            if (decay === void 0) {
              decay = 0;
            }
            return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
          };
          OptimizerConstructors2.adagrad = function(learningRate, initialAccumulatorValue) {
            if (initialAccumulatorValue === void 0) {
              initialAccumulatorValue = 0.1;
            }
            return new AdagradOptimizer(learningRate, initialAccumulatorValue);
          };
          return OptimizerConstructors2;
        }();
        var train = {
          sgd: OptimizerConstructors.sgd,
          momentum: OptimizerConstructors.momentum,
          adadelta: OptimizerConstructors.adadelta,
          adagrad: OptimizerConstructors.adagrad,
          rmsprop: OptimizerConstructors.rmsprop,
          adamax: OptimizerConstructors.adamax,
          adam: OptimizerConstructors.adam
        };
        var delayCallback = function() {
          if (typeof requestAnimationFrame !== "undefined") {
            return requestAnimationFrame;
          } else if (typeof setImmediate !== "undefined") {
            return setImmediate;
          }
          return function(f) {
            return f();
          };
        }();
        function nextFrame() {
          return new Promise(function(resolve) {
            return delayCallback(function() {
              return resolve();
            });
          });
        }
        function assertParamsConsistent2(shapes, axis) {
          var rank = shapes[0].length;
          shapes.forEach(function(shape, i) {
            assert2(shape.length === rank, function() {
              return "Error in concat" + rank + "D: rank of tensors[" + i + "] must be the same " + ("as the rank of the rest (" + rank + ")");
            });
          });
          assert2(axis >= 0 && axis < rank, function() {
            return "Error in concat" + rank + "D: axis must be between 0 and " + (rank - 1) + ".";
          });
          var firstShape = shapes[0];
          shapes.forEach(function(shape, i) {
            for (var r = 0; r < rank; r++) {
              assert2(r === axis || shape[r] === firstShape[r], function() {
                return "Error in concat" + rank + "D: Shape of tensors[" + i + "] (" + shape + ") " + ("does not match the shape of the rest (" + firstShape + ") ") + ("along the non-concatenated axis " + i + ".");
              });
            }
          });
        }
        function computeOutShape$1(shapes, axis) {
          var outputShape = shapes[0].slice();
          for (var i = 1; i < shapes.length; i++) {
            outputShape[axis] += shapes[i][axis];
          }
          return outputShape;
        }
        var PARALLELIZE_THRESHOLD2 = 30;
        function computeOptimalWindowSize2(inSize) {
          if (inSize <= PARALLELIZE_THRESHOLD2) {
            return inSize;
          }
          return nearestDivisor2(inSize, Math.floor(Math.sqrt(inSize)));
        }
        function getImageCenter2(center, imageHeight, imageWidth) {
          var centerX = imageWidth * (typeof center === "number" ? center : center[0]);
          var centerY = imageHeight * (typeof center === "number" ? center : center[1]);
          return [centerX, centerY];
        }
        function getReshaped2(inputShape, blockShape, prod3, batchToSpace) {
          if (batchToSpace === void 0) {
            batchToSpace = true;
          }
          var reshaped = [];
          if (batchToSpace) {
            reshaped = reshaped.concat(blockShape.slice(0));
            reshaped.push(inputShape[0] / prod3);
            reshaped = reshaped.concat(inputShape.slice(1));
          } else {
            reshaped = reshaped.concat(inputShape[0]);
            var spatialLength = blockShape.length;
            for (var i = 0; i < spatialLength; ++i) {
              reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
            }
            reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
          }
          return reshaped;
        }
        function getPermuted2(reshapedRank, blockShapeRank, batchToSpace) {
          if (batchToSpace === void 0) {
            batchToSpace = true;
          }
          var permuted = [];
          if (batchToSpace) {
            permuted.push(blockShapeRank);
            for (var i = blockShapeRank + 1; i < reshapedRank; ++i) {
              if (i <= 2 * blockShapeRank) {
                permuted.push(i);
                permuted.push(i - (blockShapeRank + 1));
              } else {
                permuted.push(i);
              }
            }
          } else {
            var permutedBeforeBatch = [];
            var permutedAfterBatch = [];
            for (var i = 1; i < reshapedRank; ++i) {
              if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
                permutedAfterBatch.push(i);
              } else {
                permutedBeforeBatch.push(i);
              }
            }
            permuted.push.apply(permuted, permutedBeforeBatch);
            permuted.push(0);
            permuted.push.apply(permuted, permutedAfterBatch);
          }
          return permuted;
        }
        function getReshapedPermuted2(inputShape, blockShape, prod3, batchToSpace) {
          if (batchToSpace === void 0) {
            batchToSpace = true;
          }
          var reshapedPermuted = [];
          if (batchToSpace) {
            reshapedPermuted.push(inputShape[0] / prod3);
          } else {
            reshapedPermuted.push(inputShape[0] * prod3);
          }
          for (var i = 1; i < inputShape.length; ++i) {
            if (i <= blockShape.length) {
              if (batchToSpace) {
                reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
              } else {
                reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
              }
            } else {
              reshapedPermuted.push(inputShape[i]);
            }
          }
          return reshapedPermuted;
        }
        function getSliceBeginCoords2(crops, blockShape) {
          var sliceBeginCoords = [0];
          for (var i = 0; i < blockShape; ++i) {
            sliceBeginCoords.push(crops[i][0]);
          }
          return sliceBeginCoords;
        }
        function getSliceSize2(uncroppedShape, crops, blockShape) {
          var sliceSize = uncroppedShape.slice(0, 1);
          for (var i = 0; i < blockShape; ++i) {
            sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
          }
          return sliceSize;
        }
        var SELU_SCALEALPHA2 = 1.7580993408473768;
        var SELU_SCALE2 = 1.0507009873554805;
        var ERF_P2 = 0.3275911;
        var ERF_A12 = 0.254829592;
        var ERF_A22 = -0.284496736;
        var ERF_A32 = 1.421413741;
        var ERF_A42 = -1.453152027;
        var ERF_A52 = 1.061405429;
        function warn2() {
          var msg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
          }
          if (!env2().getBool("IS_TEST")) {
            console.warn.apply(console, msg);
          }
        }
        function log$1() {
          var msg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
          }
          if (!env2().getBool("IS_TEST")) {
            console.log.apply(console, msg);
          }
        }
        function mergeRealAndImagArrays2(real4, imag3) {
          if (real4.length !== imag3.length) {
            throw new Error("Cannot merge real and imag arrays of different lengths. real:" + (real4.length + ", imag: " + imag3.length + "."));
          }
          var result2 = new Float32Array(real4.length * 2);
          for (var i = 0; i < result2.length; i += 2) {
            result2[i] = real4[i / 2];
            result2[i + 1] = imag3[i / 2];
          }
          return result2;
        }
        function splitRealAndImagArrays2(complex5) {
          var real4 = new Float32Array(complex5.length / 2);
          var imag3 = new Float32Array(complex5.length / 2);
          for (var i = 0; i < complex5.length; i += 2) {
            real4[i / 2] = complex5[i];
            imag3[i / 2] = complex5[i + 1];
          }
          return { real: real4, imag: imag3 };
        }
        function complexWithEvenIndex2(complex5) {
          var len = Math.ceil(complex5.length / 4);
          var real4 = new Float32Array(len);
          var imag3 = new Float32Array(len);
          for (var i = 0; i < complex5.length; i += 4) {
            real4[Math.floor(i / 4)] = complex5[i];
            imag3[Math.floor(i / 4)] = complex5[i + 1];
          }
          return { real: real4, imag: imag3 };
        }
        function complexWithOddIndex2(complex5) {
          var len = Math.floor(complex5.length / 4);
          var real4 = new Float32Array(len);
          var imag3 = new Float32Array(len);
          for (var i = 2; i < complex5.length; i += 4) {
            real4[Math.floor(i / 4)] = complex5[i];
            imag3[Math.floor(i / 4)] = complex5[i + 1];
          }
          return { real: real4, imag: imag3 };
        }
        function getComplexWithIndex2(complex5, index2) {
          var real4 = complex5[index2 * 2];
          var imag3 = complex5[index2 * 2 + 1];
          return { real: real4, imag: imag3 };
        }
        function assignToTypedArray2(data, real4, imag3, index2) {
          data[index2 * 2] = real4;
          data[index2 * 2 + 1] = imag3;
        }
        function exponents2(n, inverse) {
          var real4 = new Float32Array(n / 2);
          var imag3 = new Float32Array(n / 2);
          for (var i = 0; i < Math.ceil(n / 2); i++) {
            var x = (inverse ? 2 : -2) * Math.PI * (i / n);
            real4[i] = Math.cos(x);
            imag3[i] = Math.sin(x);
          }
          return { real: real4, imag: imag3 };
        }
        function exponent2(k, n, inverse) {
          var x = (inverse ? 2 : -2) * Math.PI * (k / n);
          var real4 = Math.cos(x);
          var imag3 = Math.sin(x);
          return { real: real4, imag: imag3 };
        }
        var ARROW2 = "->";
        var ARROW_REGEX2 = /->/g;
        var COMMA2 = ",";
        var ELLIPSIS2 = "...";
        function decodeEinsumEquation2(equation, numTensors) {
          equation = equation.replace(/\s/g, "");
          var numArrows = (equation.length - equation.replace(ARROW_REGEX2, "").length) / ARROW2.length;
          if (numArrows < 1) {
            throw new Error("Equations without an arrow are not supported.");
          } else if (numArrows > 1) {
            throw new Error('Equation must contain exactly one arrow ("' + ARROW2 + '").');
          }
          var _a = equation.split(ARROW2), inputString = _a[0], outputString = _a[1];
          assert2(inputString.indexOf(ELLIPSIS2) === -1, function() {
            return 'The ellipsis notation ("' + ELLIPSIS2 + '") is not supported yet.';
          });
          var inputTerms = inputString.split(COMMA2);
          var numInputs = inputTerms.length;
          if (numTensors !== numInputs) {
            throw new Error("Expected " + numInputs + " input tensors, received " + numTensors);
          }
          if (numInputs > 2) {
            throw new Error("Support for more than 2 input tensors is not implemented yet.");
          }
          var allDims = [];
          var _loop_1 = function(i2) {
            var dimName2 = outputString[i2];
            if (!inputTerms.some(function(inputTerm) {
              return inputTerm.indexOf(dimName2) !== -1;
            })) {
              throw new Error("Output subscripts contain the label " + dimName2 + " not present in the input subscripts.");
            }
            if (allDims.indexOf(dimName2) === -1) {
              allDims.push(dimName2);
            }
          };
          for (var i = 0; i < outputString.length; ++i) {
            _loop_1(i);
          }
          for (var i = 0; i < inputString.length; ++i) {
            var dimName = inputString[i];
            if (allDims.indexOf(dimName) === -1 && dimName !== COMMA2) {
              allDims.push(dimName);
            }
          }
          var idDims = new Array(inputTerms.length);
          for (var i = 0; i < numInputs; ++i) {
            if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
              throw new Error("Found duplicate axes in input component " + inputTerms[i] + ". Support for duplicate axes in input is not implemented yet.");
            }
            idDims[i] = [];
            for (var j = 0; j < inputTerms[i].length; ++j) {
              idDims[i].push(allDims.indexOf(inputTerms[i][j]));
            }
          }
          var numDims = allDims.length;
          var numOutDims = outputString.length;
          var summedDims = [];
          for (var i = numOutDims; i < numDims; ++i) {
            summedDims.push(i);
          }
          return { allDims, summedDims, idDims };
        }
        function getEinsumPermutation2(nDims, idDims) {
          var permutationIndices = new Array(nDims);
          permutationIndices.fill(-1);
          for (var i = 0; i < idDims.length; ++i) {
            permutationIndices[idDims[i]] = i;
          }
          var expandDims4 = [];
          for (var i = 0; i < nDims; ++i) {
            if (permutationIndices[i] === -1) {
              expandDims4.push(i);
            }
          }
          permutationIndices = permutationIndices.filter(function(d) {
            return d !== -1;
          });
          return { permutationIndices, expandDims: expandDims4 };
        }
        function checkEinsumDimSizes2(nDims, idDims, tensors) {
          var dimSizes = new Array(nDims);
          var _loop_2 = function(i2) {
            var shape = tensors[i2].shape;
            var _loop_3 = function(j2) {
              if (dimSizes[idDims[i2][j2]] === void 0) {
                dimSizes[idDims[i2][j2]] = shape[j2];
              } else {
                assert2(dimSizes[idDims[i2][j2]] === shape[j2], function() {
                  return "Expected dimension " + dimSizes[idDims[i2][j2]] + " at axis " + j2 + " " + ("of input shaped " + JSON.stringify(shape) + ", ") + ("but got dimension " + shape[j2]);
                });
              }
            };
            for (var j = 0; j < idDims[i2].length; ++j) {
              _loop_3(j);
            }
          };
          for (var i = 0; i < tensors.length; ++i) {
            _loop_2(i);
          }
        }
        function getEinsumComputePath2(summedDims, idDims) {
          var path = summedDims;
          var steps = [];
          var nSteps = 0;
          if (summedDims.length === 0) {
            path.push(-1);
          }
          nSteps = summedDims.length + 1;
          for (var i = 0; i < nSteps; ++i) {
            steps.push([]);
          }
          var computedTermIndices = [];
          for (var i = 0; i < path.length; ++i) {
            var summedDim = path[i];
            var termIndices = findTermsWithDim2(idDims, summedDim);
            for (var _i = 0, termIndices_1 = termIndices; _i < termIndices_1.length; _i++) {
              var termIndex = termIndices_1[_i];
              if (computedTermIndices.indexOf(termIndex) === -1) {
                steps[i].push(termIndex);
                computedTermIndices.push(termIndex);
              }
            }
          }
          return { path, steps };
        }
        function isIdentityPermutation2(perm) {
          return perm.every(function(dim, index2) {
            return dim === index2;
          });
        }
        function findTermsWithDim2(idDims, dim) {
          var termIndices = [];
          for (var i = 0; i < idDims.length; ++i) {
            if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
              termIndices.push(i);
            }
          }
          return termIndices;
        }
        function prepareSplitSize2(x, numOrSizeSplits, axis) {
          if (axis === void 0) {
            axis = 0;
          }
          var splitSizes = [];
          if (typeof numOrSizeSplits === "number") {
            assert2(x.shape[axis] % numOrSizeSplits === 0, function() {
              return "Number of splits must evenly divide the axis.";
            });
            splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
          } else {
            var numOfNegs = numOrSizeSplits.reduce(function(count, value) {
              if (value === -1) {
                count += 1;
              }
              return count;
            }, 0);
            assert2(numOfNegs <= 1, function() {
              return "There should be only one negative value in split array.";
            });
            var negIndex = numOrSizeSplits.indexOf(-1);
            if (negIndex !== -1) {
              var total = numOrSizeSplits.reduce(function(a, b) {
                return b > 0 ? a + b : a;
              });
              numOrSizeSplits[negIndex] = x.shape[axis] - total;
            }
            assert2(x.shape[axis] === numOrSizeSplits.reduce(function(a, b) {
              return a + b;
            }), function() {
              return "The sum of sizes must match the size of the axis dimension.";
            });
            splitSizes = numOrSizeSplits;
          }
          return splitSizes;
        }
        function segOpComputeOptimalWindowSize2(inSize, numSegments) {
          var done = false;
          var res;
          if (inSize <= PARALLELIZE_THRESHOLD2) {
            res = inSize;
            done = true;
          } else {
            res = nearestDivisor2(inSize, Math.floor(Math.sqrt(inSize)));
          }
          while (!done) {
            if (res > numSegments || res === inSize) {
              done = true;
            } else {
              res = nearestDivisor2(inSize, res + 1);
            }
          }
          return res;
        }
        function computeOutShape$2(aShape, axis, numSegments) {
          var outShape = [];
          var rank = aShape.length;
          for (var dim = 0; dim < rank; dim++) {
            if (dim !== axis) {
              outShape.push(aShape[dim]);
            } else {
              outShape.push(numSegments);
            }
          }
          return outShape;
        }
        function collectGatherOpShapeInfo2(x, indices, axis, batchDims) {
          var indicesRank = indices.shape.length;
          var xRank = x.shape.length;
          if (batchDims !== 0) {
            if (batchDims < -indicesRank || batchDims > indicesRank) {
              throw new Error("Expect batchDims in the range of [-" + indicesRank + ", " + indicesRank + "], but got " + batchDims);
            }
          }
          if (batchDims < 0) {
            batchDims += indicesRank;
          }
          if (batchDims > xRank) {
            throw new Error("batchDims (" + batchDims + ") must be less than rank(x) (\n    " + xRank + ").");
          }
          if (axis < batchDims) {
            throw new Error("batchDims (" + batchDims + ") must be less than or equal to axis (" + axis + ").");
          }
          for (var i = 0; i < batchDims; ++i) {
            if (x.shape[i] !== indices.shape[i]) {
              throw new Error("x.shape[" + i + "]: " + x.shape[i] + " should be equal to indices.shape[" + i + "]: " + indices.shape[i] + ".");
            }
          }
          var dimSize = x.shape[axis];
          var outputShape = [];
          var batchSize = 1;
          var outerSize = 1;
          var sliceSize = 1;
          for (var i = 0; i < batchDims; ++i) {
            outputShape.push(x.shape[i]);
            batchSize *= x.shape[i];
          }
          for (var i = batchDims; i < axis; i++) {
            outputShape.push(x.shape[i]);
            outerSize *= x.shape[i];
          }
          for (var i = batchDims; i < indicesRank; i++) {
            outputShape.push(indices.shape[i]);
          }
          for (var i = axis + 1; i < xRank; i++) {
            outputShape.push(x.shape[i]);
            sliceSize *= x.shape[i];
          }
          return { batchSize, sliceSize, outerSize, dimSize, outputShape };
        }
        var segment_util = {
          __proto__: null,
          segOpComputeOptimalWindowSize: segOpComputeOptimalWindowSize2,
          computeOutShape: computeOutShape$2,
          collectGatherOpShapeInfo: collectGatherOpShapeInfo2
        };
        function fromUint8ToStringArray2(vals) {
          try {
            return vals.map(function(val) {
              return decodeString2(val);
            });
          } catch (err) {
            throw new Error("Failed to decode encoded string bytes into utf-8, error: " + err);
          }
        }
        function fromStringArrayToUint82(strings) {
          return strings.map(function(s) {
            return encodeString2(s);
          });
        }
        var backend_util = {
          __proto__: null,
          slice_util,
          segment_util,
          fromUint8ToStringArray: fromUint8ToStringArray2,
          fromStringArrayToUint8: fromStringArrayToUint82,
          upcastType: upcastType2,
          axesAreInnerMostDims: axesAreInnerMostDims2,
          combineLocations: combineLocations2,
          computeOutAndReduceShapes: computeOutAndReduceShapes2,
          expandShapeToKeepDim: expandShapeToKeepDim2,
          assertAxesAreInnerMostDims: assertAxesAreInnerMostDims2,
          getAxesPermutation: getAxesPermutation2,
          getUndoAxesPermutation: getUndoAxesPermutation2,
          getInnerMostAxes: getInnerMostAxes2,
          getBroadcastDims: getBroadcastDims3,
          getReductionAxes: getReductionAxes2,
          assertAndGetBroadcastShape: assertAndGetBroadcastShape2,
          assertParamsConsistent: assertParamsConsistent2,
          computeOutShape: computeOutShape$1,
          computeDilation2DInfo: computeDilation2DInfo2,
          computePool2DInfo: computePool2DInfo2,
          computePool3DInfo: computePool3DInfo2,
          computeConv2DInfo: computeConv2DInfo2,
          computeConv3DInfo: computeConv3DInfo2,
          computeDefaultPad: computeDefaultPad2,
          tupleValuesAreOne: tupleValuesAreOne2,
          eitherStridesOrDilationsAreOne: eitherStridesOrDilationsAreOne2,
          convertConv2DDataFormat: convertConv2DDataFormat2,
          getFusedDyActivation: getFusedDyActivation2,
          getFusedBiasGradient: getFusedBiasGradient2,
          applyActivation: applyActivation2,
          shouldFuse: shouldFuse2,
          PARALLELIZE_THRESHOLD: PARALLELIZE_THRESHOLD2,
          computeOptimalWindowSize: computeOptimalWindowSize2,
          getImageCenter: getImageCenter2,
          getReshaped: getReshaped2,
          getPermuted: getPermuted2,
          getReshapedPermuted: getReshapedPermuted2,
          getSliceBeginCoords: getSliceBeginCoords2,
          getSliceSize: getSliceSize2,
          prepareAndValidate: prepareAndValidate2,
          validateUpdateShape: validateUpdateShape2,
          validateInput: validateInput2,
          calculateShapes: calculateShapes2,
          SELU_SCALEALPHA: SELU_SCALEALPHA2,
          SELU_SCALE: SELU_SCALE2,
          ERF_P: ERF_P2,
          ERF_A1: ERF_A12,
          ERF_A2: ERF_A22,
          ERF_A3: ERF_A32,
          ERF_A4: ERF_A42,
          ERF_A5: ERF_A52,
          warn: warn2,
          log: log$1,
          mergeRealAndImagArrays: mergeRealAndImagArrays2,
          splitRealAndImagArrays: splitRealAndImagArrays2,
          complexWithEvenIndex: complexWithEvenIndex2,
          complexWithOddIndex: complexWithOddIndex2,
          getComplexWithIndex: getComplexWithIndex2,
          assignToTypedArray: assignToTypedArray2,
          exponents: exponents2,
          exponent: exponent2,
          decodeEinsumEquation: decodeEinsumEquation2,
          getEinsumPermutation: getEinsumPermutation2,
          checkEinsumDimSizes: checkEinsumDimSizes2,
          getEinsumComputePath: getEinsumComputePath2,
          isIdentityPermutation: isIdentityPermutation2,
          prepareSplitSize: prepareSplitSize2
        };
        var kernel_impls = {
          __proto__: null,
          nonMaxSuppressionV3Impl: nonMaxSuppressionV3Impl3,
          nonMaxSuppressionV4Impl: nonMaxSuppressionV4Impl3,
          nonMaxSuppressionV5Impl: nonMaxSuppressionV5Impl3,
          whereImpl: whereImpl3
        };
        exports.Abs = Abs2;
        exports.Acos = Acos2;
        exports.Acosh = Acosh2;
        exports.AdadeltaOptimizer = AdadeltaOptimizer;
        exports.AdagradOptimizer = AdagradOptimizer;
        exports.AdamOptimizer = AdamOptimizer;
        exports.AdamaxOptimizer = AdamaxOptimizer;
        exports.Add = Add2;
        exports.AddN = AddN2;
        exports.All = All2;
        exports.Any = Any2;
        exports.ArgMax = ArgMax2;
        exports.ArgMin = ArgMin2;
        exports.Asin = Asin2;
        exports.Asinh = Asinh2;
        exports.Atan = Atan3;
        exports.Atan2 = Atan22;
        exports.Atanh = Atanh2;
        exports.AvgPool = AvgPool2;
        exports.AvgPool3D = AvgPool3D2;
        exports.AvgPool3DGrad = AvgPool3DGrad2;
        exports.AvgPoolGrad = AvgPoolGrad2;
        exports.BatchMatMul = BatchMatMul2;
        exports.BatchToSpaceND = BatchToSpaceND2;
        exports.Bincount = Bincount2;
        exports.BroadcastTo = BroadcastTo;
        exports.Cast = Cast2;
        exports.Ceil = Ceil2;
        exports.ClipByValue = ClipByValue2;
        exports.Complex = Complex2;
        exports.ComplexAbs = ComplexAbs2;
        exports.Concat = Concat2;
        exports.Conv2D = Conv2D2;
        exports.Conv2DBackpropFilter = Conv2DBackpropFilter2;
        exports.Conv2DBackpropInput = Conv2DBackpropInput2;
        exports.Conv3D = Conv3D2;
        exports.Conv3DBackpropFilterV2 = Conv3DBackpropFilterV22;
        exports.Conv3DBackpropInputV2 = Conv3DBackpropInputV22;
        exports.Cos = Cos2;
        exports.Cosh = Cosh2;
        exports.CropAndResize = CropAndResize2;
        exports.Cumsum = Cumsum2;
        exports.DataStorage = DataStorage2;
        exports.DenseBincount = DenseBincount2;
        exports.DepthToSpace = DepthToSpace2;
        exports.DepthwiseConv2dNative = DepthwiseConv2dNative2;
        exports.DepthwiseConv2dNativeBackpropFilter = DepthwiseConv2dNativeBackpropFilter2;
        exports.DepthwiseConv2dNativeBackpropInput = DepthwiseConv2dNativeBackpropInput2;
        exports.Diag = Diag2;
        exports.Dilation2D = Dilation2D2;
        exports.Dilation2DBackpropFilter = Dilation2DBackpropFilter;
        exports.Dilation2DBackpropInput = Dilation2DBackpropInput;
        exports.Einsum = Einsum2;
        exports.Elu = Elu2;
        exports.EluGrad = EluGrad2;
        exports.Environment = Environment2;
        exports.Equal = Equal2;
        exports.Erf = Erf2;
        exports.Exp = Exp2;
        exports.ExpandDims = ExpandDims2;
        exports.Expm1 = Expm12;
        exports.FFT = FFT2;
        exports.Fill = Fill2;
        exports.FlipLeftRight = FlipLeftRight2;
        exports.Floor = Floor2;
        exports.FloorDiv = FloorDiv2;
        exports.FromPixels = FromPixels2;
        exports.FusedBatchNorm = FusedBatchNorm2;
        exports.FusedConv2D = FusedConv2D2;
        exports.FusedDepthwiseConv2D = FusedDepthwiseConv2D2;
        exports.GatherNd = GatherNd2;
        exports.GatherV2 = GatherV22;
        exports.Greater = Greater2;
        exports.GreaterEqual = GreaterEqual2;
        exports.IFFT = IFFT2;
        exports.Identity = Identity2;
        exports.Imag = Imag2;
        exports.IsFinite = IsFinite2;
        exports.IsInf = IsInf2;
        exports.IsNan = IsNan2;
        exports.KernelBackend = KernelBackend2;
        exports.LRN = LRN2;
        exports.LRNGrad = LRNGrad2;
        exports.LeakyRelu = LeakyRelu2;
        exports.Less = Less2;
        exports.LessEqual = LessEqual2;
        exports.LinSpace = LinSpace2;
        exports.Log = Log2;
        exports.Log1p = Log1p2;
        exports.LogSoftmax = LogSoftmax;
        exports.LogicalAnd = LogicalAnd2;
        exports.LogicalNot = LogicalNot2;
        exports.LogicalOr = LogicalOr2;
        exports.Max = Max2;
        exports.MaxPool = MaxPool2;
        exports.MaxPool3D = MaxPool3D2;
        exports.MaxPool3DGrad = MaxPool3DGrad2;
        exports.MaxPoolGrad = MaxPoolGrad2;
        exports.MaxPoolWithArgmax = MaxPoolWithArgmax2;
        exports.Maximum = Maximum2;
        exports.Mean = Mean2;
        exports.Min = Min2;
        exports.Minimum = Minimum2;
        exports.MirrorPad = MirrorPad2;
        exports.Mod = Mod2;
        exports.MomentumOptimizer = MomentumOptimizer;
        exports.Multinomial = Multinomial2;
        exports.Multiply = Multiply2;
        exports.Neg = Neg2;
        exports.NonMaxSuppressionV3 = NonMaxSuppressionV32;
        exports.NonMaxSuppressionV4 = NonMaxSuppressionV42;
        exports.NonMaxSuppressionV5 = NonMaxSuppressionV52;
        exports.NotEqual = NotEqual2;
        exports.OP_SCOPE_SUFFIX = OP_SCOPE_SUFFIX2;
        exports.OneHot = OneHot2;
        exports.OnesLike = OnesLike2;
        exports.Optimizer = Optimizer;
        exports.Pack = Pack2;
        exports.PadV2 = PadV22;
        exports.Pool = Pool;
        exports.Pow = Pow2;
        exports.Prelu = Prelu2;
        exports.Prod = Prod2;
        exports.RMSPropOptimizer = RMSPropOptimizer;
        exports.Range = Range2;
        exports.Real = Real2;
        exports.RealDiv = RealDiv2;
        exports.Reciprocal = Reciprocal2;
        exports.Relu = Relu2;
        exports.Relu6 = Relu62;
        exports.Reshape = Reshape2;
        exports.ResizeBilinear = ResizeBilinear2;
        exports.ResizeBilinearGrad = ResizeBilinearGrad2;
        exports.ResizeNearestNeighbor = ResizeNearestNeighbor2;
        exports.ResizeNearestNeighborGrad = ResizeNearestNeighborGrad2;
        exports.Reverse = Reverse2;
        exports.RotateWithOffset = RotateWithOffset2;
        exports.Round = Round2;
        exports.Rsqrt = Rsqrt2;
        exports.SGDOptimizer = SGDOptimizer;
        exports.ScatterNd = ScatterNd2;
        exports.Select = Select2;
        exports.Selu = Selu2;
        exports.Sigmoid = Sigmoid2;
        exports.Sign = Sign2;
        exports.Sin = Sin2;
        exports.Sinh = Sinh2;
        exports.Slice = Slice2;
        exports.Softmax = Softmax2;
        exports.Softplus = Softplus2;
        exports.SpaceToBatchND = SpaceToBatchND2;
        exports.SparseFillEmptyRows = SparseFillEmptyRows2;
        exports.SparseReshape = SparseReshape2;
        exports.SparseToDense = SparseToDense2;
        exports.SplitV = SplitV2;
        exports.Sqrt = Sqrt2;
        exports.Square = Square2;
        exports.SquaredDifference = SquaredDifference2;
        exports.Step = Step2;
        exports.StridedSlice = StridedSlice2;
        exports.Sub = Sub2;
        exports.Sum = Sum2;
        exports.Tan = Tan2;
        exports.Tanh = Tanh2;
        exports.Tensor = Tensor3;
        exports.TensorBuffer = TensorBuffer2;
        exports.Tile = Tile2;
        exports.TopK = TopK2;
        exports.Transform = Transform2;
        exports.Transpose = Transpose2;
        exports.Unique = Unique2;
        exports.Unpack = Unpack2;
        exports.UnsortedSegmentSum = UnsortedSegmentSum2;
        exports.Variable = Variable2;
        exports.ZerosLike = ZerosLike2;
        exports._FusedMatMul = _FusedMatMul2;
        exports.abs = abs2;
        exports.acos = acos2;
        exports.acosh = acosh2;
        exports.add = add$1;
        exports.addN = addN2;
        exports.all = all2;
        exports.any = any2;
        exports.argMax = argMax3;
        exports.argMin = argMin2;
        exports.asin = asin2;
        exports.asinh = asinh2;
        exports.atan = atan3;
        exports.atan2 = atan22;
        exports.atanh = atanh2;
        exports.avgPool = avgPool2;
        exports.avgPool3d = avgPool3d;
        exports.backend = backend;
        exports.backend_util = backend_util;
        exports.basicLSTMCell = basicLSTMCell;
        exports.batchNorm = batchNorm2;
        exports.batchNorm2d = batchNorm2d;
        exports.batchNorm3d = batchNorm3d;
        exports.batchNorm4d = batchNorm4d;
        exports.batchToSpaceND = batchToSpaceND2;
        exports.bincount = bincount2;
        exports.booleanMaskAsync = booleanMaskAsync;
        exports.broadcastTo = broadcastTo;
        exports.browser = browser2;
        exports.buffer = buffer2;
        exports.cast = cast5;
        exports.ceil = ceil3;
        exports.clipByValue = clipByValue2;
        exports.clone = clone2;
        exports.complex = complex4;
        exports.concat = concat3;
        exports.concat1d = concat1d;
        exports.concat2d = concat2d;
        exports.concat3d = concat3d;
        exports.concat4d = concat4d;
        exports.conv1d = conv1d;
        exports.conv2d = conv2d2;
        exports.conv2dTranspose = conv2dTranspose;
        exports.conv3d = conv3d;
        exports.conv3dTranspose = conv3dTranspose;
        exports.copyRegisteredKernels = copyRegisteredKernels;
        exports.cos = cos2;
        exports.cosh = cosh2;
        exports.cosineWindow = cosineWindow;
        exports.cumsum = cumsum2;
        exports.customGrad = customGrad;
        exports.denseBincount = denseBincount2;
        exports.deprecationWarn = deprecationWarn2;
        exports.depthToSpace = depthToSpace2;
        exports.depthwiseConv2d = depthwiseConv2d;
        exports.device_util = device_util2;
        exports.diag = diag2;
        exports.dilation2d = dilation2d;
        exports.disableDeprecationWarnings = disableDeprecationWarnings;
        exports.dispose = dispose;
        exports.disposeVariables = disposeVariables;
        exports.div = div2;
        exports.divNoNan = divNoNan;
        exports.dot = dot;
        exports.dropout = dropout;
        exports.einsum = einsum2;
        exports.elu = elu3;
        exports.enableDebugMode = enableDebugMode;
        exports.enableProdMode = enableProdMode;
        exports.enclosingPowerOfTwo = enclosingPowerOfTwo;
        exports.engine = engine2;
        exports.env = env2;
        exports.equal = equal3;
        exports.erf = erf2;
        exports.exp = exp3;
        exports.expandDims = expandDims3;
        exports.expm1 = expm13;
        exports.eye = eye;
        exports.fft = fft2;
        exports.fill = fill2;
        exports.findBackend = findBackend;
        exports.findBackendFactory = findBackendFactory;
        exports.floor = floor3;
        exports.floorDiv = floorDiv2;
        exports.fused = fused_ops;
        exports.gather = gather;
        exports.gatherND = gatherND;
        exports.gather_util = gather_nd_util;
        exports.getBackend = getBackend;
        exports.getGradient = getGradient2;
        exports.getKernel = getKernel2;
        exports.getKernelsForBackend = getKernelsForBackend2;
        exports.grad = grad;
        exports.grads = grads;
        exports.greater = greater3;
        exports.greaterEqual = greaterEqual3;
        exports.ifft = ifft2;
        exports.imag = imag2;
        exports.image = image2;
        exports.inTopKAsync = inTopKAsync;
        exports.io = io;
        exports.irfft = irfft;
        exports.isFinite = isFinite$1;
        exports.isInf = isInf2;
        exports.isNaN = isNaN$1;
        exports.keep = keep;
        exports.kernel_impls = kernel_impls;
        exports.leakyRelu = leakyRelu3;
        exports.less = less3;
        exports.lessEqual = lessEqual3;
        exports.linalg = linalg;
        exports.linspace = linspace;
        exports.localResponseNormalization = localResponseNormalization;
        exports.log = log4;
        exports.log1p = log1p2;
        exports.logSigmoid = logSigmoid;
        exports.logSoftmax = logSoftmax;
        exports.logSumExp = logSumExp;
        exports.logicalAnd = logicalAnd2;
        exports.logicalNot = logicalNot2;
        exports.logicalOr = logicalOr2;
        exports.logicalXor = logicalXor;
        exports.losses = losses;
        exports.matMul = matMul;
        exports.math = math;
        exports.max = max2;
        exports.maxPool = maxPool2;
        exports.maxPool3d = maxPool3d2;
        exports.maxPoolWithArgmax = maxPoolWithArgmax;
        exports.maximum = maximum3;
        exports.mean = mean;
        exports.memory = memory;
        exports.meshgrid = meshgrid;
        exports.min = min2;
        exports.minimum = minimum3;
        exports.mirrorPad = mirrorPad;
        exports.mod = mod3;
        exports.moments = moments;
        exports.movingAverage = movingAverage;
        exports.mul = mul3;
        exports.multiRNNCell = multiRNNCell;
        exports.multinomial = multinomial2;
        exports.neg = neg2;
        exports.nextFrame = nextFrame;
        exports.norm = norm;
        exports.notEqual = notEqual3;
        exports.oneHot = oneHot2;
        exports.ones = ones$1;
        exports.onesLike = onesLike2;
        exports.op = op2;
        exports.outerProduct = outerProduct;
        exports.pad = pad;
        exports.pad1d = pad1d;
        exports.pad2d = pad2d;
        exports.pad3d = pad3d2;
        exports.pad4d = pad4d;
        exports.pool = pool;
        exports.pow = pow2;
        exports.prelu = prelu3;
        exports.print = print2;
        exports.prod = prod2;
        exports.profile = profile;
        exports.rand = rand;
        exports.randomGamma = randomGamma;
        exports.randomNormal = randomNormal;
        exports.randomUniform = randomUniform;
        exports.range = range2;
        exports.ready = ready;
        exports.real = real3;
        exports.reciprocal = reciprocal2;
        exports.registerBackend = registerBackend2;
        exports.registerGradient = registerGradient;
        exports.registerKernel = registerKernel2;
        exports.relu = relu3;
        exports.relu6 = relu63;
        exports.removeBackend = removeBackend;
        exports.reshape = reshape4;
        exports.reverse = reverse2;
        exports.reverse1d = reverse1d;
        exports.reverse2d = reverse2d;
        exports.reverse3d = reverse3d;
        exports.reverse4d = reverse4d;
        exports.rfft = rfft;
        exports.round = round$1;
        exports.rsqrt = rsqrt3;
        exports.scalar = scalar3;
        exports.scatterND = scatterND;
        exports.scatter_util = scatter_nd_util;
        exports.selu = selu2;
        exports.separableConv2d = separableConv2d;
        exports.serialization = serialization;
        exports.setBackend = setBackend;
        exports.setPlatform = setPlatform;
        exports.setdiff1dAsync = setdiff1dAsync;
        exports.sigmoid = sigmoid4;
        exports.sign = sign2;
        exports.signal = signal;
        exports.sin = sin2;
        exports.sinh = sinh2;
        exports.slice = slice2;
        exports.slice1d = slice1d;
        exports.slice2d = slice2d;
        exports.slice3d = slice3d;
        exports.slice4d = slice4d;
        exports.slice_util = slice_util;
        exports.softmax = softmax2;
        exports.softplus = softplus2;
        exports.spaceToBatchND = spaceToBatchND2;
        exports.sparse = sparse;
        exports.sparseToDense = sparseToDense2;
        exports.spectral = spectral2;
        exports.split = split2;
        exports.sqrt = sqrt2;
        exports.square = square2;
        exports.squaredDifference = squaredDifference3;
        exports.squeeze = squeeze2;
        exports.stack = stack;
        exports.step = step3;
        exports.stridedSlice = stridedSlice2;
        exports.sub = sub4;
        exports.sum = sum$1;
        exports.sumOutType = sumOutType2;
        exports.tan = tan2;
        exports.tanh = tanh$1;
        exports.tensor = tensor;
        exports.tensor1d = tensor1d;
        exports.tensor2d = tensor2d2;
        exports.tensor3d = tensor3d;
        exports.tensor4d = tensor4d;
        exports.tensor5d = tensor5d;
        exports.tensor6d = tensor6d;
        exports.tensor_util = tensor_util;
        exports.test_util = test_util;
        exports.tidy = tidy3;
        exports.tile = tile2;
        exports.time = time;
        exports.topk = topk;
        exports.train = train;
        exports.transpose = transpose2;
        exports.truncatedNormal = truncatedNormal;
        exports.unique = unique2;
        exports.unregisterGradient = unregisterGradient;
        exports.unregisterKernel = unregisterKernel;
        exports.unsortedSegmentSum = unsortedSegmentSum2;
        exports.unstack = unstack;
        exports.upcastType = upcastType2;
        exports.util = util12;
        exports.valueAndGrad = valueAndGrad;
        exports.valueAndGrads = valueAndGrads;
        exports.variable = variable;
        exports.variableGrads = variableGrads;
        exports.version_core = version;
        exports.where = where;
        exports.whereAsync = whereAsync;
        exports.zeros = zeros3;
        exports.zerosLike = zerosLike2;
      }
    });
  
    // node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js
    var require_tf_converter_node = __commonJS({
      "node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var tfOps = require_tf_core_node();
        var __assign2 = function() {
          __assign2 = Object.assign || function __assign3(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign2.apply(this, arguments);
        };
        function __awaiter2(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step3(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step3(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step3(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step3((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator2(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step3([n, v]);
            };
          }
          function step3(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        }
        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        }
        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        }
        var DataType;
        (function(DataType2) {
          DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
          DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
          DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
          DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
          DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
          DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
          DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
          DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
          DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
          DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
          DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
          DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
          DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
          DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
          DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
          DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
          DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
          DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
          DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
          DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
          DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
          DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
          DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
          DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
          DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
          DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
          DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
          DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
          DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
        })(DataType || (DataType = {}));
        var SaverDef;
        (function(SaverDef2) {
          var CheckpointFormatVersion;
          (function(CheckpointFormatVersion2) {
            CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
            CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
            CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
          })(CheckpointFormatVersion = SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
        })(SaverDef || (SaverDef = {}));
        var CUSTOM_OPS = {};
        function registerOp(name, opFunc) {
          var opMapper = {
            tfOpName: name,
            category: "custom",
            inputs: [],
            attrs: [],
            customExecutor: opFunc
          };
          CUSTOM_OPS[name] = opMapper;
        }
        function getRegisteredOp(name) {
          return CUSTOM_OPS[name];
        }
        function deregisterOp(name) {
          delete CUSTOM_OPS[name];
        }
        function getParamValue(paramName, node, tensorMap, context, resourceManager) {
          var inputParam = node.inputParams[paramName];
          if (inputParam && inputParam.inputIndexStart !== void 0) {
            var start = inputParam.inputIndexStart;
            var end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start + 1 : inputParam.inputIndexEnd;
            if (inputParam.type === "tensor") {
              return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);
            }
            if (inputParam.type === "tensors") {
              var inputs = node.inputNames.slice(start, end);
              return inputs.map(function(name) {
                return getTensor(name, tensorMap, context, resourceManager);
              });
            }
            var tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);
            var data = tensor.dataSync();
            return inputParam.type === "number" ? data[0] : tfOps.util.toNestedArray(tensor.shape, data);
          }
          var attrParam = node.attrParams[paramName];
          return attrParam && attrParam.value;
        }
        function getTensor(name, tensorsMap, context, resourceManager) {
          var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index2 = _a[1];
          if (resourceManager != null) {
            var tensor = resourceManager.getHashTableHandleByName(nodeName);
            if (tensor != null) {
              return tensor;
            }
          }
          var contextId = context.currentContextIds.find(function(contextId2) {
            return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
          });
          return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index2] : void 0;
        }
        function getTensorsForCurrentContenxt(name, tensorsMap, context) {
          return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];
        }
        function getNodeNameAndIndex(inputName, context) {
          var _a = __read(parseNodeName(inputName), 2), nodeName = _a[0], index2 = _a[1];
          return [
            getNodeNameWithContextId(nodeName, context && context.currentContextId),
            index2
          ];
        }
        function getNodeNameWithContextId(name, contextId) {
          return !!contextId ? name + "-" + contextId : name;
        }
        function parseNodeName(name) {
          var parts = name.split(":");
          if (parts.length === 1) {
            return [name, 0];
          }
          var nodeName = parts[0];
          return [nodeName, Number(parts[parts.length - 1])];
        }
        function getPadding(node, tensorMap, context) {
          var pad = getParamValue("pad", node, tensorMap, context);
          if (pad === "explicit") {
            pad = getParamValue("explicitPaddings", node, tensorMap, context);
            var explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
            for (var i = 0; i < 4; i++) {
              explicitPadding[i][0] = pad[i * 2];
              explicitPadding[i][1] = pad[i * 2 + 1];
            }
            return explicitPadding;
          }
          return pad;
        }
        function cloneTensor(tensor) {
          return tensor.kept ? tensor : tfOps.clone(tensor);
        }
        var json = [
          {
            "tfOpName": "Add",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "AddV2",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "AddN",
            "category": "arithmetic",
            "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }]
          },
          {
            "tfOpName": "BiasAdd",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "Sub",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "RealDiv",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Div",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "DivNoNan",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "FloorDiv",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Mul",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Maximum",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Minimum",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Pow",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "SquaredDifference",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Mod",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "FloorMod",
            "category": "arithmetic",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "T",
              "name": "dtype",
              "type": "dtype",
              "notSupported": true
            }]
          }
        ];
        var arithmetic = {
          __proto__: null,
          json
        };
        var json$1 = [
          {
            "tfOpName": "Abs",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Acos",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Asin",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Atan",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Atan2",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "y", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Ceil",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "ClipByValue",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "clipValueMin", "type": "number" },
              { "start": 2, "name": "clipValueMax", "type": "number" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Complex",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "real", "type": "tensor" },
              { "start": 1, "name": "imag", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "ComplexAbs",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Cos",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Cosh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Elu",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Exp",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Floor",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Log",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Imag",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "outputType",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "Neg",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Real",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "outputType",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "Prelu",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "alpha", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Relu",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Relu6",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Selu",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Sigmoid",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Sin",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Sinh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Sqrt",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Rsqrt",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Square",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Tan",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Tanh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Sign",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Round",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Expm1",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Log1p",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Reciprocal",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Softplus",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Asinh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Acosh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Atanh",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Erf",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Prod",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axes", "type": "number[]" }
            ],
            "attrs": [
              {
                "tfName": "keep_dims",
                "name": "keepDims",
                "type": "bool",
                "notSupported": true
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "LeakyRelu",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "alpha",
                "name": "alpha",
                "type": "number",
                "defaultValue": 0.2
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "IsNan",
            "category": "basic_math",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "T",
              "name": "dtype",
              "type": "dtype",
              "notSupported": true
            }]
          }
        ];
        var basicMath = {
          __proto__: null,
          json: json$1
        };
        var json$2 = [
          {
            "tfOpName": "EmptyTensorList",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "elementShape", "type": "shape" },
              { "start": 1, "name": "maxNumElements", "type": "number" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "LoopCond",
            "category": "control",
            "inputs": [{ "start": 0, "name": "pred", "type": "tensor" }]
          },
          {
            "tfOpName": "Switch",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "data", "type": "tensor" },
              { "start": 1, "name": "pred", "type": "tensor" }
            ]
          },
          {
            "tfOpName": "Merge",
            "category": "control",
            "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }]
          },
          {
            "tfOpName": "Enter",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              { "tfName": "frame_name", "name": "frameName", "type": "string" },
              { "tfName": "is_constant", "name": "isConstant", "type": "bool" }
            ]
          },
          {
            "tfOpName": "Exit",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "NextIteration",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "TensorArrayV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "size", "type": "number" }
            ],
            "attrs": [
              { "tfName": "dtype", "name": "dtype", "type": "dtype" },
              { "tfName": "element_shape", "name": "elementShape", "type": "shape" },
              { "tfName": "dynamic_size", "name": "dynamicSize", "type": "bool" },
              { "tfName": "clear_after_read", "name": "clearAfterRead", "type": "bool" },
              {
                "tfName": "identical_element_shapes",
                "name": "identicalElementShapes",
                "type": "bool"
              },
              { "tfName": "tensor_array_name", "name": "name", "type": "string" }
            ]
          },
          {
            "tfOpName": "TensorArrayWriteV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "index", "type": "number" },
              { "start": 2, "name": "tensor", "type": "tensor" },
              { "start": 3, "name": "flowIn", "type": "number" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "TensorArrayReadV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "index", "type": "number" },
              { "start": 2, "name": "flowIn", "type": "number" }
            ],
            "attrs": [{
              "tfName": "dtype",
              "name": "dtype",
              "type": "dtype",
              "notSupported": true
            }]
          },
          {
            "tfOpName": "TensorArrayGatherV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "number[]" },
              { "start": 2, "name": "flowIn", "type": "number" }
            ],
            "attrs": [
              { "tfName": "dtype", "name": "dtype", "type": "dtype" },
              { "tfName": "element_shape", "name": "elementShape", "type": "shape" }
            ]
          },
          {
            "tfOpName": "TensorArrayScatterV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "number[]" },
              { "start": 2, "name": "tensor", "type": "tensor" },
              { "start": 3, "name": "flowIn", "type": "number" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorArrayConcatV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "flowIn", "type": "number" }
            ],
            "attrs": [
              { "tfName": "dtype", "name": "dtype", "type": "dtype" },
              {
                "tfName": "element_shape_except0",
                "name": "elementShapeExcept0",
                "type": "shape",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "TensorArraySplitV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "tensor", "type": "tensor" },
              { "start": 2, "name": "lengths", "type": "number[]" },
              { "start": 3, "name": "flowIn", "type": "number" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorArraySizeV3",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorArrayId", "type": "tensor" },
              { "start": 1, "name": "flowIn", "type": "number" }
            ]
          },
          {
            "tfOpName": "TensorArrayCloseV3",
            "category": "control",
            "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }]
          },
          {
            "tfOpName": "StatelessIf",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "cond", "type": "tensor" },
              { "start": 1, "end": 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "then_branch", "name": "thenBranch", "type": "func" },
              { "tfName": "else_branch", "name": "elseBranch", "type": "func" }
            ]
          },
          {
            "tfOpName": "If",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "cond", "type": "tensor" },
              { "start": 1, "end": 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "then_branch", "name": "thenBranch", "type": "func" },
              { "tfName": "else_branch", "name": "elseBranch", "type": "func" }
            ]
          },
          {
            "tfOpName": "StatelessWhile",
            "category": "control",
            "inputs": [
              { "start": 0, "end": 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "cond", "name": "cond", "type": "func" },
              { "tfName": "body", "name": "body", "type": "func" }
            ]
          },
          {
            "tfOpName": "While",
            "category": "control",
            "inputs": [
              { "start": 0, "end": 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "cond", "name": "cond", "type": "func" },
              { "tfName": "body", "name": "body", "type": "func" }
            ]
          },
          {
            "tfOpName": "TensorListScatter",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "number[]" },
              { "start": 2, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListScatterV2",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "number[]" },
              { "start": 2, "name": "elementShape", "type": "shape" },
              { "start": 3, "name": "numElements", "type": "number" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListGather",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "number[]" },
              { "start": 2, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListGetItem",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "index", "type": "number" },
              { "start": 2, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListSetItem",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "index", "type": "number" },
              { "start": 2, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListReserve",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "elementShape", "type": "shape" },
              { "start": 1, "name": "numElements", "type": "number" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListFromTensor",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" },
              { "start": 1, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListStack",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [
              { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" },
              { "tfName": "num_elements", "name": "numElements", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "TensorListSplit",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" },
              { "start": 1, "name": "elementShape", "type": "shape" },
              { "start": 2, "name": "lengths", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListConcat",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "element_shape", "name": "elementShape", "type": "shape" },
              { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "TensorListPopBack",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "elementShape", "type": "shape" }
            ],
            "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }]
          },
          {
            "tfOpName": "TensorListPushBack",
            "category": "control",
            "inputs": [
              { "start": 0, "name": "tensorListId", "type": "tensor" },
              { "start": 1, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }
            ]
          }
        ];
        var control = {
          __proto__: null,
          json: json$2
        };
        var json$3 = [
          {
            "tfOpName": "AvgPool",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              },
              { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "MaxPool",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              },
              { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": [],
                "notSupported": true
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "MaxPoolWithArgmax",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
              {
                "tfName": "include_batch_in_index",
                "name": "includeBatchInIndex",
                "type": "bool"
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "AvgPool3D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              },
              { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "MaxPool3D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              },
              { "tfName": "ksize", "name": "kernelSize", "type": "number[]" },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Conv1D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "stride", "name": "stride", "type": "number" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NWC"
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              {
                "tfName": "dilation",
                "name": "dilation",
                "type": "number",
                "defaultValue": 1
              }
            ]
          },
          {
            "tfOpName": "Conv2D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              { "tfName": "useCudnnOnGpu", "name": "useCudnnOnGpu", "type": "bool" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              },
              { "tfName": "dilations", "name": "dilations", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "_FusedConv2D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" },
              { "start": 2, end: 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "num_args", "name": "numArgs", "type": "number" },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              },
              {
                "tfName": "use_cudnn_on_gpu",
                "name": "useCudnnOnGpu",
                "type": "bool",
                "defaultValue": true
              },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              {
                "tfName": "dilations",
                "name": "dilations",
                "type": "number[]",
                "defaultValue": [1, 1, 1, 1]
              },
              {
                "tfName": "fused_ops",
                "name": "fusedOps",
                "type": "string[]",
                "defaultValue": []
              },
              {
                "tfName": "epsilon",
                "name": "epsilon",
                "type": "number",
                "defaultValue": 1e-4
              },
              {
                "tfName": "leakyrelu_alpha",
                "name": "leakyreluAlpha",
                "type": "number"
              }
            ]
          },
          {
            "tfOpName": "Conv2DBackpropInput",
            "category": "convolution",
            "inputs": [
              { "start": 2, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" },
              { "start": 0, "name": "outputShape", "type": "number[]" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              },
              {
                "tfName": "dilations",
                "name": "dilations",
                "type": "number[]",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "DepthwiseConv2d",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "input", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              },
              { "tfName": "dilations", "name": "dilations", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "DepthwiseConv2dNative",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "input", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              },
              { "tfName": "dilations", "name": "dilations", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "FusedDepthwiseConv2dNative",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" },
              { "start": 2, end: 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "num_args", "name": "numArgs", "type": "number" },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              {
                "tfName": "dilations",
                "name": "dilations",
                "type": "number[]",
                "defaultValue": [1, 1, 1, 1]
              },
              {
                "tfName": "fused_ops",
                "name": "fusedOps",
                "type": "string[]",
                "defaultValue": []
              },
              {
                "tfName": "explicit_paddings",
                "name": "explicitPaddings",
                "type": "number[]",
                "defaultValue": []
              }
            ]
          },
          {
            "tfOpName": "Conv3D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "defaultValue": "NHWC"
              },
              { "tfName": "dilations", "name": "dilations", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "Dilation2D",
            "category": "convolution",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "filter", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "strides", "name": "strides", "type": "number[]" },
              { "tfName": "rates", "name": "dilations", "type": "number[]" },
              { "tfName": "padding", "name": "pad", "type": "string" }
            ]
          }
        ];
        var convolution = {
          __proto__: null,
          json: json$3
        };
        var json$4 = [
          {
            "tfOpName": "Fill",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "shape", "type": "number[]" },
              { "start": 1, "name": "value", "type": "number" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "LinSpace",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "start", "type": "number" },
              { "start": 1, "name": "stop", "type": "number" },
              { "start": 2, "name": "num", "type": "number" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "OneHot",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "indices", "type": "tensor" },
              { "start": 1, "name": "depth", "type": "number" },
              { "start": 2, "name": "onValue", "type": "number", "defaultValue": 1 },
              { "start": 3, "name": "offValue", "type": "number", "defaultValue": 0 }
            ],
            "attrs": [
              {
                "tfName": "axis",
                "name": "axis",
                "type": "number",
                "notSupported": true
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Ones",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "shape", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "OnesLike",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "RandomUniform",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "shape", "type": "number[]" }
            ],
            "attrs": [
              {
                "tfName": "minval",
                "name": "minval",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "maxval",
                "name": "maxval",
                "type": "number",
                "defaultValue": 1
              },
              { "tfName": "dtype", "name": "dtype", "type": "dtype" },
              { "tfName": "seed", "name": "seed", "type": "number", "defaultValue": 0 },
              {
                "tfName": "seed2",
                "name": "seed2",
                "type": "number",
                "defaultValue": 0,
                "notSupported": true
              },
              { "tfName": "T", "name": "T", "type": "number", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Range",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "start", "type": "number" },
              { "start": 1, "name": "stop", "type": "number" },
              { "start": 2, "name": "step", "type": "number", "defaultValue": 0 }
            ],
            "attrs": [{ "tfName": "Tidx", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "TruncatedNormal",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "shape", "type": "number[]" }
            ],
            "attrs": [
              {
                "tfName": "means",
                "name": "mean",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "stddev",
                "name": "stdDev",
                "type": "number",
                "defaultValue": 1
              },
              { "tfName": "seed", "name": "seed", "type": "number" },
              {
                "tfName": "seed2",
                "name": "seed2",
                "type": "number",
                "defaultValue": 0,
                "notSupported": true
              },
              { "tfName": "dtype", "name": "dtype", "type": "dtype" },
              { "tfName": "T", "name": "T", "type": "number", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Zeros",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "shape", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "ZerosLike",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }]
          },
          {
            "tfOpName": "Multinomial",
            "category": "creation",
            "inputs": [
              { "start": 0, "name": "logits", "type": "tensor" },
              { "start": 1, "name": "numSamples", "type": "number" }
            ],
            "attrs": [
              { "tfName": "seed", "name": "seed", "type": "number" },
              { "tfName": "seed2", "name": "seed2", "type": "number" },
              { "tfName": "T", "name": "dtype", "type": "dtype" },
              { "tfName": "output_dtype", "name": "output_dtype", "type": "dtype" }
            ]
          }
        ];
        var creation = {
          __proto__: null,
          json: json$4
        };
        var json$5 = [
          {
            "tfOpName": "NonMaxSuppressionV2",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "boxes", "type": "tensor" },
              { "start": 1, "name": "scores", "type": "tensor" },
              { "start": 2, "name": "maxOutputSize", "type": "number" },
              { "start": 3, "name": "iouThreshold", "type": "number" }
            ]
          },
          {
            "tfOpName": "NonMaxSuppressionV3",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "boxes", "type": "tensor" },
              { "start": 1, "name": "scores", "type": "tensor" },
              { "start": 2, "name": "maxOutputSize", "type": "number" },
              { "start": 3, "name": "iouThreshold", "type": "number" },
              { "start": 4, "name": "scoreThreshold", "type": "number" }
            ]
          },
          {
            "tfOpName": "NonMaxSuppressionV4",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "boxes", "type": "tensor" },
              { "start": 1, "name": "scores", "type": "tensor" },
              { "start": 2, "name": "maxOutputSize", "type": "number" },
              { "start": 3, "name": "iouThreshold", "type": "number" },
              { "start": 4, "name": "scoreThreshold", "type": "number" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true },
              {
                "tfName": "T_threshold",
                "name": "threshold",
                "type": "dtype",
                "notSupported": true
              },
              {
                "tfName": "pad_to_max_output_size",
                "name": "padToMaxOutputSize",
                "type": "bool"
              }
            ]
          },
          {
            "tfOpName": "NonMaxSuppressionV5",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "boxes", "type": "tensor" },
              { "start": 1, "name": "scores", "type": "tensor" },
              { "start": 2, "name": "maxOutputSize", "type": "number" },
              { "start": 3, "name": "iouThreshold", "type": "number" },
              { "start": 4, "name": "scoreThreshold", "type": "number" },
              { "start": 5, "name": "softNmsSigma", "type": "number" }
            ]
          },
          {
            "tfOpName": "Where",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "condition", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "ListDiff",
            "category": "dynamic",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "y", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "T",
              "name": "dtype",
              "type": "dtype",
              "notSupported": true
            }]
          }
        ];
        var dynamic = {
          __proto__: null,
          json: json$5
        };
        var json$6 = [
          {
            "tfOpName": "TopKV2",
            "category": "evaluation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "k", "type": "number" }
            ],
            "attrs": [{ "tfName": "sorted", "name": "sorted", "type": "bool" }]
          },
          {
            "tfOpName": "Unique",
            "category": "evaluation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ]
          },
          {
            "tfOpName": "UniqueV2",
            "category": "evaluation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number" }
            ]
          }
        ];
        var evaluation = {
          __proto__: null,
          json: json$6
        };
        var json$7 = [
          {
            "tfOpName": "PlaceholderWithDefault",
            "category": "graph",
            "inputs": [
              { "start": 0, "name": "default", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "shape", "name": "shape", "type": "shape" },
              { "tfName": "dtype", "name": "dtype", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "Placeholder",
            "category": "graph",
            "attrs": [
              { "tfName": "shape", "name": "shape", "type": "shape" },
              { "tfName": "dtype", "name": "dtype", "type": "dtype" }
            ]
          },
          { "tfOpName": "Const", "category": "graph" },
          {
            "tfOpName": "Identity",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "IdentityN",
            "category": "graph",
            "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }]
          },
          {
            "tfOpName": "Snapshot",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "Rank",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "Size",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "Shape",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "ShapeN",
            "category": "graph",
            "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }]
          },
          {
            "tfOpName": "Print",
            "category": "graph",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "data", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "message", "name": "message", "type": "string" },
              {
                "tfName": "first_n",
                "name": "firstN",
                "type": "number",
                "notSupported": true
              },
              {
                "tfName": "summarize",
                "name": "summarize",
                "type": "number",
                "defaultValue": 3
              }
            ]
          },
          { "tfOpName": "NoOp", "category": "graph", "inputs": [] },
          {
            "tfOpName": "StopGradient",
            "category": "graph",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "FakeQuantWithMinMaxVars",
            "category": "graph",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "min", "name": "min", "type": "number" },
              { "tfName": "max", "name": "max", "type": "number" }
            ]
          }
        ];
        var graph = {
          __proto__: null,
          json: json$7
        };
        var json$8 = [
          {
            "tfOpName": "HashTable",
            "category": "hash_table",
            "inputs": [],
            "attrs": [
              { "tfName": "shared_name", "name": "sharedName", "type": "string" },
              {
                "tfName": "use_node_name_sharing",
                "name": "useNodeNameSharing",
                "type": "bool"
              },
              { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" },
              { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "HashTableV2",
            "category": "hash_table",
            "inputs": [],
            "attrs": [
              { "tfName": "shared_name", "name": "sharedName", "type": "string" },
              {
                "tfName": "use_node_name_sharing",
                "name": "useNodeNameSharing",
                "type": "bool"
              },
              { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" },
              { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "LookupTableImport",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" },
              { "start": 1, "name": "keys", "type": "tensor" },
              { "start": 2, "name": "values", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "tOut",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "LookupTableImportV2",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" },
              { "start": 1, "name": "keys", "type": "tensor" },
              { "start": 2, "name": "values", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "tOut",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "LookupTableFind",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" },
              { "start": 1, "name": "keys", "type": "tensor" },
              { "start": 2, "name": "defaultValue", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "tOut",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "LookupTableFindV2",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" },
              { "start": 1, "name": "keys", "type": "tensor" },
              { "start": 2, "name": "defaultValue", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true },
              {
                "tfName": "Tout",
                "name": "tOut",
                "type": "dtype",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "LookupTableSize",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" }
            ]
          },
          {
            "tfOpName": "LookupTableSizeV2",
            "category": "hash_table",
            "inputs": [
              { "start": 0, "name": "tableHandle", "type": "tensor" }
            ]
          }
        ];
        var hashTable = {
          __proto__: null,
          json: json$8
        };
        var json$9 = [
          {
            "tfOpName": "ResizeBilinear",
            "category": "image",
            "inputs": [
              { "start": 0, "name": "images", "type": "tensor" },
              { "start": 1, "name": "size", "type": "number[]" }
            ],
            "attrs": [
              { "tfName": "align_corners", "name": "alignCorners", "type": "bool" },
              {
                "tfName": "half_pixel_centers",
                "name": "halfPixelCenters",
                "type": "bool"
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "ResizeNearestNeighbor",
            "category": "image",
            "inputs": [
              { "start": 0, "name": "images", "type": "tensor" },
              { "start": 1, "name": "size", "type": "number[]" }
            ],
            "attrs": [
              { "tfName": "align_corners", "name": "alignCorners", "type": "bool" },
              {
                "tfName": "half_pixel_centers",
                "name": "halfPixelCenters",
                "type": "bool"
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "CropAndResize",
            "category": "image",
            "inputs": [
              { "start": 0, "name": "image", "type": "tensor" },
              { "start": 1, "name": "boxes", "type": "tensor" },
              { "start": 2, "name": "boxInd", "type": "tensor" },
              { "start": 3, "name": "cropSize", "type": "number[]" }
            ],
            "attrs": [
              { "tfName": "method", "name": "method", "type": "string" },
              {
                "tfName": "extrapolation_value",
                "name": "extrapolationValue",
                "type": "number"
              }
            ]
          }
        ];
        var image2 = {
          __proto__: null,
          json: json$9
        };
        var json$a = [
          {
            "tfOpName": "Equal",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "NotEqual",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Greater",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "GreaterEqual",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Less",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "LessEqual",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "LogicalAnd",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "LogicalNot",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "LogicalOr",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Select",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "condition", "type": "tensor" },
              { "start": 1, "name": "a", "type": "tensor" },
              { "start": 2, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "SelectV2",
            "category": "logical",
            "inputs": [
              { "start": 0, "name": "condition", "type": "tensor" },
              { "start": 1, "name": "a", "type": "tensor" },
              { "start": 2, "name": "b", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "T",
              "name": "dtype",
              "type": "dtype",
              "notSupported": true
            }]
          }
        ];
        var logical = {
          __proto__: null,
          json: json$a
        };
        var json$b = [
          {
            "tfOpName": "_FusedMatMul",
            "category": "matrices",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" },
              { "start": 2, end: 0, "name": "args", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "num_args", "name": "numArgs", "type": "number" },
              {
                "tfName": "fused_ops",
                "name": "fusedOps",
                "type": "string[]",
                "defaultValue": []
              },
              {
                "tfName": "epsilon",
                "name": "epsilon",
                "type": "number",
                "defaultValue": 1e-4
              },
              {
                "tfName": "transpose_a",
                "name": "transposeA",
                "type": "bool",
                "defaultValue": false
              },
              {
                "tfName": "transpose_b",
                "name": "transposeB",
                "type": "bool",
                "defaultValue": false
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "MatMul",
            "category": "matrices",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "transpose_a",
                "name": "transposeA",
                "type": "bool",
                "defaultValue": false
              },
              {
                "tfName": "transpose_b",
                "name": "transposeB",
                "type": "bool",
                "defaultValue": false
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "BatchMatMul",
            "category": "matrices",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "adj_x",
                "name": "transposeA",
                "type": "bool",
                "defaultValue": false
              },
              {
                "tfName": "adj_y",
                "name": "transposeB",
                "type": "bool",
                "defaultValue": false
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "BatchMatMulV2",
            "category": "matrices",
            "inputs": [
              { "start": 0, "name": "a", "type": "tensor" },
              { "start": 1, "name": "b", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "adj_x",
                "name": "transposeA",
                "type": "bool",
                "defaultValue": false
              },
              {
                "tfName": "adj_y",
                "name": "transposeB",
                "type": "bool",
                "defaultValue": false
              },
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Transpose",
            "category": "matrices",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "perm", "type": "number[]" }
            ],
            "attrs": [
              { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }
            ]
          },
          {
            "tfOpName": "Einsum",
            "category": "matrices",
            "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }],
            "attrs": [
              { "tfName": "equation", "name": "equation", "type": "string" },
              { "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 },
              { "tfName": "T", "name": "dtype", "type": "dtype" }
            ]
          }
        ];
        var matrices = {
          __proto__: null,
          json: json$b
        };
        var json$c = [
          {
            "tfOpName": "FusedBatchNorm",
            "category": "normalization",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "scale", "type": "tensor" },
              { "start": 2, "name": "offset", "type": "tensor" },
              { "start": 3, "name": "mean", "type": "tensor" },
              { "start": 4, "name": "variance", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "epsilon",
                "name": "epsilon",
                "type": "number",
                "defaultValue": 1e-3
              },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "FusedBatchNormV2",
            "category": "normalization",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "scale", "type": "tensor" },
              { "start": 2, "name": "offset", "type": "tensor" },
              { "start": 3, "name": "mean", "type": "tensor" },
              { "start": 4, "name": "variance", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "epsilon",
                "name": "epsilon",
                "type": "number",
                "defaultValue": 1e-3
              },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "FusedBatchNormV3",
            "category": "normalization",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "scale", "type": "tensor" },
              { "start": 2, "name": "offset", "type": "tensor" },
              { "start": 3, "name": "mean", "type": "tensor" },
              { "start": 4, "name": "variance", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "epsilon",
                "name": "epsilon",
                "type": "number",
                "defaultValue": 1e-3
              },
              {
                "tfName": "data_format",
                "name": "dataFormat",
                "type": "string",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "LRN",
            "category": "normalization",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "depth_radius",
                "name": "radius",
                "type": "number",
                "defaultValue": 5
              },
              { "tfName": "bias", "name": "bias", "type": "number", "defaultValue": 1 },
              {
                "tfName": "alpha",
                "name": "alpha",
                "type": "number",
                "defaultValue": 1
              },
              {
                "tfName": "beta",
                "name": "beta",
                "type": "number",
                "defaultValue": 0.5
              }
            ]
          },
          {
            "tfOpName": "Softmax",
            "category": "normalization",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "LogSoftmax",
            "category": "normalization",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "SparseToDense",
            "category": "normalization",
            "inputs": [
              { "start": 0, "name": "sparseIndices", "type": "tensor" },
              { "start": 1, "name": "outputShape", "type": "number[]" },
              { "start": 2, "name": "sparseValues", "type": "tensor" },
              { "start": 3, "name": "defaultValue", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "validate_indices",
              "name": "validateIndices",
              "type": "bool",
              "defaultValue": true,
              "notSupported": true
            }]
          }
        ];
        var normalization = {
          __proto__: null,
          json: json$c
        };
        var json$d = [
          {
            "tfOpName": "Bincount",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "size", "type": "number" },
              { "start": 2, "name": "weights", "type": "tensor" }
            ]
          },
          {
            "tfOpName": "DenseBincount",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "size", "type": "number" },
              { "start": 2, "name": "weights", "type": "tensor" }
            ],
            "attrs": [{ "tfName": "binary_output", "name": "binaryOutput", "type": "bool" }]
          },
          {
            "tfOpName": "Max",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "Mean",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "Min",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "Sum",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "All",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "Any",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "ArgMax",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number" }
            ]
          },
          {
            "tfOpName": "ArgMin",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number" }
            ]
          },
          {
            "tfOpName": "Prod",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }]
          },
          {
            "tfOpName": "Cumsum",
            "category": "reduction",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number" }
            ],
            "attrs": [
              { "tfName": "exclusive", "name": "exclusive", "type": "bool" },
              { "tfName": "reverse", "name": "reverse", "type": "bool" }
            ]
          }
        ];
        var reduction = {
          __proto__: null,
          json: json$d
        };
        var json$e = [
          {
            "tfOpName": "ConcatV2",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "end": -1, "name": "tensors", "type": "tensors" },
              { "start": -1, "name": "axis", "type": "number" }
            ],
            "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }]
          },
          {
            "tfOpName": "Concat",
            "category": "slice_join",
            "inputs": [
              { "start": 1, "end": 0, "name": "tensors", "type": "tensors" },
              { "start": 0, "name": "axis", "type": "number" }
            ],
            "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }]
          },
          {
            "tfOpName": "GatherV2",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "tensor" },
              { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }
            ],
            "attrs": [{
              "tfName": "batch_dims",
              "name": "batchDims",
              "type": "number",
              "defaultValue": 0
            }]
          },
          {
            "tfOpName": "Gather",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "validate_indices",
              "name": "validateIndices",
              "type": "bool",
              "notSupported": true
            }]
          },
          {
            "tfOpName": "Reverse",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "dims", "type": "bool[]" }
            ]
          },
          {
            "tfOpName": "ReverseV2",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "Slice",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "begin", "type": "number[]" },
              { "start": 2, "name": "size", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "StridedSlice",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "begin", "type": "number[]" },
              { "start": 2, "name": "end", "type": "number[]" },
              { "start": 3, "name": "strides", "type": "number[]" }
            ],
            "attrs": [
              {
                "tfName": "begin_mask",
                "name": "beginMask",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "end_mask",
                "name": "endMask",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "new_axis_mask",
                "name": "newAxisMask",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "ellipsis_mask",
                "name": "ellipsisMask",
                "type": "number",
                "defaultValue": 0
              },
              {
                "tfName": "shrink_axis_mask",
                "name": "shrinkAxisMask",
                "type": "number",
                "defaultValue": 0
              }
            ]
          },
          {
            "tfOpName": "Pack",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "end": 0, "name": "tensors", "type": "tensors" }
            ],
            "attrs": [
              { "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 }
            ]
          },
          {
            "tfOpName": "Unpack",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "tensor", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 },
              {
                "tfName": "num",
                "name": "num",
                "type": "number",
                "defaultValue": 0,
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "Tile",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "reps", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "Split",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "axis", "type": "number", "defaultValue": 0 },
              { "start": 1, "name": "x", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "num_split",
              "name": "numOrSizeSplits",
              "type": "number",
              "defaultValue": 1
            }]
          },
          {
            "tfOpName": "SplitV",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "numOrSizeSplits", "type": "number[]" },
              { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }
            ]
          },
          {
            "tfOpName": "ScatterNd",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "indices", "type": "tensor" },
              { "start": 1, "name": "values", "type": "tensor" },
              { "start": 2, "name": "shape", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "GatherNd",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "indices", "type": "tensor" }
            ]
          },
          {
            "tfOpName": "SparseToDense",
            "category": "slice_join",
            "inputs": [
              { "start": 0, "name": "sparseIndices", "type": "tensor" },
              { "start": 1, "name": "outputShape", "type": "number[]" },
              { "start": 2, "name": "sparseValues", "type": "tensor" },
              { "start": 3, "name": "defaultValue", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "validate_indices",
              "name": "validateIndices",
              "type": "bool",
              "defaultValue": false,
              "notSupported": true
            }]
          }
        ];
        var sliceJoin = {
          __proto__: null,
          json: json$e
        };
        var json$f = [
          {
            "tfOpName": "FFT",
            "category": "spectral",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "IFFT",
            "category": "spectral",
            "inputs": [{ "start": 0, "name": "x", "type": "tensor" }]
          },
          {
            "tfOpName": "RFFT",
            "category": "spectral",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              {
                "start": 1,
                "name": "fft_length",
                "type": "number",
                "notSupported": true
              }
            ]
          },
          {
            "tfOpName": "IRFFT",
            "category": "spectral",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              {
                "start": 1,
                "name": "fft_length",
                "type": "number",
                "notSupported": true
              }
            ]
          }
        ];
        var spectral2 = {
          __proto__: null,
          json: json$f
        };
        var json$g = [
          {
            "tfOpName": "Cast",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              {
                "tfName": "SrcT",
                "name": "sdtype",
                "type": "dtype",
                "notSupported": true
              },
              { "tfName": "DstT", "name": "dtype", "type": "dtype" }
            ]
          },
          {
            "tfOpName": "ExpandDims",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "axis", "type": "number" }
            ]
          },
          {
            "tfOpName": "MirrorPad",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "padding", "type": "number[]" }
            ],
            "attrs": [{ "tfName": "mode", "name": "mode", "type": "string" }]
          },
          {
            "tfOpName": "Pad",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "padding", "type": "number[]" }
            ],
            "attrs": [{
              "tfName": "constant_value",
              "name": "constantValue",
              "type": "number",
              "defaultValue": 0
            }]
          },
          {
            "tfOpName": "PadV2",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "padding", "type": "number[]" },
              {
                "start": 2,
                "name": "constantValue",
                "type": "number",
                "defaultValue": 0
              }
            ]
          },
          {
            "tfOpName": "Reshape",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "shape", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "Squeeze",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [{
              "tfName": "axis",
              "tfDeprecatedName": "squeeze_dims",
              "name": "axis",
              "type": "number[]"
            }]
          },
          {
            "tfOpName": "SpaceToBatchND",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "blockShape", "type": "number[]" },
              { "start": 2, "name": "paddings", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "BatchToSpaceND",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "blockShape", "type": "number[]" },
              { "start": 2, "name": "crops", "type": "number[]" }
            ]
          },
          {
            "tfOpName": "DepthToSpace",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" }
            ],
            "attrs": [
              { "tfName": "block_size", "name": "blockSize", "type": "number" },
              { "tfName": "data_format", "name": "dataFormat", "type": "string" }
            ]
          },
          {
            "tfOpName": "BroadcastTo",
            "category": "transformation",
            "inputs": [
              { "start": 0, "name": "x", "type": "tensor" },
              { "start": 1, "name": "shape", "type": "number[]" }
            ],
            "attrs": []
          }
        ];
        var transformation = {
          __proto__: null,
          json: json$g
        };
        var OperationMapper = function() {
          function OperationMapper2() {
            var ops = [
              arithmetic,
              basicMath,
              control,
              convolution,
              creation,
              dynamic,
              evaluation,
              logical,
              image2,
              graph,
              matrices,
              normalization,
              reduction,
              sliceJoin,
              spectral2,
              transformation,
              hashTable
            ];
            var mappersJson = [].concat.apply([], __spread(ops.map(function(op2) {
              return op2.json;
            })));
            this.opMappers = mappersJson.reduce(function(map2, mapper) {
              map2[mapper.tfOpName] = mapper;
              return map2;
            }, {});
          }
          Object.defineProperty(OperationMapper2, "Instance", {
            get: function() {
              return this._instance || (this._instance = new this());
            },
            enumerable: true,
            configurable: true
          });
          OperationMapper2.prototype.transformGraph = function(graph2, signature) {
            var _this2 = this;
            if (signature === void 0) {
              signature = {};
            }
            var tfNodes = graph2.node;
            var placeholders = [];
            var weights = [];
            var initNodes = [];
            var nodes = tfNodes.reduce(function(map2, node) {
              map2[node.name] = _this2.mapNode(node);
              if (node.op.startsWith("Placeholder")) {
                placeholders.push(map2[node.name]);
              } else if (node.op === "Const") {
                weights.push(map2[node.name]);
              } else if (node.input == null || node.input.length === 0) {
                initNodes.push(map2[node.name]);
              }
              return map2;
            }, {});
            var inputs = [];
            var outputs = [];
            var inputNodeNameToKey = {};
            var outputNodeNameToKey = {};
            if (signature != null) {
              inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
              outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
            }
            var allNodes = Object.keys(nodes);
            allNodes.forEach(function(key) {
              var node = nodes[key];
              node.inputNames.forEach(function(name) {
                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
              });
            });
            if (Object.keys(outputNodeNameToKey).length === 0) {
              allNodes.forEach(function(key) {
                var node = nodes[key];
                if (node.children.length === 0) {
                  outputs.push(node);
                }
              });
            } else {
              Object.keys(outputNodeNameToKey).forEach(function(name) {
                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];
                var node = nodes[nodeName];
                if (node != null) {
                  node.signatureKey = outputNodeNameToKey[name];
                  outputs.push(node);
                }
              });
            }
            if (Object.keys(inputNodeNameToKey).length > 0) {
              Object.keys(inputNodeNameToKey).forEach(function(name) {
                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];
                var node = nodes[nodeName];
                if (node) {
                  node.signatureKey = inputNodeNameToKey[name];
                  inputs.push(node);
                }
              });
            } else {
              inputs = placeholders;
            }
            var functions = {};
            if (graph2.library != null && graph2.library.function != null) {
              functions = graph2.library.function.reduce(function(functions2, func) {
                functions2[func.signature.name] = _this2.mapFunction(func);
                return functions2;
              }, {});
            }
            var result2 = { nodes, inputs, outputs, weights, placeholders, signature, functions };
            if (initNodes.length > 0) {
              result2.initNodes = initNodes;
            }
            return result2;
          };
          OperationMapper2.prototype.mapSignatureEntries = function(entries) {
            return Object.keys(entries || {}).reduce(function(prev, curr) {
              prev[entries[curr].name] = curr;
              return prev;
            }, {});
          };
          OperationMapper2.prototype.mapNode = function(node) {
            var mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};
            if (node.attr == null) {
              node.attr = {};
            }
            var newNode = {
              name: node.name,
              op: node.op,
              category: mapper.category,
              inputNames: (node.input || []).map(function(input) {
                return input.startsWith("^") ? input.substr(1) : input;
              }),
              inputs: [],
              children: [],
              inputParams: {},
              attrParams: {},
              rawAttrs: node.attr
            };
            if (mapper.inputs != null) {
              newNode.inputParams = mapper.inputs.reduce(function(map2, param) {
                map2[param.name] = {
                  type: param.type,
                  inputIndexStart: param.start,
                  inputIndexEnd: param.end
                };
                return map2;
              }, {});
            }
            if (mapper.attrs != null) {
              newNode.attrParams = mapper.attrs.reduce(function(map2, param) {
                var type = param.type;
                var value = void 0;
                switch (param.type) {
                  case "string":
                    value = getStringParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "string[]":
                    value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "number":
                    value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "number[]":
                    value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "bool":
                    value = getBoolParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "bool[]":
                    value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "shape":
                    value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "shape[]":
                    value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "dtype":
                    value = getDtypeParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "dtype[]":
                    value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "func":
                    value = getFuncParam(node.attr, param.tfName, param.defaultValue);
                    if (value === void 0 && !!param.tfDeprecatedName) {
                      value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                    }
                    break;
                  case "tensor":
                  case "tensors":
                    break;
                  default:
                    throw new Error("Unsupported param type: " + param.type + " for op: " + node.op);
                }
                map2[param.name] = { value, type };
                return map2;
              }, {});
            }
            return newNode;
          };
          OperationMapper2.prototype.mapFunction = function(functionDef) {
            var _this2 = this;
            var tfNodes = functionDef.nodeDef;
            var placeholders = [];
            var weights = [];
            var nodes = {};
            if (tfNodes != null) {
              nodes = tfNodes.reduce(function(map2, node) {
                map2[node.name] = _this2.mapNode(node);
                if (node.op === "Const") {
                  weights.push(map2[node.name]);
                }
                return map2;
              }, {});
            }
            var inputs = [];
            var outputs = [];
            functionDef.signature.inputArg.forEach(function(arg) {
              var _a = __read(getNodeNameAndIndex(arg.name), 1), nodeName = _a[0];
              var node = {
                name: nodeName,
                op: "Placeholder",
                inputs: [],
                inputNames: [],
                category: "graph",
                inputParams: {},
                attrParams: { dtype: { value: parseDtypeParam(arg.type), type: "dtype" } },
                children: []
              };
              node.signatureKey = arg.name;
              inputs.push(node);
              nodes[nodeName] = node;
            });
            var allNodes = Object.keys(nodes);
            allNodes.forEach(function(key) {
              var node = nodes[key];
              node.inputNames.forEach(function(name) {
                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
              });
            });
            var returnNodeMap = functionDef.ret;
            functionDef.signature.outputArg.forEach(function(output) {
              var _a = __read(getNodeNameAndIndex(returnNodeMap[output.name]), 2), nodeName = _a[0], index2 = _a[1];
              var node = nodes[nodeName];
              if (node != null) {
                node.defaultOutput = index2;
                outputs.push(node);
              }
            });
            var signature = this.mapArgsToSignature(functionDef);
            return { nodes, inputs, outputs, weights, placeholders, signature };
          };
          OperationMapper2.prototype.mapArgsToSignature = function(functionDef) {
            var _this2 = this;
            return {
              methodName: functionDef.signature.name,
              inputs: functionDef.signature.inputArg.reduce(function(map2, arg) {
                map2[arg.name] = _this2.mapArgToTensorInfo(arg);
                return map2;
              }, {}),
              outputs: functionDef.signature.outputArg.reduce(function(map2, arg) {
                map2[arg.name] = _this2.mapArgToTensorInfo(arg, functionDef.ret);
                return map2;
              }, {})
            };
          };
          OperationMapper2.prototype.mapArgToTensorInfo = function(arg, nameMap) {
            var name = arg.name;
            if (nameMap != null) {
              name = nameMap[name];
            }
            return { name, dtype: arg.type };
          };
          return OperationMapper2;
        }();
        function decodeBase64(text) {
          var global2 = tfOps.env().global;
          if (typeof global2.atob !== "undefined") {
            return global2.atob(text);
          } else if (typeof Buffer !== "undefined") {
            return new Buffer(text, "base64").toString();
          } else {
            throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
          }
        }
        function parseStringParam(s, keepCase) {
          var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);
          return keepCase ? value : value.toLowerCase();
        }
        function getStringParam(attrs, name, def, keepCase) {
          if (keepCase === void 0) {
            keepCase = false;
          }
          var param = attrs[name];
          if (param != null) {
            return parseStringParam(param.s, keepCase);
          }
          return def;
        }
        function getBoolParam(attrs, name, def) {
          var param = attrs[name];
          return param ? param.b : def;
        }
        function getNumberParam(attrs, name, def) {
          var param = attrs[name] || {};
          var value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
          return typeof value === "number" ? value : parseInt(value, 10);
        }
        function parseDtypeParam(value) {
          if (typeof value === "string") {
            value = DataType[value];
          }
          switch (value) {
            case DataType.DT_FLOAT:
              return "float32";
            case DataType.DT_INT32:
            case DataType.DT_INT64:
            case DataType.DT_INT8:
            case DataType.DT_UINT8:
              return "int32";
            case DataType.DT_BOOL:
              return "bool";
            case DataType.DT_DOUBLE:
              return "float32";
            case DataType.DT_STRING:
              return "string";
            default:
              return null;
          }
        }
        function getFuncParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.func) {
            return param.func.name;
          }
          return def;
        }
        function getDtypeParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.type) {
            return parseDtypeParam(param.type);
          }
          return def;
        }
        function getDtypeArrayParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.list && param.list.type) {
            return param.list.type.map(function(v) {
              return parseDtypeParam(v);
            });
          }
          return def;
        }
        function parseTensorShapeParam(shape) {
          if (shape.unknownRank) {
            return void 0;
          }
          if (shape.dim != null) {
            return shape.dim.map(function(dim) {
              return typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10);
            });
          }
          return [];
        }
        function getTensorShapeParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.shape) {
            return parseTensorShapeParam(param.shape);
          }
          return def;
        }
        function getNumericArrayParam(attrs, name, def) {
          var param = attrs[name];
          if (param) {
            return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(function(v) {
              return typeof v === "number" ? v : parseInt(v, 10);
            });
          }
          return def;
        }
        function getStringArrayParam(attrs, name, def, keepCase) {
          if (keepCase === void 0) {
            keepCase = false;
          }
          var param = attrs[name];
          if (param && param.list && param.list.s) {
            return param.list.s.map(function(v) {
              return parseStringParam(v, keepCase);
            });
          }
          return def;
        }
        function getTensorShapeArrayParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.list && param.list.shape) {
            return param.list.shape.map(function(v) {
              return parseTensorShapeParam(v);
            });
          }
          return def;
        }
        function getBoolArrayParam(attrs, name, def) {
          var param = attrs[name];
          if (param && param.list && param.list.b) {
            return param.list.b;
          }
          return def;
        }
        var NodeValueImpl = function() {
          function NodeValueImpl2(node, tensorMap, context) {
            var _this2 = this;
            this.node = node;
            this.tensorMap = tensorMap;
            this.context = context;
            this.inputs = [];
            this.attrs = {};
            this.inputs = node.inputNames.map(function(name) {
              return _this2.getInput(name);
            });
            if (node.rawAttrs != null) {
              this.attrs = Object.keys(node.rawAttrs).reduce(function(attrs, key) {
                attrs[key] = _this2.getAttr(key);
                return attrs;
              }, {});
            }
          }
          NodeValueImpl2.prototype.getInput = function(name) {
            return getTensor(name, this.tensorMap, this.context);
          };
          NodeValueImpl2.prototype.getAttr = function(name, defaultValue) {
            var value = this.node.rawAttrs[name];
            if (value.tensor != null) {
              return getTensor(name, this.tensorMap, this.context);
            }
            if (value.i != null || value.f != null) {
              return getNumberParam(this.node.rawAttrs, name, defaultValue);
            }
            if (value.s != null) {
              return getStringParam(this.node.rawAttrs, name, defaultValue);
            }
            if (value.b != null) {
              return getBoolParam(this.node.rawAttrs, name, defaultValue);
            }
            if (value.shape != null) {
              return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
            }
            if (value.type != null) {
              return getDtypeParam(this.node.rawAttrs, name, defaultValue);
            }
            if (value.list != null) {
              if (value.list.i != null || value.list.f != null) {
                return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
              }
              if (value.list.s != null) {
                return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
              }
              if (value.list.shape != null) {
                return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
              }
              if (value.list.b != null) {
                return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
              }
              if (value.list.type != null) {
                return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
              }
            }
            return defaultValue;
          };
          return NodeValueImpl2;
        }();
        var executeOp = function(node, tensorMap, context) {
          switch (node.op) {
            case "BiasAdd":
            case "AddV2":
            case "Add": {
              return [tfOps.add(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "AddN": {
              return [tfOps.addN(getParamValue("tensors", node, tensorMap, context))];
            }
            case "FloorMod":
            case "Mod":
              return [tfOps.mod(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            case "Mul":
              return [tfOps.mul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            case "RealDiv":
            case "Div": {
              return [tfOps.div(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "DivNoNan": {
              return [tfOps.divNoNan(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "FloorDiv": {
              return [tfOps.floorDiv(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Sub": {
              return [tfOps.sub(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Minimum": {
              return [tfOps.minimum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Maximum": {
              return [tfOps.maximum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Pow": {
              return [tfOps.pow(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "SquaredDifference": {
              return [tfOps.squaredDifference(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$1 = function(node, tensorMap, context) {
          switch (node.op) {
            case "Abs":
            case "ComplexAbs":
              return [tfOps.abs(getParamValue("x", node, tensorMap, context))];
            case "Acos":
              return [tfOps.acos(getParamValue("x", node, tensorMap, context))];
            case "Acosh":
              return [tfOps.acosh(getParamValue("x", node, tensorMap, context))];
            case "Asin":
              return [tfOps.asin(getParamValue("x", node, tensorMap, context))];
            case "Asinh":
              return [tfOps.asinh(getParamValue("x", node, tensorMap, context))];
            case "Atan":
              return [tfOps.atan(getParamValue("x", node, tensorMap, context))];
            case "Atan2":
              return [tfOps.atan2(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context))];
            case "Atanh":
              return [tfOps.atanh(getParamValue("x", node, tensorMap, context))];
            case "Ceil":
              return [tfOps.ceil(getParamValue("x", node, tensorMap, context))];
            case "Complex":
              return [tfOps.complex(getParamValue("real", node, tensorMap, context), getParamValue("imag", node, tensorMap, context))];
            case "Cos":
              return [tfOps.cos(getParamValue("x", node, tensorMap, context))];
            case "Cosh":
              return [tfOps.cosh(getParamValue("x", node, tensorMap, context))];
            case "Elu":
              return [tfOps.elu(getParamValue("x", node, tensorMap, context))];
            case "Erf":
              return [tfOps.erf(getParamValue("x", node, tensorMap, context))];
            case "Exp":
              return [tfOps.exp(getParamValue("x", node, tensorMap, context))];
            case "Expm1": {
              return [tfOps.expm1(getParamValue("x", node, tensorMap, context))];
            }
            case "Floor":
              return [tfOps.floor(getParamValue("x", node, tensorMap, context))];
            case "Log":
              return [tfOps.log(getParamValue("x", node, tensorMap, context))];
            case "Log1p": {
              return [tfOps.log1p(getParamValue("x", node, tensorMap, context))];
            }
            case "Imag":
              return [tfOps.imag(getParamValue("x", node, tensorMap, context))];
            case "Neg":
              return [tfOps.neg(getParamValue("x", node, tensorMap, context))];
            case "Reciprocal": {
              return [tfOps.reciprocal(getParamValue("x", node, tensorMap, context))];
            }
            case "Real":
              return [tfOps.real(getParamValue("x", node, tensorMap, context))];
            case "Relu":
              return [tfOps.relu(getParamValue("x", node, tensorMap, context))];
            case "Round": {
              return [tfOps.round(getParamValue("x", node, tensorMap, context))];
            }
            case "Selu":
              return [tfOps.selu(getParamValue("x", node, tensorMap, context))];
            case "Sigmoid":
              return [tfOps.sigmoid(getParamValue("x", node, tensorMap, context))];
            case "Sin":
              return [tfOps.sin(getParamValue("x", node, tensorMap, context))];
            case "Sign": {
              return [tfOps.sign(getParamValue("x", node, tensorMap, context))];
            }
            case "Sinh": {
              return [tfOps.sinh(getParamValue("x", node, tensorMap, context))];
            }
            case "Softplus": {
              return [tfOps.softplus(getParamValue("x", node, tensorMap, context))];
            }
            case "Sqrt": {
              return [tfOps.sqrt(getParamValue("x", node, tensorMap, context))];
            }
            case "Square": {
              return [tfOps.square(getParamValue("x", node, tensorMap, context))];
            }
            case "Tanh": {
              return [tfOps.tanh(getParamValue("x", node, tensorMap, context))];
            }
            case "Tan":
              return [tfOps.tan(getParamValue("x", node, tensorMap, context))];
            case "ClipByValue":
              return [tfOps.clipByValue(getParamValue("x", node, tensorMap, context), getParamValue("clipValueMin", node, tensorMap, context), getParamValue("clipValueMax", node, tensorMap, context))];
            case "Relu6":
              return [tfOps.relu6(getParamValue("x", node, tensorMap, context))];
            case "Rsqrt":
              return [tfOps.rsqrt(getTensor(node.inputNames[0], tensorMap, context))];
            case "Prod":
              return [tfOps.prod(getParamValue("x", node, tensorMap, context), getParamValue("axes", node, tensorMap, context))];
            case "LeakyRelu":
              return [tfOps.leakyRelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
            case "Prelu":
              return [tfOps.prelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
            case "IsNan":
              return [tfOps.isNaN(getTensor(node.inputNames[0], tensorMap, context))];
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix) {
          if (errorMessagePrefix === void 0) {
            errorMessagePrefix = "";
          }
          if (typeof shapeA === "number" || typeof shapeB === "number") {
            return;
          }
          tfOps.util.assert(shapeA.length === shapeB.length, function() {
            return errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match");
          });
          for (var i = 0; i < shapeA.length; i++) {
            var dim0 = shapeA[i];
            var dim1 = shapeB[i];
            tfOps.util.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, function() {
              return errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match");
            });
          }
        }
        function fullDefinedShape(elementShape) {
          if (typeof elementShape === "number" || elementShape.some(function(dim) {
            return dim < 0;
          })) {
            return false;
          }
          return true;
        }
        function inferElementShape(listElementShape, tensors, elementShape) {
          var partialShape = mergeElementShape(listElementShape, elementShape);
          var notfullDefinedShape = !fullDefinedShape(partialShape);
          if (notfullDefinedShape && tensors.length === 0) {
            throw new Error("Tried to calculate elements of an empty list" + (" with non-fully-defined elementShape: " + partialShape));
          }
          if (notfullDefinedShape) {
            tensors.forEach(function(tensor) {
              partialShape = mergeElementShape(tensor.shape, partialShape);
            });
          }
          if (!fullDefinedShape(partialShape)) {
            throw new Error("Non-fully-defined elementShape: " + partialShape);
          }
          return partialShape;
        }
        function mergeElementShape(elementShapeA, elementShapeB) {
          if (typeof elementShapeA === "number") {
            return elementShapeB;
          }
          if (typeof elementShapeB === "number") {
            return elementShapeA;
          }
          if (elementShapeA.length !== elementShapeB.length) {
            throw new Error("Incompatible ranks during merge: " + elementShapeA + " vs. " + elementShapeB);
          }
          var result2 = [];
          for (var i = 0; i < elementShapeA.length; ++i) {
            var dim0 = elementShapeA[i];
            var dim1 = elementShapeB[i];
            if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
              throw new Error("Incompatible shape during merge: " + elementShapeA + " vs. " + elementShapeB);
            }
            result2[i] = dim0 >= 0 ? dim0 : dim1;
          }
          return result2;
        }
        var TensorArray = function() {
          function TensorArray2(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
            this.name = name;
            this.dtype = dtype;
            this.maxSize = maxSize;
            this.elementShape = elementShape;
            this.identicalElementShapes = identicalElementShapes;
            this.dynamicSize = dynamicSize;
            this.clearAfterRead = clearAfterRead;
            this.tensors = [];
            this.closed_ = false;
            this.idTensor = tfOps.scalar(0);
            tfOps.keep(this.idTensor);
          }
          Object.defineProperty(TensorArray2.prototype, "id", {
            get: function() {
              return this.idTensor.id;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(TensorArray2.prototype, "closed", {
            get: function() {
              return this.closed_;
            },
            enumerable: true,
            configurable: true
          });
          TensorArray2.prototype.clearAndClose = function(keepIds) {
            this.tensors.forEach(function(tensor) {
              if (keepIds == null || !keepIds.has(tensor.tensor.id)) {
                tensor.tensor.dispose();
              }
            });
            this.tensors = [];
            this.closed_ = true;
            this.idTensor.dispose();
          };
          TensorArray2.prototype.size = function() {
            return this.tensors.length;
          };
          TensorArray2.prototype.read = function(index2) {
            if (this.closed_) {
              throw new Error("TensorArray " + this.name + " has already been closed.");
            }
            if (index2 < 0 || index2 >= this.size()) {
              throw new Error("Tried to read from index " + index2 + ", but array size is: " + this.size());
            }
            var tensorWithState = this.tensors[index2];
            if (tensorWithState.cleared) {
              throw new Error("TensorArray " + this.name + ": Could not read index " + index2 + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
            }
            if (this.clearAfterRead) {
              tensorWithState.cleared = true;
            }
            tensorWithState.read = true;
            return tensorWithState.tensor;
          };
          TensorArray2.prototype.readMany = function(indices) {
            var _this2 = this;
            return indices.map(function(index2) {
              return _this2.read(index2);
            });
          };
          TensorArray2.prototype.write = function(index2, tensor) {
            if (this.closed_) {
              throw new Error("TensorArray " + this.name + " has already been closed.");
            }
            if (index2 < 0 || !this.dynamicSize && index2 >= this.maxSize) {
              throw new Error("Tried to write to index " + index2 + ", but array is not resizeable and size is: " + this.maxSize);
            }
            var t = this.tensors[index2] || {};
            if (tensor.dtype !== this.dtype) {
              throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index2 + ",\n          because the value dtype is " + tensor.dtype + ", but TensorArray dtype is " + this.dtype + ".");
            }
            if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
              this.elementShape = tensor.shape;
            }
            assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + index2 + ".");
            if (t.read) {
              throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index2 + ", because it has already been read.");
            }
            if (t.written) {
              throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index2 + ", because it has already been written.");
            }
            t.tensor = tensor;
            tfOps.keep(tensor);
            t.written = true;
            this.tensors[index2] = t;
          };
          TensorArray2.prototype.writeMany = function(indices, tensors) {
            var _this2 = this;
            if (indices.length !== tensors.length) {
              throw new Error("TensorArray " + this.name + ": could not write multiple tensors," + ("because the index size: " + indices.length + " is not the same as tensors size: " + tensors.length + "."));
            }
            indices.forEach(function(i, index2) {
              return _this2.write(i, tensors[index2]);
            });
          };
          TensorArray2.prototype.gather = function(indices, dtype) {
            if (!!dtype && dtype !== this.dtype) {
              throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + dtype);
            }
            if (!indices) {
              indices = [];
              for (var i = 0; i < this.size(); i++) {
                indices.push(i);
              }
            } else {
              indices = indices.slice(0, this.size());
            }
            if (indices.length === 0) {
              return tfOps.tensor([], [0].concat(this.elementShape));
            }
            var tensors = this.readMany(indices);
            assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
            return tfOps.stack(tensors, 0);
          };
          TensorArray2.prototype.concat = function(dtype) {
            if (!!dtype && dtype !== this.dtype) {
              throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + dtype);
            }
            if (this.size() === 0) {
              return tfOps.tensor([], [0].concat(this.elementShape));
            }
            var indices = [];
            for (var i = 0; i < this.size(); i++) {
              indices.push(i);
            }
            var tensors = this.readMany(indices);
            assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + tensors[0].shape + ")");
            return tfOps.concat(tensors, 0);
          };
          TensorArray2.prototype.scatter = function(indices, tensor) {
            if (tensor.dtype !== this.dtype) {
              throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + tensor.dtype);
            }
            if (indices.length !== tensor.shape[0]) {
              throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + indices.length + " vs. " + tensor.shape[0]);
            }
            var maxIndex = Math.max.apply(Math, __spread(indices));
            if (!this.dynamicSize && maxIndex >= this.maxSize) {
              throw new Error("Max index must be < array size (" + maxIndex + "  vs. " + this.maxSize + ")");
            }
            this.writeMany(indices, tfOps.unstack(tensor, 0));
          };
          TensorArray2.prototype.split = function(length, tensor) {
            var _this2 = this;
            if (tensor.dtype !== this.dtype) {
              throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + tensor.dtype);
            }
            var totalLength = 0;
            var cumulativeLengths = length.map(function(len) {
              totalLength += len;
              return totalLength;
            });
            if (totalLength !== tensor.shape[0]) {
              throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + totalLength + ", and tensor's shape is: " + tensor.shape);
            }
            if (!this.dynamicSize && length.length !== this.maxSize) {
              throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + length.length + "), and the TensorArray is not marked as dynamically resizeable");
            }
            var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;
            var tensors = [];
            tfOps.tidy(function() {
              tensor = tfOps.reshape(tensor, [1, totalLength, elementPerRow]);
              for (var i2 = 0; i2 < length.length; ++i2) {
                var previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
                var indices_1 = [0, previousLength, 0];
                var sizes = [1, length[i2], elementPerRow];
                tensors[i2] = tfOps.reshape(tfOps.slice(tensor, indices_1, sizes), _this2.elementShape);
              }
              return tensors;
            });
            var indices = [];
            for (var i = 0; i < length.length; i++) {
              indices[i] = i;
            }
            this.writeMany(indices, tensors);
          };
          return TensorArray2;
        }();
        var TensorList = function() {
          function TensorList2(tensors, elementShape, elementDtype, maxNumElements) {
            if (maxNumElements === void 0) {
              maxNumElements = -1;
            }
            this.tensors = tensors;
            this.elementShape = elementShape;
            this.elementDtype = elementDtype;
            if (tensors != null) {
              tensors.forEach(function(tensor) {
                if (elementDtype !== tensor.dtype) {
                  throw new Error("Invalid data types; op elements " + elementDtype + ", but list elements " + tensor.dtype);
                }
                assertShapesMatchAllowUndefinedSize(elementShape, tensor.shape, "TensorList shape mismatch: ");
                tfOps.keep(tensor);
              });
            }
            this.idTensor = tfOps.scalar(0);
            this.maxNumElements = maxNumElements;
            tfOps.keep(this.idTensor);
          }
          Object.defineProperty(TensorList2.prototype, "id", {
            get: function() {
              return this.idTensor.id;
            },
            enumerable: true,
            configurable: true
          });
          TensorList2.prototype.copy = function() {
            return new TensorList2(__spread(this.tensors), this.elementShape, this.elementDtype);
          };
          TensorList2.prototype.clearAndClose = function(keepIds) {
            this.tensors.forEach(function(tensor) {
              if (keepIds == null || !keepIds.has(tensor.id)) {
                tensor.dispose();
              }
            });
            this.tensors.length = 0;
            this.idTensor.dispose();
          };
          TensorList2.prototype.size = function() {
            return this.tensors.length;
          };
          TensorList2.prototype.stack = function(elementShape, elementDtype, numElements) {
            var _this2 = this;
            if (numElements === void 0) {
              numElements = -1;
            }
            if (elementDtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + elementDtype + ", but list elements " + this.elementDtype);
            }
            if (numElements !== -1 && this.tensors.length !== numElements) {
              throw new Error("Operation expected a list with " + numElements + " elements but got a list with " + this.tensors.length + " elements.");
            }
            assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
            var outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
            return tfOps.tidy(function() {
              var reshapedTensors = _this2.tensors.map(function(tensor) {
                return tfOps.reshape(tensor, outputElementShape);
              });
              return tfOps.stack(reshapedTensors, 0);
            });
          };
          TensorList2.prototype.popBack = function(elementShape, elementDtype) {
            if (elementDtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + elementDtype + ", but list elements " + this.elementDtype);
            }
            if (this.size() === 0) {
              throw new Error("Trying to pop from an empty list.");
            }
            var outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
            var tensor = this.tensors.pop();
            assertShapesMatchAllowUndefinedSize(tensor.shape, elementShape, "TensorList shape mismatch: ");
            return tfOps.reshape(tensor, outputElementShape);
          };
          TensorList2.prototype.pushBack = function(tensor) {
            if (tensor.dtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + tensor.dtype + ", but list elements " + this.elementDtype);
            }
            assertShapesMatchAllowUndefinedSize(tensor.shape, this.elementShape, "TensorList shape mismatch: ");
            if (this.maxNumElements === this.size()) {
              throw new Error("Trying to push element into a full list.");
            }
            tfOps.keep(tensor);
            this.tensors.push(tensor);
          };
          TensorList2.prototype.resize = function(size) {
            if (size < 0) {
              throw new Error("TensorListResize expects size to be non-negative. Got: " + size);
            }
            if (this.maxNumElements !== -1 && size > this.maxNumElements) {
              throw new Error("TensorListResize input size " + size + " is greater maxNumElement " + this.maxNumElements + ".");
            }
            this.tensors.length = size;
          };
          TensorList2.prototype.getItem = function(elementIndex, elementShape, elementDtype) {
            if (elementDtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + elementDtype + ", but list elements " + this.elementDtype);
            }
            if (elementIndex < 0 || elementIndex > this.tensors.length) {
              throw new Error("Trying to access element " + elementIndex + " in a list with " + this.tensors.length + " elements.");
            }
            if (this.tensors[elementIndex] == null) {
              throw new Error("element at index " + elementIndex + " is null.");
            }
            assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
            var outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
            return tfOps.reshape(this.tensors[elementIndex], outputElementShape);
          };
          TensorList2.prototype.setItem = function(elementIndex, tensor) {
            if (tensor.dtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + tensor.dtype + ", but list elements " + this.elementDtype);
            }
            if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
              throw new Error("Trying to set element " + elementIndex + " in a list with max " + this.maxNumElements + " elements.");
            }
            assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, "TensorList shape mismatch: ");
            tfOps.keep(tensor);
            this.tensors[elementIndex] = tensor;
          };
          TensorList2.prototype.gather = function(indices, elementDtype, elementShape) {
            var _this2 = this;
            if (elementDtype !== this.elementDtype) {
              throw new Error("Invalid data types; op elements " + elementDtype + ", but list elements " + this.elementDtype);
            }
            assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
            indices = indices.slice(0, this.size());
            var outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
            if (indices.length === 0) {
              return tfOps.tensor([], [0].concat(outputElementShape));
            }
            return tfOps.tidy(function() {
              var tensors = indices.map(function(i) {
                return tfOps.reshape(_this2.tensors[i], outputElementShape);
              });
              return tfOps.stack(tensors, 0);
            });
          };
          TensorList2.prototype.concat = function(elementDtype, elementShape) {
            var _this2 = this;
            if (!!elementDtype && elementDtype !== this.elementDtype) {
              throw new Error("TensorList dtype is " + this.elementDtype + " but concat requested dtype " + elementDtype);
            }
            assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
            var outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
            if (this.size() === 0) {
              return tfOps.tensor([], [0].concat(outputElementShape));
            }
            return tfOps.tidy(function() {
              var tensors = _this2.tensors.map(function(t) {
                return tfOps.reshape(t, outputElementShape);
              });
              return tfOps.concat(tensors, 0);
            });
          };
          return TensorList2;
        }();
        function fromTensor(tensor, elementShape, elementDtype) {
          var dtype = tensor.dtype;
          if (tensor.shape.length < 1) {
            throw new Error("Tensor must be at least a vector, but saw shape: " + tensor.shape);
          }
          if (tensor.dtype !== elementDtype) {
            throw new Error("Invalid data types; op elements " + tensor.dtype + ", but list elements " + elementDtype);
          }
          var tensorElementShape = tensor.shape.slice(1);
          assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
          var tensorList = tfOps.unstack(tensor);
          return new TensorList(tensorList, elementShape, dtype);
        }
        function reserve(elementShape, elementDtype, numElements) {
          return new TensorList([], elementShape, elementDtype, numElements);
        }
        function scatter(tensor, indices, elementShape, numElements) {
          if (indices.length !== tensor.shape[0]) {
            throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + indices.length + " vs. " + tensor.shape[0]);
          }
          var maxIndex = Math.max.apply(Math, __spread(indices));
          if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
            throw new Error("Max index must be < array size (" + maxIndex + "  vs. " + numElements + ")");
          }
          var list = new TensorList([], elementShape, tensor.dtype, numElements);
          var tensors = tfOps.unstack(tensor, 0);
          indices.forEach(function(value, index2) {
            list.setItem(value, tensors[index2]);
          });
          return list;
        }
        function split2(tensor, length, elementShape) {
          var totalLength = 0;
          var cumulativeLengths = length.map(function(len) {
            totalLength += len;
            return totalLength;
          });
          if (totalLength !== tensor.shape[0]) {
            throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + totalLength + ", and tensor's shape is: " + tensor.shape);
          }
          var shapeWithoutFirstDim = tensor.shape.slice(1);
          var outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
          var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;
          var tensors = tfOps.tidy(function() {
            var tensors2 = [];
            tensor = tfOps.reshape(tensor, [1, totalLength, elementPerRow]);
            for (var i2 = 0; i2 < length.length; ++i2) {
              var previousLength = i2 === 0 ? 0 : cumulativeLengths[i2 - 1];
              var indices = [0, previousLength, 0];
              var sizes = [1, length[i2], elementPerRow];
              tensors2[i2] = tfOps.reshape(tfOps.slice(tensor, indices, sizes), outputElementShape);
            }
            tensor.dispose();
            return tensors2;
          });
          var list = new TensorList([], elementShape, tensor.dtype, length.length);
          for (var i = 0; i < tensors.length; i++) {
            list.setItem(i, tensors[i]);
          }
          return list;
        }
        var _this = void 0;
        var executeOp$2 = function(node, tensorMap, context) {
          return __awaiter2(_this, void 0, void 0, function() {
            var _a, thenFunc, elseFunc, cond, args, condValue, bodyFunc, condFunc, args, condResult, argIds_1, condValue, result2, _loop_1, pred, pred, data, inputName, data, frameId, data, data, data, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name_1, tensorArray, id, index2, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray, idTensor, index2, writeTensor, tensorList, idTensor, readIndex, elementShape, elementDType, tensorList, scatterIndices, scatterTensor, elementShape, numElements, tensorList, elementShape, elementDtype, numElementsParam, numElements, tensorList, gatherId, gatherIndices, elementShape, elementDtype, tensorList, idTensor, elementShape, elementDtype, numElements, tensorList, tensor, elementShape, elementDtype, tensorList, concatId, tensorList, concatDtype, elementShape, idTensor, writeTensor, tensorList, idTensor, elementShape, elementDType, tensorList, splitTensor, elementShape, lengths, tensorList;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = node.op;
                  switch (_a) {
                    case "If":
                      return [3, 1];
                    case "StatelessIf":
                      return [3, 1];
                    case "While":
                      return [3, 3];
                    case "StatelessWhile":
                      return [3, 3];
                    case "LoopCond":
                      return [3, 9];
                    case "Switch":
                      return [3, 10];
                    case "Merge":
                      return [3, 12];
                    case "Enter":
                      return [3, 13];
                    case "Exit":
                      return [3, 14];
                    case "NextIteration":
                      return [3, 15];
                    case "TensorArrayV3":
                      return [3, 16];
                    case "TensorArrayWriteV3":
                      return [3, 17];
                    case "TensorArrayReadV3":
                      return [3, 18];
                    case "TensorArrayGatherV3":
                      return [3, 19];
                    case "TensorArrayScatterV3":
                      return [3, 20];
                    case "TensorArrayConcatV3":
                      return [3, 21];
                    case "TensorArraySplitV3":
                      return [3, 22];
                    case "TensorArraySizeV3":
                      return [3, 23];
                    case "TensorArrayCloseV3":
                      return [3, 24];
                    case "TensorListSetItem":
                      return [3, 25];
                    case "TensorListGetItem":
                      return [3, 26];
                    case "TensorListScatterV2":
                      return [3, 27];
                    case "TensorListScatter":
                      return [3, 27];
                    case "TensorListReserve":
                      return [3, 28];
                    case "EmptyTensorList":
                      return [3, 28];
                    case "TensorListGather":
                      return [3, 29];
                    case "TensorListStack":
                      return [3, 30];
                    case "TensorListFromTensor":
                      return [3, 31];
                    case "TensorListConcat":
                      return [3, 32];
                    case "TensorListPushBack":
                      return [3, 33];
                    case "TensorListPopBack":
                      return [3, 34];
                    case "TensorListSplit":
                      return [3, 35];
                  }
                  return [3, 36];
                case 1:
                  thenFunc = getParamValue("thenBranch", node, tensorMap, context);
                  elseFunc = getParamValue("elseBranch", node, tensorMap, context);
                  cond = getParamValue("cond", node, tensorMap, context);
                  args = getParamValue("args", node, tensorMap, context);
                  return [4, cond.data()];
                case 2:
                  condValue = _b.sent();
                  if (condValue[0]) {
                    return [2, context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];
                  } else {
                    return [2, context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];
                  }
                case 3:
                  bodyFunc = getParamValue("body", node, tensorMap, context);
                  condFunc = getParamValue("cond", node, tensorMap, context);
                  args = getParamValue("args", node, tensorMap, context);
                  return [4, context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];
                case 4:
                  condResult = _b.sent();
                  argIds_1 = args.map(function(tensor2) {
                    return tensor2.id;
                  });
                  return [4, condResult[0].data()];
                case 5:
                  condValue = _b.sent();
                  condResult.forEach(function(tensor2) {
                    if (!tensor2.kept && argIds_1.indexOf(tensor2.id) === -1) {
                      tensor2.dispose();
                    }
                  });
                  result2 = args;
                  _loop_1 = function() {
                    var origResult, resultIds, condResult_1;
                    return __generator2(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          origResult = result2;
                          return [4, context.functionMap[bodyFunc].executeFunctionAsync(result2, context.tensorArrayMap, context.tensorListMap)];
                        case 1:
                          result2 = _a2.sent();
                          resultIds = result2.map(function(tensor2) {
                            return tensor2.id;
                          });
                          origResult.forEach(function(tensor2) {
                            if (!tensor2.kept && argIds_1.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
                              tensor2.dispose();
                            }
                          });
                          return [4, context.functionMap[condFunc].executeFunctionAsync(result2, context.tensorArrayMap, context.tensorListMap)];
                        case 2:
                          condResult_1 = _a2.sent();
                          return [4, condResult_1[0].data()];
                        case 3:
                          condValue = _a2.sent();
                          condResult_1.forEach(function(tensor2) {
                            if (!tensor2.kept && argIds_1.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
                              tensor2.dispose();
                            }
                          });
                          return [2];
                      }
                    });
                  };
                  _b.label = 6;
                case 6:
                  if (!condValue[0])
                    return [3, 8];
                  return [5, _loop_1()];
                case 7:
                  _b.sent();
                  return [3, 6];
                case 8:
                  return [2, result2];
                case 9: {
                  pred = getParamValue("pred", node, tensorMap, context);
                  return [2, [cloneTensor(pred)]];
                }
                case 10:
                  pred = getParamValue("pred", node, tensorMap, context);
                  data = getParamValue("data", node, tensorMap, context);
                  if (!data.kept) {
                    data = cloneTensor(data);
                  }
                  return [4, pred.data()];
                case 11:
                  return [2, _b.sent()[0] ? [void 0, data] : [data, void 0]];
                case 12: {
                  inputName = node.inputNames.find(function(name) {
                    return getTensor(name, tensorMap, context) !== void 0;
                  });
                  if (inputName) {
                    data = getTensor(inputName, tensorMap, context);
                    return [2, [cloneTensor(data)]];
                  }
                  return [2, void 0];
                }
                case 13: {
                  frameId = getParamValue("frameName", node, tensorMap, context);
                  data = getParamValue("tensor", node, tensorMap, context);
                  context.enterFrame(frameId);
                  return [2, [cloneTensor(data)]];
                }
                case 14: {
                  data = getParamValue("tensor", node, tensorMap, context);
                  context.exitFrame();
                  return [2, [cloneTensor(data)]];
                }
                case 15: {
                  data = getParamValue("tensor", node, tensorMap, context);
                  context.nextIteration();
                  return [2, [cloneTensor(data)]];
                }
                case 16: {
                  size = getParamValue("size", node, tensorMap, context);
                  dtype = getParamValue("dtype", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  dynamicSize = getParamValue("dynamicSize", node, tensorMap, context);
                  clearAfterRead = getParamValue("clearAfterRead", node, tensorMap, context);
                  identicalElementShapes = getParamValue("identicalElementShapes", node, tensorMap, context);
                  name_1 = getParamValue("name", node, tensorMap, context);
                  tensorArray = new TensorArray(name_1, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
                  context.addTensorArray(tensorArray);
                  return [2, [tensorArray.idTensor, tfOps.scalar(1)]];
                }
                case 17: {
                  id = getParamValue("tensorArrayId", node, tensorMap, context);
                  index2 = getParamValue("index", node, tensorMap, context);
                  writeTensor = getParamValue("tensor", node, tensorMap, context);
                  writeTensorArray = context.getTensorArray(id.id);
                  writeTensorArray.write(index2, writeTensor);
                  return [2, [writeTensorArray.idTensor]];
                }
                case 18: {
                  readId = getParamValue("tensorArrayId", node, tensorMap, context);
                  readIndex = getParamValue("index", node, tensorMap, context);
                  readTensorArray = context.getTensorArray(readId.id);
                  return [2, [readTensorArray.read(readIndex)]];
                }
                case 19: {
                  gatherId = getParamValue("tensorArrayId", node, tensorMap, context);
                  gatherIndices = getParamValue("indices", node, tensorMap, context);
                  gatherDtype = getParamValue("dtype", node, tensorMap, context);
                  gatherTensorArray = context.getTensorArray(gatherId.id);
                  return [2, [gatherTensorArray.gather(gatherIndices, gatherDtype)]];
                }
                case 20: {
                  scatterId = getParamValue("tensorArrayId", node, tensorMap, context);
                  scatterIndices = getParamValue("indices", node, tensorMap, context);
                  scatterTensor = getParamValue("tensor", node, tensorMap, context);
                  scatterTensorArray = context.getTensorArray(scatterId.id);
                  scatterTensorArray.scatter(scatterIndices, scatterTensor);
                  return [2, [scatterTensorArray.idTensor]];
                }
                case 21: {
                  concatId = getParamValue("tensorArrayId", node, tensorMap, context);
                  concatTensorArray = context.getTensorArray(concatId.id);
                  concatDtype = getParamValue("dtype", node, tensorMap, context);
                  return [2, [concatTensorArray.concat(concatDtype)]];
                }
                case 22: {
                  splitId = getParamValue("tensorArrayId", node, tensorMap, context);
                  splitTensor = getParamValue("tensor", node, tensorMap, context);
                  lengths = getParamValue("lengths", node, tensorMap, context);
                  splitTensorArray = context.getTensorArray(splitId.id);
                  splitTensorArray.split(lengths, splitTensor);
                  return [2, [splitTensorArray.idTensor]];
                }
                case 23: {
                  sizeId = getParamValue("tensorArrayId", node, tensorMap, context);
                  sizeTensorArray = context.getTensorArray(sizeId.id);
                  return [2, [tfOps.scalar(sizeTensorArray.size(), "int32")]];
                }
                case 24: {
                  closeId = getParamValue("tensorArrayId", node, tensorMap, context);
                  closeTensorArray = context.getTensorArray(closeId.id);
                  closeTensorArray.clearAndClose();
                  return [2, [closeTensorArray.idTensor]];
                }
                case 25: {
                  idTensor = getParamValue("tensorListId", node, tensorMap, context);
                  index2 = getParamValue("index", node, tensorMap, context);
                  writeTensor = getParamValue("tensor", node, tensorMap, context);
                  tensorList = context.getTensorList(idTensor.id);
                  tensorList.setItem(index2, writeTensor);
                  return [2, [tensorList.idTensor]];
                }
                case 26: {
                  idTensor = getParamValue("tensorListId", node, tensorMap, context);
                  readIndex = getParamValue("index", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDType = getParamValue("elementDType", node, tensorMap, context);
                  tensorList = context.getTensorList(idTensor.id);
                  return [2, [tensorList.getItem(readIndex, elementShape, elementDType)]];
                }
                case 27: {
                  scatterIndices = getParamValue("indices", node, tensorMap, context);
                  scatterTensor = getParamValue("tensor", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  numElements = getParamValue("numElements", node, tensorMap, context);
                  tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
                  context.addTensorList(tensorList);
                  return [2, [tensorList.idTensor]];
                }
                case 28: {
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDtype = getParamValue("elementDType", node, tensorMap, context);
                  numElementsParam = void 0;
                  if (node.op === "TensorListReserve") {
                    numElementsParam = "numElements";
                  } else {
                    numElementsParam = "maxNumElements";
                  }
                  numElements = getParamValue(numElementsParam, node, tensorMap, context);
                  tensorList = reserve(elementShape, elementDtype, numElements);
                  context.addTensorList(tensorList);
                  return [2, [tensorList.idTensor]];
                }
                case 29: {
                  gatherId = getParamValue("tensorListId", node, tensorMap, context);
                  gatherIndices = getParamValue("indices", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDtype = getParamValue("elementDType", node, tensorMap, context);
                  tensorList = context.getTensorList(gatherId.id);
                  return [2, [tensorList.gather(gatherIndices, elementDtype, elementShape)]];
                }
                case 30: {
                  idTensor = getParamValue("tensorListId", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDtype = getParamValue("elementDType", node, tensorMap, context);
                  numElements = getParamValue("numElements", node, tensorMap, context);
                  tensorList = context.getTensorList(idTensor.id);
                  return [2, [tensorList.stack(elementShape, elementDtype, numElements)]];
                }
                case 31: {
                  tensor = getParamValue("tensor", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDtype = getParamValue("elementDType", node, tensorMap, context);
                  tensorList = fromTensor(tensor, elementShape, elementDtype);
                  context.addTensorList(tensorList);
                  return [2, [tensorList.idTensor]];
                }
                case 32: {
                  concatId = getParamValue("tensorListId", node, tensorMap, context);
                  tensorList = context.getTensorList(concatId.id);
                  concatDtype = getParamValue("dtype", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  return [2, [tensorList.concat(concatDtype, elementShape)]];
                }
                case 33: {
                  idTensor = getParamValue("tensorListId", node, tensorMap, context);
                  writeTensor = getParamValue("tensor", node, tensorMap, context);
                  tensorList = context.getTensorList(idTensor.id);
                  tensorList.pushBack(writeTensor);
                  return [2, [tensorList.idTensor]];
                }
                case 34: {
                  idTensor = getParamValue("tensorListId", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  elementDType = getParamValue("elementDType", node, tensorMap, context);
                  tensorList = context.getTensorList(idTensor.id);
                  return [2, [tensorList.popBack(elementShape, elementDType)]];
                }
                case 35: {
                  splitTensor = getParamValue("tensor", node, tensorMap, context);
                  elementShape = getParamValue("elementShape", node, tensorMap, context);
                  lengths = getParamValue("lengths", node, tensorMap, context);
                  tensorList = split2(splitTensor, lengths, elementShape);
                  context.addTensorList(tensorList);
                  return [2, [tensorList.idTensor]];
                }
                case 36:
                  throw TypeError("Node type " + node.op + " is not implemented");
              }
            });
          });
        };
        function fusedConvAndDepthWiseParams(node, tensorMap, context) {
          var _a = __read(getParamValue("fusedOps", node, tensorMap, context), 2), extraOp = _a[0], activationFunc = _a[1];
          var isBiasAdd = extraOp === "biasadd";
          var isPrelu = activationFunc === "prelu";
          var isBatchNorm = extraOp === "fusedbatchnorm";
          var numArgs = getParamValue("numArgs", node, tensorMap, context);
          if (isBiasAdd) {
            if (isPrelu && numArgs !== 2) {
              throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            }
            if (!isPrelu && numArgs !== 1) {
              throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
            }
          }
          if (isBatchNorm) {
            throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
          }
          var stride = getParamValue("strides", node, tensorMap, context);
          var pad = getPadding(node, tensorMap, context);
          var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          var dilations = getParamValue("dilations", node, tensorMap, context);
          var _b = __read(getParamValue("args", node, tensorMap, context), 2), biasArg = _b[0], preluArg = _b[1];
          var leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
          return {
            stride,
            pad,
            dataFormat,
            dilations,
            biasArg,
            preluArg,
            activationFunc,
            leakyreluAlpha
          };
        }
        var executeOp$3 = function(node, tensorMap, context) {
          switch (node.op) {
            case "Conv1D": {
              var stride = getParamValue("stride", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
              var dilation = getParamValue("dilation", node, tensorMap, context);
              return [tfOps.conv1d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), stride, pad, dataFormat, dilation)];
            }
            case "Conv2D": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getPadding(node, tensorMap, context);
              var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
              var dilations = getParamValue("dilations", node, tensorMap, context);
              return [tfOps.conv2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];
            }
            case "_FusedConv2D": {
              var _a = fusedConvAndDepthWiseParams(node, tensorMap, context), stride = _a.stride, pad = _a.pad, dataFormat = _a.dataFormat, dilations = _a.dilations, biasArg = _a.biasArg, preluArg = _a.preluArg, activationFunc = _a.activationFunc, leakyreluAlpha = _a.leakyreluAlpha;
              return [tfOps.fused.conv2d({
                x: getParamValue("x", node, tensorMap, context),
                filter: getParamValue("filter", node, tensorMap, context),
                strides: [stride[1], stride[2]],
                pad,
                dataFormat,
                dilations: [dilations[1], dilations[2]],
                bias: biasArg,
                activation: activationFunc,
                preluActivationWeights: preluArg,
                leakyreluAlpha
              })];
            }
            case "FusedDepthwiseConv2dNative": {
              var _b = fusedConvAndDepthWiseParams(node, tensorMap, context), stride = _b.stride, pad = _b.pad, dataFormat = _b.dataFormat, dilations = _b.dilations, biasArg = _b.biasArg, preluArg = _b.preluArg, activationFunc = _b.activationFunc, leakyreluAlpha = _b.leakyreluAlpha;
              return [tfOps.fused.depthwiseConv2d({
                x: getParamValue("x", node, tensorMap, context),
                filter: getParamValue("filter", node, tensorMap, context),
                strides: [stride[1], stride[2]],
                pad,
                dataFormat,
                dilations: [dilations[1], dilations[2]],
                bias: biasArg,
                activation: activationFunc,
                preluActivationWeights: preluArg,
                leakyreluAlpha
              })];
            }
            case "Conv2DBackpropInput":
            case "Conv2dTranspose": {
              var shape = getParamValue("outputShape", node, tensorMap, context);
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getPadding(node, tensorMap, context);
              return [tfOps.conv2dTranspose(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad)];
            }
            case "DepthwiseConv2dNative":
            case "DepthwiseConv2d": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getPadding(node, tensorMap, context);
              var dilations = getParamValue("dilations", node, tensorMap, context);
              var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
              return [tfOps.depthwiseConv2d(getParamValue("input", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];
            }
            case "Conv3D": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
              var dilations = getParamValue("dilations", node, tensorMap, context);
              return [tfOps.conv3d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2], stride[3]], pad, dataFormat, [dilations[1], dilations[2], dilations[3]])];
            }
            case "AvgPool": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var kernelSize = getParamValue("kernelSize", node, tensorMap, context);
              return [tfOps.avgPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
            }
            case "MaxPool": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var kernelSize = getParamValue("kernelSize", node, tensorMap, context);
              return [tfOps.maxPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
            }
            case "MaxPoolWithArgmax": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var kernelSize = getParamValue("kernelSize", node, tensorMap, context);
              var includeBatchInIndex = getParamValue("includeBatchInIndex", node, tensorMap, context);
              var _c = tfOps.maxPoolWithArgmax(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad, includeBatchInIndex), result2 = _c.result, indexes = _c.indexes;
              return [result2, indexes];
            }
            case "AvgPool3D": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var kernelSize = getParamValue("kernelSize", node, tensorMap, context);
              return [tfOps.avgPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];
            }
            case "MaxPool3D": {
              var stride = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var kernelSize = getParamValue("kernelSize", node, tensorMap, context);
              return [tfOps.maxPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];
            }
            case "Dilation2D": {
              var strides = getParamValue("strides", node, tensorMap, context);
              var pad = getParamValue("pad", node, tensorMap, context);
              var dilations = getParamValue("dilations", node, tensorMap, context);
              var strideHeight = strides[1];
              var strideWidth = strides[2];
              var dilationHeight = dilations[1];
              var dilationWidth = dilations[2];
              return [tfOps.dilation2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [strideHeight, strideWidth], pad, [dilationHeight, dilationWidth], "NHWC")];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$4 = function(node, tensorMap, context) {
          switch (node.op) {
            case "Fill": {
              var shape = getParamValue("shape", node, tensorMap, context);
              var dtype = getParamValue("dtype", node, tensorMap, context);
              var value = getParamValue("value", node, tensorMap, context);
              return [tfOps.fill(shape, value, dtype)];
            }
            case "LinSpace": {
              var start = getParamValue("start", node, tensorMap, context);
              var stop_1 = getParamValue("stop", node, tensorMap, context);
              var num = getParamValue("num", node, tensorMap, context);
              return [tfOps.linspace(start, stop_1, num)];
            }
            case "Multinomial": {
              var logits = getParamValue("logits", node, tensorMap, context);
              var numSamples = getParamValue("numSamples", node, tensorMap, context);
              var seed = getParamValue("seed", node, tensorMap, context);
              return [tfOps.multinomial(logits, numSamples, seed)];
            }
            case "OneHot": {
              var indices = getParamValue("indices", node, tensorMap, context);
              var depth = getParamValue("depth", node, tensorMap, context);
              var onValue = getParamValue("onValue", node, tensorMap, context);
              var offValue = getParamValue("offValue", node, tensorMap, context);
              return [tfOps.oneHot(indices, depth, onValue, offValue)];
            }
            case "Ones": {
              return [tfOps.ones(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
            }
            case "OnesLike": {
              return [tfOps.onesLike(getParamValue("x", node, tensorMap, context))];
            }
            case "RandomUniform": {
              return [tfOps.randomUniform(getParamValue("shape", node, tensorMap, context), getParamValue("minval", node, tensorMap, context), getParamValue("maxval", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
            }
            case "Range": {
              var start = getParamValue("start", node, tensorMap, context);
              var stop_2 = getParamValue("stop", node, tensorMap, context);
              var step3 = getParamValue("step", node, tensorMap, context);
              return [tfOps.range(start, stop_2, step3, getParamValue("dtype", node, tensorMap, context))];
            }
            case "TruncatedNormal": {
              var shape = getParamValue("shape", node, tensorMap, context);
              var mean = getParamValue("mean", node, tensorMap, context);
              var stdDev = getParamValue("stdDev", node, tensorMap, context);
              var seed = getParamValue("seed", node, tensorMap, context);
              return [tfOps.truncatedNormal(shape, mean, stdDev, getParamValue("dtype", node, tensorMap, context), seed)];
            }
            case "Zeros": {
              return [tfOps.zeros(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
            }
            case "ZerosLike": {
              return [tfOps.zerosLike(getParamValue("x", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var _this$1 = void 0;
        function nmsParams(node, tensorMap, context) {
          var boxes = getParamValue("boxes", node, tensorMap, context);
          var scores = getParamValue("scores", node, tensorMap, context);
          var maxOutputSize = getParamValue("maxOutputSize", node, tensorMap, context);
          var iouThreshold = getParamValue("iouThreshold", node, tensorMap, context);
          var scoreThreshold = getParamValue("scoreThreshold", node, tensorMap, context);
          var softNmsSigma = getParamValue("softNmsSigma", node, tensorMap, context);
          return {
            boxes,
            scores,
            maxOutputSize,
            iouThreshold,
            scoreThreshold,
            softNmsSigma
          };
        }
        var executeOp$5 = function(node, tensorMap, context) {
          return __awaiter2(_this$1, void 0, void 0, function() {
            var _a, _b, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, result2, _c, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize, result2, _d, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, condition, result2;
            return __generator2(this, function(_e) {
              switch (_e.label) {
                case 0:
                  _a = node.op;
                  switch (_a) {
                    case "NonMaxSuppressionV5":
                      return [3, 1];
                    case "NonMaxSuppressionV4":
                      return [3, 3];
                    case "NonMaxSuppressionV3":
                      return [3, 5];
                    case "NonMaxSuppressionV2":
                      return [3, 5];
                    case "Where":
                      return [3, 7];
                    case "ListDiff":
                      return [3, 9];
                  }
                  return [3, 10];
                case 1:
                  _b = nmsParams(node, tensorMap, context), boxes = _b.boxes, scores = _b.scores, maxOutputSize = _b.maxOutputSize, iouThreshold = _b.iouThreshold, scoreThreshold = _b.scoreThreshold, softNmsSigma = _b.softNmsSigma;
                  return [4, tfOps.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma)];
                case 2:
                  result2 = _e.sent();
                  return [2, [result2.selectedIndices, result2.selectedScores]];
                case 3:
                  _c = nmsParams(node, tensorMap, context), boxes = _c.boxes, scores = _c.scores, maxOutputSize = _c.maxOutputSize, iouThreshold = _c.iouThreshold, scoreThreshold = _c.scoreThreshold;
                  padToMaxOutputSize = getParamValue("padToMaxOutputSize", node, tensorMap, context);
                  return [4, tfOps.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize)];
                case 4:
                  result2 = _e.sent();
                  return [2, [result2.selectedIndices, result2.validOutputs]];
                case 5:
                  _d = nmsParams(node, tensorMap, context), boxes = _d.boxes, scores = _d.scores, maxOutputSize = _d.maxOutputSize, iouThreshold = _d.iouThreshold, scoreThreshold = _d.scoreThreshold;
                  return [4, tfOps.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
                case 6:
                  return [2, [_e.sent()]];
                case 7:
                  condition = tfOps.cast(getParamValue("condition", node, tensorMap, context), "bool");
                  return [4, tfOps.whereAsync(condition)];
                case 8:
                  result2 = [_e.sent()];
                  condition.dispose();
                  return [2, result2];
                case 9: {
                  return [2, tfOps.setdiff1dAsync(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context))];
                }
                case 10:
                  throw TypeError("Node type " + node.op + " is not implemented");
              }
            });
          });
        };
        var executeOp$6 = function(node, tensorMap, context) {
          switch (node.op) {
            case "TopKV2": {
              var x = getParamValue("x", node, tensorMap, context);
              var k = getParamValue("k", node, tensorMap, context);
              var sorted = getParamValue("sorted", node, tensorMap, context);
              var result2 = tfOps.topk(x, k, sorted);
              return [result2.values, result2.indices];
            }
            case "Unique": {
              var x = getParamValue("x", node, tensorMap, context);
              var result2 = tfOps.unique(x);
              return [result2.values, result2.indices];
            }
            case "UniqueV2": {
              var x = getParamValue("x", node, tensorMap, context);
              var axis = getParamValue("axis", node, tensorMap, context);
              var result2 = tfOps.unique(x, axis);
              return [result2.values, result2.indices];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$7 = function(node, tensorMap, context) {
          switch (node.op) {
            case "Const": {
              return tensorMap[node.name];
            }
            case "PlaceholderWithDefault":
              var def = getParamValue("default", node, tensorMap, context);
              return [getTensor(node.name, tensorMap, context) || def];
            case "Placeholder":
              return [getTensor(node.name, tensorMap, context)];
            case "Identity":
            case "StopGradient":
            case "FakeQuantWithMinMaxVars": {
              var data_1 = getParamValue("x", node, tensorMap, context);
              return [cloneTensor(data_1)];
            }
            case "IdentityN":
              return getParamValue("x", node, tensorMap, context).map(function(t) {
                return cloneTensor(t);
              });
            case "Snapshot":
              var snapshot = getParamValue("x", node, tensorMap, context);
              return [cloneTensor(snapshot)];
            case "Shape":
              return [tfOps.tensor1d(getParamValue("x", node, tensorMap, context).shape, "int32")];
            case "ShapeN":
              return getParamValue("x", node, tensorMap, context).map(function(t) {
                return tfOps.tensor1d(t.shape);
              });
            case "Size":
              return [tfOps.scalar(getParamValue("x", node, tensorMap, context).size, "int32")];
            case "Rank":
              return [tfOps.scalar(getParamValue("x", node, tensorMap, context).rank, "int32")];
            case "NoOp":
              return [tfOps.scalar(1)];
            case "Print":
              var input = getParamValue("x", node, tensorMap, context);
              var data = getParamValue("data", node, tensorMap, context);
              var message = getParamValue("message", node, tensorMap, context);
              var summarize = getParamValue("summarize", node, tensorMap, context);
              console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
              console.log(message);
              for (var i = 0; i < data.length; i++) {
                console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));
              }
              return [input];
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var HashTable = function() {
          function HashTable2(keyDType, valueDType) {
            this.keyDType = keyDType;
            this.valueDType = valueDType;
            this.handle = tfOps.scalar(0);
            this.tensorMap = new Map();
            tfOps.keep(this.handle);
          }
          Object.defineProperty(HashTable2.prototype, "id", {
            get: function() {
              return this.handle.id;
            },
            enumerable: true,
            configurable: true
          });
          HashTable2.prototype.clearAndClose = function() {
            this.tensorMap.forEach(function(value) {
              return value.dispose();
            });
            this.tensorMap.clear();
            this.handle.dispose();
          };
          HashTable2.prototype.size = function() {
            return this.tensorMap.size;
          };
          HashTable2.prototype.tensorSize = function() {
            return tfOps.scalar(this.size(), "int32");
          };
          HashTable2.prototype.import = function(keys, values) {
            return __awaiter2(this, void 0, void 0, function() {
              var $keys;
              var _this2 = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.checkKeyAndValueTensor(keys, values);
                    return [4, keys.data()];
                  case 1:
                    $keys = _a.sent();
                    this.tensorMap.forEach(function(value) {
                      return value.dispose();
                    });
                    this.tensorMap.clear();
                    return [2, tfOps.tidy(function() {
                      var $values = tfOps.unstack(values);
                      var keysLength = $keys.length;
                      var valuesLength = $values.length;
                      tfOps.util.assert(keysLength === valuesLength, function() {
                        return "The number of elements doesn't match, keys has " + (keysLength + " elements, the values has " + valuesLength + " ") + "elements.";
                      });
                      for (var i = 0; i < keysLength; i++) {
                        var key = $keys[i];
                        var value = $values[i];
                        tfOps.keep(value);
                        _this2.tensorMap.set(key, value);
                      }
                      return _this2.handle;
                    })];
                }
              });
            });
          };
          HashTable2.prototype.find = function(keys, defaultValue) {
            return __awaiter2(this, void 0, void 0, function() {
              var $keys;
              var _this2 = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.checkKeyAndValueTensor(keys, defaultValue);
                    return [4, keys.data()];
                  case 1:
                    $keys = _a.sent();
                    return [2, tfOps.tidy(function() {
                      var result2 = [];
                      for (var i = 0; i < $keys.length; i++) {
                        var key = $keys[i];
                        var value = _this2.findWithDefault(key, defaultValue);
                        result2.push(value);
                      }
                      return tfOps.stack(result2);
                    })];
                }
              });
            });
          };
          HashTable2.prototype.findWithDefault = function(key, defaultValue) {
            var result2 = this.tensorMap.get(key);
            return result2 != null ? result2 : defaultValue;
          };
          HashTable2.prototype.checkKeyAndValueTensor = function(key, value) {
            if (key.dtype !== this.keyDType) {
              throw new Error("Expect key dtype " + this.keyDType + ", but got " + ("" + key.dtype));
            }
            if (value.dtype !== this.valueDType) {
              throw new Error("Expect value dtype " + this.valueDType + ", but got " + ("" + value.dtype));
            }
          };
          return HashTable2;
        }();
        var _this$2 = void 0;
        var executeOp$8 = function(node, tensorMap, context, resourceManager) {
          return __awaiter2(_this$2, void 0, void 0, function() {
            var _a, keyDType, valueDType, hashTable2, handle, keys, values, hashTable2, handle, keys, defaultValue, hashTable2, handle, hashTable2;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = node.op;
                  switch (_a) {
                    case "HashTable":
                      return [3, 1];
                    case "HashTableV2":
                      return [3, 1];
                    case "LookupTableImport":
                      return [3, 2];
                    case "LookupTableImportV2":
                      return [3, 2];
                    case "LookupTableFind":
                      return [3, 4];
                    case "LookupTableFindV2":
                      return [3, 4];
                    case "LookupTableSize":
                      return [3, 6];
                    case "LookupTableSizeV2":
                      return [3, 6];
                  }
                  return [3, 7];
                case 1: {
                  keyDType = getParamValue("keyDType", node, tensorMap, context);
                  valueDType = getParamValue("valueDType", node, tensorMap, context);
                  hashTable2 = new HashTable(keyDType, valueDType);
                  resourceManager.addHashTable(node.name, hashTable2);
                  return [2, [hashTable2.handle]];
                }
                case 2:
                  handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
                  keys = getParamValue("keys", node, tensorMap, context);
                  values = getParamValue("values", node, tensorMap, context);
                  hashTable2 = resourceManager.getHashTableById(handle.id);
                  return [4, hashTable2.import(keys, values)];
                case 3:
                  return [2, [_b.sent()]];
                case 4:
                  handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
                  keys = getParamValue("keys", node, tensorMap, context);
                  defaultValue = getParamValue("defaultValue", node, tensorMap, context);
                  hashTable2 = resourceManager.getHashTableById(handle.id);
                  return [4, hashTable2.find(keys, defaultValue)];
                case 5:
                  return [2, [_b.sent()]];
                case 6: {
                  handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
                  hashTable2 = resourceManager.getHashTableById(handle.id);
                  return [2, [hashTable2.tensorSize()]];
                }
                case 7:
                  throw TypeError("Node type " + node.op + " is not implemented");
              }
            });
          });
        };
        var executeOp$9 = function(node, tensorMap, context) {
          switch (node.op) {
            case "ResizeBilinear": {
              var images = getParamValue("images", node, tensorMap, context);
              var size = getParamValue("size", node, tensorMap, context);
              var alignCorners = getParamValue("alignCorners", node, tensorMap, context);
              var halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
              return [tfOps.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
            }
            case "ResizeNearestNeighbor": {
              var images = getParamValue("images", node, tensorMap, context);
              var size = getParamValue("size", node, tensorMap, context);
              var alignCorners = getParamValue("alignCorners", node, tensorMap, context);
              var halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
              return [tfOps.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
            }
            case "CropAndResize": {
              var image3 = getParamValue("image", node, tensorMap, context);
              var boxes = getParamValue("boxes", node, tensorMap, context);
              var boxInd = getParamValue("boxInd", node, tensorMap, context);
              var cropSize = getParamValue("cropSize", node, tensorMap, context);
              var method = getParamValue("method", node, tensorMap, context);
              var extrapolationValue = getParamValue("extrapolationValue", node, tensorMap, context);
              return [tfOps.image.cropAndResize(image3, boxes, boxInd, cropSize, method, extrapolationValue)];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$a = function(node, tensorMap, context) {
          switch (node.op) {
            case "Equal": {
              return [tfOps.equal(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "NotEqual": {
              return [tfOps.notEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Greater": {
              return [tfOps.greater(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "GreaterEqual": {
              return [tfOps.greaterEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Less": {
              return [tfOps.less(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "LessEqual": {
              return [tfOps.lessEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "LogicalAnd": {
              return [tfOps.logicalAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "LogicalNot": {
              return [tfOps.logicalNot(getParamValue("a", node, tensorMap, context))];
            }
            case "LogicalOr": {
              return [tfOps.logicalOr(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            case "Select":
            case "SelectV2": {
              return [tfOps.where(getParamValue("condition", node, tensorMap, context), getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$b = function(node, tensorMap, context) {
          switch (node.op) {
            case "BatchMatMul":
            case "BatchMatMulV2":
            case "MatMul":
              return [tfOps.matMul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context), getParamValue("transposeA", node, tensorMap, context), getParamValue("transposeB", node, tensorMap, context))];
            case "Einsum":
              return [tfOps.einsum.apply(tfOps, __spread([getParamValue("equation", node, tensorMap, context)], getParamValue("tensors", node, tensorMap, context)))];
            case "Transpose":
              return [tfOps.transpose(getParamValue("x", node, tensorMap, context), getParamValue("perm", node, tensorMap, context))];
            case "_FusedMatMul":
              var _a = __read(getParamValue("fusedOps", node, tensorMap, context), 2), extraOp = _a[0], activationFunc = _a[1];
              var isBiasAdd = extraOp === "biasadd";
              var isPrelu = activationFunc === "prelu";
              var numArgs = getParamValue("numArgs", node, tensorMap, context);
              var leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
              if (isBiasAdd) {
                if (isPrelu && numArgs !== 2) {
                  throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                }
                if (!isPrelu && numArgs !== 1) {
                  throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
                }
              }
              var _b = __read(getParamValue("args", node, tensorMap, context), 2), biasArg = _b[0], preluArg = _b[1];
              return [tfOps.fused.matMul({
                a: getParamValue("a", node, tensorMap, context),
                b: getParamValue("b", node, tensorMap, context),
                transposeA: getParamValue("transposeA", node, tensorMap, context),
                transposeB: getParamValue("transposeB", node, tensorMap, context),
                bias: biasArg,
                activation: activationFunc,
                preluActivationWeights: preluArg,
                leakyreluAlpha
              })];
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$c = function(node, tensorMap, context) {
          switch (node.op) {
            case "FusedBatchNorm":
            case "FusedBatchNormV2": {
              return [tfOps.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
            }
            case "FusedBatchNormV3": {
              return [tfOps.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
            }
            case "LRN": {
              return [tfOps.localResponseNormalization(getParamValue("x", node, tensorMap, context), getParamValue("radius", node, tensorMap, context), getParamValue("bias", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context), getParamValue("beta", node, tensorMap, context))];
            }
            case "Softmax": {
              return [tfOps.softmax(getParamValue("x", node, tensorMap, context))];
            }
            case "LogSoftmax": {
              return [tfOps.logSoftmax(getParamValue("x", node, tensorMap, context))];
            }
            case "SparseToDense": {
              return [tfOps.sparseToDense(getParamValue("sparseIndices", node, tensorMap, context), getParamValue("outputShape", node, tensorMap, context), getParamValue("sparseValues", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$d = function(node, tensorMap, context) {
          switch (node.op) {
            case "Max": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.max(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "Mean": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.mean(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "Min": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.min(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "Sum": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.sum(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "All": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.all(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "Any": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.any(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "ArgMax": {
              var axis = getParamValue("axis", node, tensorMap, context);
              return [tfOps.argMax(getParamValue("x", node, tensorMap, context), axis)];
            }
            case "ArgMin": {
              var axis = getParamValue("axis", node, tensorMap, context);
              return [tfOps.argMin(getParamValue("x", node, tensorMap, context), axis)];
            }
            case "Prod": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var keepDims = getParamValue("keepDims", node, tensorMap, context);
              return [tfOps.prod(getParamValue("x", node, tensorMap, context), axis, keepDims)];
            }
            case "Cumsum": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var exclusive = getParamValue("exclusive", node, tensorMap, context);
              var reverse2 = getParamValue("reverse", node, tensorMap, context);
              return [tfOps.cumsum(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse2)];
            }
            case "Bincount":
              var x = getParamValue("x", node, tensorMap, context);
              var weights = getParamValue("weights", node, tensorMap, context);
              var size = getParamValue("size", node, tensorMap, context);
              return [tfOps.bincount(x, weights, size)];
            case "DenseBincount": {
              var x_1 = getParamValue("x", node, tensorMap, context);
              var weights_1 = getParamValue("weights", node, tensorMap, context);
              var size_1 = getParamValue("size", node, tensorMap, context);
              var binaryOutput = getParamValue("binaryOutput", node, tensorMap, context);
              return [tfOps.denseBincount(x_1, weights_1, size_1, binaryOutput)];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$e = function(node, tensorMap, context) {
          switch (node.op) {
            case "ConcatV2":
            case "Concat": {
              var n = getParamValue("n", node, tensorMap, context);
              var axis = getParamValue("axis", node, tensorMap, context);
              var inputs = getParamValue("tensors", node, tensorMap, context);
              inputs = inputs.slice(0, n);
              return [tfOps.concat(inputs, axis)];
            }
            case "Gather": {
              var input = getParamValue("x", node, tensorMap, context);
              var indices = getParamValue("indices", node, tensorMap, context);
              return [tfOps.gather(input, tfOps.cast(indices, "int32"), 0)];
            }
            case "GatherV2": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var batchDims = getParamValue("batchDims", node, tensorMap, context);
              var input = getParamValue("x", node, tensorMap, context);
              var indices = getParamValue("indices", node, tensorMap, context);
              return [tfOps.gather(input, tfOps.cast(indices, "int32"), axis, batchDims)];
            }
            case "Reverse": {
              var dims = getParamValue("dims", node, tensorMap, context);
              var axis = [];
              for (var i = 0; i < dims.length; i++) {
                if (dims[i]) {
                  axis.push(i);
                }
              }
              var input = getParamValue("x", node, tensorMap, context);
              return [tfOps.reverse(input, axis)];
            }
            case "ReverseV2": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var input = getParamValue("x", node, tensorMap, context);
              return [tfOps.reverse(input, axis)];
            }
            case "Slice": {
              var begin = getParamValue("begin", node, tensorMap, context);
              var size = getParamValue("size", node, tensorMap, context);
              return [tfOps.slice(getParamValue("x", node, tensorMap, context), begin, size)];
            }
            case "StridedSlice": {
              var begin = getParamValue("begin", node, tensorMap, context);
              var end = getParamValue("end", node, tensorMap, context);
              var strides = getParamValue("strides", node, tensorMap, context);
              var beginMask = getParamValue("beginMask", node, tensorMap, context);
              var endMask = getParamValue("endMask", node, tensorMap, context);
              var ellipsisMask = getParamValue("ellipsisMask", node, tensorMap, context);
              var newAxisMask = getParamValue("newAxisMask", node, tensorMap, context);
              var shrinkAxisMask = getParamValue("shrinkAxisMask", node, tensorMap, context);
              var tensor = getParamValue("x", node, tensorMap, context);
              return [tfOps.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
            }
            case "Pack": {
              return tfOps.tidy(function() {
                var axis2 = getParamValue("axis", node, tensorMap, context);
                var tensors = getParamValue("tensors", node, tensorMap, context);
                var shape2 = tensors[0].shape;
                var squeezedShape = tfOps.squeeze(tensors[0]).shape;
                var mapped = tensors.map(function(tensor2) {
                  var sameShape = tfOps.util.arraysEqual(tensor2.shape, shape2);
                  if (!sameShape && !tfOps.util.arraysEqual(tfOps.squeeze(tensor2).shape, squeezedShape)) {
                    throw new Error("the input tensors shape does not match");
                  }
                  return sameShape ? tensor2 : tfOps.reshape(tensor2, shape2);
                });
                return [tfOps.stack(mapped, axis2)];
              });
            }
            case "Unpack": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var tensor = getParamValue("tensor", node, tensorMap, context);
              return tfOps.unstack(tensor, axis);
            }
            case "Tile": {
              var reps = getParamValue("reps", node, tensorMap, context);
              return [tfOps.tile(getParamValue("x", node, tensorMap, context), reps)];
            }
            case "Split":
            case "SplitV": {
              var axis = getParamValue("axis", node, tensorMap, context);
              var numOrSizeSplits = getParamValue("numOrSizeSplits", node, tensorMap, context);
              var tensor = getParamValue("x", node, tensorMap, context);
              return tfOps.split(tensor, numOrSizeSplits, axis);
            }
            case "ScatterNd": {
              var indices = getParamValue("indices", node, tensorMap, context);
              var values = getParamValue("values", node, tensorMap, context);
              var shape = getParamValue("shape", node, tensorMap, context);
              return [tfOps.scatterND(indices, values, shape)];
            }
            case "GatherNd": {
              var x = getParamValue("x", node, tensorMap, context);
              var indices = getParamValue("indices", node, tensorMap, context);
              return [tfOps.gatherND(x, indices)];
            }
            case "SparseToDense": {
              var indices = getParamValue("sparseIndices", node, tensorMap, context);
              var shape = getParamValue("outputShape", node, tensorMap, context);
              var sparseValues = getParamValue("sparseValues", node, tensorMap, context);
              var defaultValue = getParamValue("defaultValue", node, tensorMap, context);
              return [tfOps.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : tfOps.cast(defaultValue, sparseValues.dtype))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$f = function(node, tensorMap, context) {
          switch (node.op) {
            case "SparseReshape": {
              var _a = tfOps.sparse.sparseReshape(getParamValue("inputIndices", node, tensorMap, context), getParamValue("inputShape", node, tensorMap, context), getParamValue("newShape", node, tensorMap, context)), outputIndices = _a.outputIndices, outputShape = _a.outputShape;
              return [outputIndices, outputShape];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$g = function(node, tensorMap, context) {
          switch (node.op) {
            case "FFT": {
              return [tfOps.fft(getParamValue("x", node, tensorMap, context))];
            }
            case "IFFT": {
              return [tfOps.ifft(getParamValue("x", node, tensorMap, context))];
            }
            case "RFFT": {
              return [tfOps.rfft(getParamValue("x", node, tensorMap, context))];
            }
            case "IRFFT": {
              return [tfOps.irfft(getParamValue("x", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        var executeOp$h = function(node, tensorMap, context) {
          switch (node.op) {
            case "Cast": {
              return [tfOps.cast(getParamValue("x", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
            }
            case "ExpandDims": {
              var axis = getParamValue("axis", node, tensorMap, context);
              return [tfOps.expandDims(getParamValue("x", node, tensorMap, context), axis)];
            }
            case "Squeeze": {
              var axis = getParamValue("axis", node, tensorMap, context);
              return [tfOps.squeeze(getParamValue("x", node, tensorMap, context), axis)];
            }
            case "Reshape": {
              return [tfOps.reshape(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
            }
            case "MirrorPad": {
              return [tfOps.mirrorPad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("mode", node, tensorMap, context))];
            }
            case "PadV2":
            case "Pad": {
              return [tfOps.pad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("constantValue", node, tensorMap, context))];
            }
            case "SpaceToBatchND": {
              var blockShape = getParamValue("blockShape", node, tensorMap, context);
              var paddings = getParamValue("paddings", node, tensorMap, context);
              return [tfOps.spaceToBatchND(getParamValue("x", node, tensorMap, context), blockShape, paddings)];
            }
            case "BatchToSpaceND": {
              var blockShape = getParamValue("blockShape", node, tensorMap, context);
              var crops = getParamValue("crops", node, tensorMap, context);
              return [tfOps.batchToSpaceND(getParamValue("x", node, tensorMap, context), blockShape, crops)];
            }
            case "DepthToSpace": {
              var blockSize = getParamValue("blockSize", node, tensorMap, context);
              var dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
              return [tfOps.depthToSpace(getParamValue("x", node, tensorMap, context), blockSize, dataFormat)];
            }
            case "BroadcastTo": {
              return [tfOps.broadcastTo(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
            }
            default:
              throw TypeError("Node type " + node.op + " is not implemented");
          }
        };
        function executeOp$i(node, tensorMap, context, resourceManager) {
          var value = function(node2, tensorMap2, context2) {
            switch (node2.category) {
              case "arithmetic":
                return tfOps.tidy(function() {
                  return executeOp(node2, tensorMap2, context2);
                });
              case "basic_math":
                return tfOps.tidy(function() {
                  return executeOp$1(node2, tensorMap2, context2);
                });
              case "control":
                return executeOp$2(node2, tensorMap2, context2);
              case "convolution":
                return tfOps.tidy(function() {
                  return executeOp$3(node2, tensorMap2, context2);
                });
              case "creation":
                return tfOps.tidy(function() {
                  return executeOp$4(node2, tensorMap2, context2);
                });
              case "dynamic":
                return executeOp$5(node2, tensorMap2, context2);
              case "evaluation":
                return tfOps.tidy(function() {
                  return executeOp$6(node2, tensorMap2, context2);
                });
              case "image":
                return tfOps.tidy(function() {
                  return executeOp$9(node2, tensorMap2, context2);
                });
              case "graph":
                return tfOps.tidy(function() {
                  return executeOp$7(node2, tensorMap2, context2);
                });
              case "logical":
                return tfOps.tidy(function() {
                  return executeOp$a(node2, tensorMap2, context2);
                });
              case "matrices":
                return tfOps.tidy(function() {
                  return executeOp$b(node2, tensorMap2, context2);
                });
              case "normalization":
                return tfOps.tidy(function() {
                  return executeOp$c(node2, tensorMap2, context2);
                });
              case "reduction":
                return tfOps.tidy(function() {
                  return executeOp$d(node2, tensorMap2, context2);
                });
              case "slice_join":
                return tfOps.tidy(function() {
                  return executeOp$e(node2, tensorMap2, context2);
                });
              case "sparse":
                return tfOps.tidy(function() {
                  return executeOp$f(node2, tensorMap2, context2);
                });
              case "spectral":
                return tfOps.tidy(function() {
                  return executeOp$g(node2, tensorMap2, context2);
                });
              case "transformation":
                return tfOps.tidy(function() {
                  return executeOp$h(node2, tensorMap2, context2);
                });
              case "hash_table":
                return executeOp$8(node2, tensorMap2, context2, resourceManager);
              case "custom":
                var opMapper = getRegisteredOp(node2.op);
                if (opMapper && opMapper.customExecutor) {
                  return opMapper.customExecutor(new NodeValueImpl(node2, tensorMap2, context2));
                } else {
                  throw TypeError("Custom op " + node2.op + " is not registered.");
                }
              default:
                throw TypeError("Unknown op '" + node2.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
            }
          }(node, tensorMap, context);
          if (tfOps.util.isPromise(value)) {
            return value.then(function(data) {
              return [].concat(data);
            });
          }
          return [].concat(value);
        }
        var ExecutionContext = function() {
          function ExecutionContext2(weightMap, tensorArrayMap, tensorListMap, functionMap) {
            if (weightMap === void 0) {
              weightMap = {};
            }
            if (tensorArrayMap === void 0) {
              tensorArrayMap = {};
            }
            if (tensorListMap === void 0) {
              tensorListMap = {};
            }
            if (functionMap === void 0) {
              functionMap = {};
            }
            this.weightMap = weightMap;
            this.tensorArrayMap = tensorArrayMap;
            this.tensorListMap = tensorListMap;
            this.functionMap = functionMap;
            this.rootContext = { id: 0, frameName: "", iterationId: 0 };
            this.contexts = [this.rootContext];
            this.lastId = 0;
            this.generateCurrentContextIds();
          }
          ExecutionContext2.prototype.newFrame = function(id, frameName) {
            return { id, frameName, iterationId: 0 };
          };
          Object.defineProperty(ExecutionContext2.prototype, "currentContext", {
            get: function() {
              return this.contexts;
            },
            set: function(contexts2) {
              if (this.contexts !== contexts2) {
                this.contexts = contexts2;
                this.generateCurrentContextIds();
              }
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(ExecutionContext2.prototype, "currentContextId", {
            get: function() {
              return this._currentContextIds[0];
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(ExecutionContext2.prototype, "currentContextIds", {
            get: function() {
              return this._currentContextIds;
            },
            enumerable: true,
            configurable: true
          });
          ExecutionContext2.prototype.generateCurrentContextIds = function() {
            var names = [];
            for (var i = 0; i < this.contexts.length - 1; i++) {
              var contexts2 = this.contexts.slice(0, this.contexts.length - i);
              names.push(this.contextIdforContexts(contexts2));
            }
            names.push("");
            this._currentContextIds = names;
          };
          ExecutionContext2.prototype.contextIdforContexts = function(contexts2) {
            return contexts2 ? contexts2.map(function(context) {
              return context.id === 0 && context.iterationId === 0 ? "" : context.frameName + "-" + context.iterationId;
            }).join("/") : "";
          };
          ExecutionContext2.prototype.enterFrame = function(frameId) {
            if (this.contexts) {
              this.lastId++;
              this.contexts = this.contexts.slice();
              this.contexts.push(this.newFrame(this.lastId, frameId));
              this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
            }
          };
          ExecutionContext2.prototype.exitFrame = function() {
            if (this.contexts && this.contexts.length > 1) {
              this.contexts = this.contexts.slice();
              this.contexts.splice(-1);
              this.currentContextIds.shift();
            } else {
              throw new Error("Cannot exit frame, the context is empty");
            }
          };
          ExecutionContext2.prototype.nextIteration = function() {
            if (this.contexts && this.contexts.length > 0) {
              this.contexts = this.contexts.slice();
              this.lastId++;
              var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
              context.iterationId += 1;
              context.id = this.lastId;
              this.contexts.splice(-1, 1, context);
              this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
            } else {
              throw new Error("Cannot increase frame iteration, the context is empty");
            }
          };
          ExecutionContext2.prototype.getWeight = function(name) {
            return this.weightMap[name];
          };
          ExecutionContext2.prototype.addTensorArray = function(tensorArray) {
            this.tensorArrayMap[tensorArray.id] = tensorArray;
          };
          ExecutionContext2.prototype.getTensorArray = function(id) {
            return this.tensorArrayMap[id];
          };
          ExecutionContext2.prototype.addTensorList = function(tensorList) {
            this.tensorListMap[tensorList.id] = tensorList;
          };
          ExecutionContext2.prototype.getTensorList = function(id) {
            return this.tensorListMap[id];
          };
          ExecutionContext2.prototype.dispose = function(keepIds) {
            for (var key in this.tensorArrayMap) {
              this.tensorArrayMap[key].clearAndClose(keepIds);
            }
            for (var key in this.tensorListMap) {
              this.tensorListMap[key].clearAndClose(keepIds);
            }
          };
          return ExecutionContext2;
        }();
        function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
          var usedNodes = new Set();
          var missingInputs = [];
          var dynamicNode = null;
          var syncInputs = null;
          var seen = new Set();
          var inputNodeNames = Object.keys(inputs).map(function(name) {
            return parseNodeName(name)[0];
          });
          var initNodeNames = [];
          if (initNodes != null) {
            initNodeNames = initNodes.map(function(node2) {
              return parseNodeName(node2.name)[0];
            });
          }
          var frontier = __spread(outputs);
          while (frontier.length > 0) {
            var node = frontier.pop();
            if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
              if (dynamicNode == null) {
                dynamicNode = node;
                syncInputs = dynamicNode.children.map(function(child) {
                  return child.name;
                }).filter(function(name) {
                  return usedNodes.has(name);
                });
              }
            }
            usedNodes.add(node.name);
            if (weightMap[node.name] != null) {
              continue;
            }
            if (inputNodeNames.indexOf(node.name) !== -1) {
              continue;
            }
            if (initNodeNames.indexOf(node.name) !== -1) {
              continue;
            }
            if (node.inputs.length === 0) {
              missingInputs.push(node.name);
              continue;
            }
            node.inputs.forEach(function(input) {
              if (seen.has(input.name)) {
                return;
              }
              seen.add(input.name);
              frontier.push(input);
            });
          }
          return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
        }
        function getNodesInTopologicalOrder(graph2, weightMap, executionInfo) {
          var usedNodes = executionInfo.usedNodes, inputs = executionInfo.inputs;
          var frontier = [];
          var inputNodes = Object.keys(inputs).map(function(name) {
            return parseNodeName(name)[0];
          }).map(function(name) {
            return graph2.nodes[name];
          });
          var initNodes = graph2.initNodes;
          inputNodes.forEach(function(input) {
            if (usedNodes.has(input.name)) {
              frontier.push(input);
            }
          });
          graph2.weights.forEach(function(weight) {
            if (usedNodes.has(weight.name)) {
              frontier.push(weight);
            }
          });
          if (initNodes != null) {
            initNodes.forEach(function(node2) {
              if (usedNodes.has(node2.name)) {
                frontier.push(node2);
              }
            });
          }
          var seen = new Set();
          var orderedNodes = [];
          while (frontier.length > 0) {
            var node = frontier.pop();
            seen.add(node.name);
            if (!weightMap[node.name]) {
              orderedNodes.push(node);
            }
            node.children.forEach(function(child) {
              if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(function(input) {
                return seen.has(input.name);
              })) {
                frontier.push(child);
              }
            });
          }
          return orderedNodes;
        }
        var CONTROL_FLOW_OPS = [
          "Switch",
          "Merge",
          "Enter",
          "Exit",
          "NextIteration",
          "StatelessIf",
          "StatelessWhile",
          "if",
          "While"
        ];
        var DYNAMIC_SHAPE_OPS = [
          "NonMaxSuppressionV2",
          "NonMaxSuppressionV3",
          "NonMaxSuppressionV5",
          "Where"
        ];
        var HASH_TABLE_OPS = [
          "HashTable",
          "HashTableV2",
          "LookupTableImport",
          "LookupTableImportV2",
          "LookupTableFind",
          "LookupTableFindV2",
          "LookupTableSize",
          "LookupTableSizeV2"
        ];
        function isControlFlow(node) {
          return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;
        }
        function isDynamicShape(node) {
          return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;
        }
        function isHashTable(node) {
          return HASH_TABLE_OPS.indexOf(node.op) >= 0;
        }
        var GraphExecutor = function() {
          function GraphExecutor2(graph2, parent) {
            var _this2 = this;
            this.graph = graph2;
            this.parent = parent;
            this.compiledMap = new Map();
            this._weightMap = {};
            this.SEPERATOR = ",";
            this._functions = {};
            this._functionExecutorMap = {};
            this._outputs = graph2.outputs;
            this._inputs = graph2.inputs;
            this._initNodes = graph2.initNodes;
            this._signature = graph2.signature;
            this._functions = graph2.functions;
            if (graph2.functions != null) {
              Object.keys(graph2.functions).forEach(function(name) {
                _this2._functionExecutorMap[name] = new GraphExecutor2(graph2.functions[name], _this2);
              });
            }
          }
          Object.defineProperty(GraphExecutor2.prototype, "weightIds", {
            get: function() {
              return this.parent ? this.parent.weightIds : this._weightIds;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "functionExecutorMap", {
            get: function() {
              return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "weightMap", {
            get: function() {
              return this.parent ? this.parent.weightMap : this._weightMap;
            },
            set: function(weightMap) {
              var weightIds = Object.keys(weightMap).map(function(key) {
                return weightMap[key].map(function(tensor) {
                  return tensor.id;
                });
              });
              this._weightIds = [].concat.apply([], __spread(weightIds));
              this._weightMap = weightMap;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "resourceManager", {
            set: function(resourceManager) {
              this._resourceManager = resourceManager;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "inputs", {
            get: function() {
              return this._inputs.map(function(node) {
                return {
                  name: node.name,
                  shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
                  dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
                };
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "outputs", {
            get: function() {
              return this._outputs.map(function(node) {
                return {
                  name: node.name,
                  shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
                  dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
                };
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "inputNodes", {
            get: function() {
              return this._inputs.map(function(node) {
                return node.signatureKey || node.name;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "outputNodes", {
            get: function() {
              return this._outputs.map(function(node) {
                var name = node.signatureKey || node.name;
                return node.defaultOutput ? name + ":" + node.defaultOutput : name;
              });
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphExecutor2.prototype, "functions", {
            get: function() {
              var _this2 = this;
              return Object.keys(this._functions).reduce(function(map2, key) {
                map2[key] = _this2._functions[key].signature;
                return map2;
              }, {});
            },
            enumerable: true,
            configurable: true
          });
          GraphExecutor2.prototype.getCompilationKey = function(inputs, outputs) {
            var sortedInputs = inputs.map(function(node) {
              return node.name;
            }).sort();
            var sortedOutputs = outputs.map(function(node) {
              return node.name;
            }).sort();
            return sortedInputs.join(this.SEPERATOR) + "--" + sortedOutputs.join(this.SEPERATOR);
          };
          GraphExecutor2.prototype.compile = function(inputs, outputs) {
            var executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
            var missingInputs = executionInfo.missingInputs, dynamicNode = executionInfo.dynamicNode, syncInputs = executionInfo.syncInputs;
            if (dynamicNode != null) {
              throw new Error("This execution contains the node '" + dynamicNode.name + "', which has " + ("the dynamic op '" + dynamicNode.op + "'. Please use ") + "model.executeAsync() instead. Alternatively, to avoid the " + ("dynamic ops, specify the inputs [" + syncInputs + "]"));
            }
            if (missingInputs.length > 0) {
              var outNames = outputs.map(function(n) {
                return n.name;
              });
              var inNames = Object.keys(inputs);
              throw new Error("Cannot compute the outputs [" + outNames + "] from the provided inputs " + ("[" + inNames + "]. Missing the following inputs: [" + missingInputs + "]"));
            }
            return getNodesInTopologicalOrder(this.graph, this.weightMap, executionInfo);
          };
          GraphExecutor2.prototype.execute = function(inputs, outputs) {
            var _this2 = this;
            inputs = this.mapInputs(inputs);
            var names = Object.keys(inputs).sort();
            this.checkInputs(inputs);
            this.checkInputShapeAndType(inputs);
            outputs = this.mapOutputs(outputs);
            this.checkOutputs(outputs);
            var inputNodes = names.map(function(name) {
              return _this2.graph.nodes[parseNodeName(name)[0]];
            });
            var outputNodeNames = outputs.map(function(name) {
              return parseNodeName(name)[0];
            });
            var outputNodes = outputNodeNames.map(function(name) {
              return _this2.graph.nodes[name];
            });
            if (outputNodes.length === 0) {
              outputNodes = this._outputs;
            }
            var compilationKey = this.getCompilationKey(inputNodes, outputNodes);
            var orderedNodes = this.compiledMap.get(compilationKey);
            if (orderedNodes == null) {
              orderedNodes = this.compile(inputs, outputNodes);
              this.compiledMap.set(compilationKey, orderedNodes);
            }
            var tensorArrayMap = {};
            var tensorListMap = {};
            return tfOps.tidy(function() {
              var context = new ExecutionContext(_this2.weightMap, tensorArrayMap, tensorListMap, _this2.functionExecutorMap);
              var tensorsMap = __assign2({}, _this2.weightMap);
              Object.keys(inputs).forEach(function(name) {
                var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index2 = _a[1];
                var tensors2 = [];
                tensors2[index2] = inputs[name];
                tensorsMap[nodeName] = tensors2;
              });
              var tensorsToKeep = _this2.getFrozenTensorIds(tensorsMap);
              var intermediateTensorConsumerCount = {};
              for (var i = 0; i < orderedNodes.length; i++) {
                var node = orderedNodes[i];
                if (!tensorsMap[node.name]) {
                  var tensors = executeOp$i(node, tensorsMap, context, _this2._resourceManager);
                  if (tfOps.util.isPromise(tensors)) {
                    throw new Error("The execution of the op '" + node.op + "' returned a promise. Please use model.executeAsync() instead.");
                  }
                  tensorsMap[node.name] = tensors;
                  _this2.checkTensorForDisposal(node.name, node, tensorsMap, context, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount);
                }
              }
              if (_this2.parent == null) {
                context.dispose(tensorsToKeep);
              }
              return outputs.map(function(name) {
                return getTensor(name, tensorsMap, context);
              });
            });
          };
          GraphExecutor2.prototype.getFrozenTensorIds = function(tensorMap) {
            var ids = [].concat.apply([], Object.keys(tensorMap).map(function(key) {
              return tensorMap[key];
            }).map(function(tensors) {
              return tensors.map(function(tensor) {
                return tensor.id;
              });
            }));
            return new Set(ids);
          };
          GraphExecutor2.prototype.checkTensorForDisposal = function(nodeName, node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {
            if (node.category === "control" || outputNames.indexOf(nodeName) !== -1) {
              return;
            }
            tensorMap[nodeName].forEach(function(tensor) {
              if (tensor != null) {
                intermediateTensorConsumerCount[tensor.id] = (intermediateTensorConsumerCount[tensor.id] || 0) + node.children.length;
              }
            });
            node.inputs.forEach(function(input) {
              if (input.category !== "control") {
                var tensors = getTensorsForCurrentContenxt(input.name, tensorMap, context);
                if (tensors != null) {
                  tensors.forEach(function(tensor) {
                    if (tensor && !tensor.kept && !tensorsToKeep.has(tensor.id)) {
                      var count = intermediateTensorConsumerCount[tensor.id];
                      if (count === 1) {
                        tensor.dispose();
                        delete intermediateTensorConsumerCount[tensor.id];
                      } else if (count != null) {
                        intermediateTensorConsumerCount[tensor.id]--;
                      }
                    }
                  });
                }
              }
            });
          };
          GraphExecutor2.prototype.executeAsync = function(inputs, outputs) {
            return __awaiter2(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                return [2, this._executeAsync(inputs, outputs)];
              });
            });
          };
          GraphExecutor2.prototype._executeAsync = function(inputs, outputs, isFunctionExecution, tensorArrayMap, tensorListMap) {
            if (isFunctionExecution === void 0) {
              isFunctionExecution = false;
            }
            if (tensorArrayMap === void 0) {
              tensorArrayMap = {};
            }
            if (tensorListMap === void 0) {
              tensorListMap = {};
            }
            return __awaiter2(this, void 0, void 0, function() {
              var context, tensorMap, results, outputIds, inputIds, keepIds;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!isFunctionExecution) {
                      inputs = this.mapInputs(inputs);
                      this.checkInputs(inputs);
                      this.checkInputShapeAndType(inputs);
                      outputs = this.mapOutputs(outputs);
                      this.checkOutputs(outputs);
                    }
                    context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
                    return [4, this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution)];
                  case 1:
                    tensorMap = _a.sent();
                    results = outputs.map(function(name) {
                      return getTensor(name, tensorMap, context);
                    });
                    outputIds = results.map(function(t) {
                      return t.id;
                    });
                    inputIds = Object.keys(inputs).map(function(name) {
                      return inputs[name].id;
                    });
                    keepIds = new Set(__spread(outputIds, inputIds, this.weightIds));
                    Object.keys(tensorMap).forEach(function(key) {
                      var tensorArray = tensorMap[key];
                      tensorArray.forEach(function(tensor) {
                        if (tensor && !tensor.kept && !tensor.isDisposed && !keepIds.has(tensor.id)) {
                          tensor.dispose();
                        }
                      });
                    });
                    if (this.parent == null) {
                      context.dispose(keepIds);
                    }
                    return [2, results];
                }
              });
            });
          };
          GraphExecutor2.prototype.executeFunctionAsync = function(inputs, tensorArrayMap, tensorListMap) {
            return __awaiter2(this, void 0, void 0, function() {
              var mappedInputs;
              var _this2 = this;
              return __generator2(this, function(_a) {
                mappedInputs = inputs.reduce(function(map2, tensor, index2) {
                  map2[_this2.inputs[index2].name] = tensor;
                  return map2;
                }, {});
                return [2, this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap)];
              });
            });
          };
          GraphExecutor2.prototype.executeWithControlFlow = function(inputs, context, outputNames, isFunctionExecution) {
            return __awaiter2(this, void 0, void 0, function() {
              var names, inputNodes, outputNodeNames, outputNodes, _a, usedNodes, missingInputs, dynamicNode, syncInputs, stack, tensorsMap, intermediateTensorConsumerCount, tensorsToKeep, added, promises, missingOutputs, alternativeMsg;
              var _this2 = this;
              return __generator2(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    names = Object.keys(inputs);
                    inputNodes = names.map(function(name) {
                      return _this2.graph.nodes[parseNodeName(name)[0]];
                    });
                    outputNodeNames = outputNames.map(function(name) {
                      return parseNodeName(name)[0];
                    });
                    outputNodes = outputNodeNames.map(function(name) {
                      return _this2.graph.nodes[name];
                    });
                    if (outputNodes.length === 0) {
                      outputNodes = this._outputs;
                    }
                    _a = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes), usedNodes = _a.usedNodes, missingInputs = _a.missingInputs, dynamicNode = _a.dynamicNode, syncInputs = _a.syncInputs;
                    stack = __spread(inputNodes, this.graph.weights, this._initNodes || []).map(function(node) {
                      return { node, contexts: context.currentContext };
                    });
                    tensorsMap = __assign2({}, this.weightMap);
                    Object.keys(inputs).forEach(function(name) {
                      var _a2 = __read(parseNodeName(name), 2), nodeName = _a2[0], index2 = _a2[1];
                      var tensors = [];
                      tensors[index2] = inputs[name];
                      tensorsMap[nodeName] = tensors;
                    });
                    intermediateTensorConsumerCount = {};
                    tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
                    added = {};
                    _b.label = 1;
                  case 1:
                    if (!(stack.length > 0))
                      return [3, 3];
                    promises = this.processStack(inputNodes, stack, context, tensorsMap, added, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount, usedNodes);
                    return [4, Promise.all(promises)];
                  case 2:
                    _b.sent();
                    return [3, 1];
                  case 3:
                    if (dynamicNode == null && !isFunctionExecution) {
                      console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
                    }
                    missingOutputs = outputNodes.filter(function(node) {
                      return !isControlFlow(node) && !getTensor(node.name, tensorsMap, context);
                    }).map(function(node) {
                      return node.name;
                    });
                    if (missingOutputs.length > 0) {
                      alternativeMsg = "";
                      if (dynamicNode != null) {
                        alternativeMsg = "Alternatively, to avoid the dynamic ops, use model.execute() " + ("and specify the inputs [" + syncInputs + "]");
                      }
                      throw new Error("Cannot compute the outputs [" + missingOutputs + "] from the provided " + ("inputs [" + names + "]. Consider providing the following inputs: ") + ("[" + missingInputs + "]. " + alternativeMsg));
                    }
                    return [2, tensorsMap];
                }
              });
            });
          };
          GraphExecutor2.prototype.processStack = function(inputNodes, stack, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {
            var _this2 = this;
            var promises = [];
            var _loop_1 = function() {
              var _a, _b;
              var item = stack.pop();
              context.currentContext = item.contexts;
              var nodeName = "";
              if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context)) {
                _a = __read(getNodeNameAndIndex(item.node.name, context), 1), nodeName = _a[0];
              }
              if (tensorMap[item.node.name] == null) {
                var tensors = executeOp$i(item.node, tensorMap, context, this_1._resourceManager);
                if (!nodeName) {
                  _b = __read(getNodeNameAndIndex(item.node.name, context), 1), nodeName = _b[0];
                }
                var currentContext_1 = context.currentContext;
                if (tfOps.util.isPromise(tensors)) {
                  promises.push(tensors.then(function(t) {
                    tensorMap[nodeName] = t;
                    context.currentContext = currentContext_1;
                    _this2.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
                    _this2.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);
                    return t;
                  }));
                } else {
                  tensorMap[nodeName] = tensors;
                  this_1.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
                  this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);
                }
              } else {
                this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);
              }
            };
            var this_1 = this;
            while (stack.length > 0) {
              _loop_1();
            }
            return promises;
          };
          GraphExecutor2.prototype.processChildNodes = function(node, stack, context, tensorMap, added, usedNodes) {
            node.children.forEach(function(childNode) {
              var _a = __read(getNodeNameAndIndex(childNode.name, context), 1), nodeName = _a[0];
              if (added[nodeName] || !usedNodes.has(childNode.name)) {
                return;
              }
              if (childNode.op === "Merge") {
                if (childNode.inputNames.some(function(name) {
                  return !!getTensor(name, tensorMap, context);
                })) {
                  added[nodeName] = true;
                  stack.push({ contexts: context.currentContext, node: childNode });
                }
              } else if (childNode.inputNames.every(function(name) {
                return !!getTensor(name, tensorMap, context);
              })) {
                added[nodeName] = true;
                stack.push({ contexts: context.currentContext, node: childNode });
              }
            });
          };
          GraphExecutor2.prototype.dispose = function() {
            var _this2 = this;
            Object.keys(this.weightMap).forEach(function(key) {
              return _this2.weightMap[key].forEach(function(tensor) {
                return tensor.dispose();
              });
            });
          };
          GraphExecutor2.prototype.checkInputShapeAndType = function(inputs) {
            var _this2 = this;
            Object.keys(inputs).forEach(function(name) {
              var input = inputs[name];
              var _a = __read(parseNodeName(name), 1), nodeName = _a[0];
              var node = _this2.graph.nodes[nodeName];
              if (node.attrParams["shape"] && node.attrParams["shape"].value) {
                var shape_1 = node.attrParams["shape"].value;
                var match = shape_1.length === input.shape.length && input.shape.every(function(dim, index2) {
                  return shape_1[index2] === -1 || shape_1[index2] === dim;
                });
                tfOps.util.assert(match, function() {
                  return "The shape of dict['" + node.name + "'] provided in " + ("model.execute(dict) must be [" + shape_1 + "], but was ") + ("[" + input.shape + "]");
                });
              }
              if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
                tfOps.util.assert(input.dtype === node.attrParams["dtype"].value, function() {
                  return "The dtype of dict['" + node.name + "'] provided in model.execute(dict) must be " + (node.attrParams["dtype"].value + ", but was " + input.dtype);
                });
              }
            });
          };
          GraphExecutor2.prototype.mapInputs = function(inputs) {
            var result2 = {};
            for (var inputName in inputs) {
              if (this._signature != null && this._signature.inputs != null && this._signature.inputs[inputName] != null) {
                var tensor = this._signature.inputs[inputName];
                result2[tensor.name] = inputs[inputName];
              } else {
                result2[inputName] = inputs[inputName];
              }
            }
            return result2;
          };
          GraphExecutor2.prototype.checkInputs = function(inputs) {
            var _this2 = this;
            var notInGraph = Object.keys(inputs).filter(function(name) {
              var _a = __read(parseNodeName(name), 1), nodeName = _a[0];
              return _this2.graph.nodes[nodeName] == null;
            });
            if (notInGraph.length > 0) {
              throw new Error("The dict provided in model.execute(dict) has " + ("keys: [" + notInGraph + "] that are not part of graph"));
            }
          };
          GraphExecutor2.prototype.mapOutputs = function(outputs) {
            var _this2 = this;
            return outputs.map(function(name) {
              if (_this2._signature != null && _this2._signature.outputs != null && _this2._signature.outputs[name] != null) {
                var tensor = _this2._signature.outputs[name];
                return tensor.name;
              }
              return name;
            }, {});
          };
          GraphExecutor2.prototype.checkOutputs = function(outputs) {
            var _this2 = this;
            outputs.forEach(function(name) {
              var _a = __read(parseNodeName(name), 1), normalizedName = _a[0];
              if (!_this2.graph.nodes[normalizedName]) {
                throw new Error("The output '" + name + "' is not found in the graph");
              }
            });
          };
          return GraphExecutor2;
        }();
        var ResourceManager = function() {
          function ResourceManager2(hashTableNameToHandle, hashTableMap) {
            if (hashTableNameToHandle === void 0) {
              hashTableNameToHandle = {};
            }
            if (hashTableMap === void 0) {
              hashTableMap = {};
            }
            this.hashTableNameToHandle = hashTableNameToHandle;
            this.hashTableMap = hashTableMap;
          }
          ResourceManager2.prototype.addHashTable = function(name, hashTable2) {
            this.hashTableNameToHandle[name] = hashTable2.handle;
            this.hashTableMap[hashTable2.id] = hashTable2;
          };
          ResourceManager2.prototype.getHashTableHandleByName = function(name) {
            return this.hashTableNameToHandle[name];
          };
          ResourceManager2.prototype.getHashTableById = function(id) {
            return this.hashTableMap[id];
          };
          ResourceManager2.prototype.dispose = function() {
            for (var key in this.hashTableMap) {
              this.hashTableMap[key].clearAndClose();
              delete this.hashTableMap[key];
            }
            for (var name_1 in this.hashTableNameToHandle) {
              this.hashTableNameToHandle[name_1].dispose();
              delete this.hashTableNameToHandle[name_1];
            }
          };
          return ResourceManager2;
        }();
        var TFHUB_SEARCH_PARAM = "?tfjs-format=file";
        var DEFAULT_MODEL_NAME = "model.json";
        var GraphModel = function() {
          function GraphModel2(modelUrl, loadOptions) {
            if (loadOptions === void 0) {
              loadOptions = {};
            }
            this.modelUrl = modelUrl;
            this.loadOptions = loadOptions;
            this.version = "n/a";
            if (loadOptions == null) {
              this.loadOptions = {};
            }
            this.resourceManager = new ResourceManager();
          }
          Object.defineProperty(GraphModel2.prototype, "modelVersion", {
            get: function() {
              return this.version;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "inputNodes", {
            get: function() {
              return this.executor.inputNodes;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "outputNodes", {
            get: function() {
              return this.executor.outputNodes;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "inputs", {
            get: function() {
              return this.executor.inputs;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "outputs", {
            get: function() {
              return this.executor.outputs;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "weights", {
            get: function() {
              return this.executor.weightMap;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "metadata", {
            get: function() {
              return this.artifacts.userDefinedMetadata;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(GraphModel2.prototype, "modelSignature", {
            get: function() {
              return this.signature;
            },
            enumerable: true,
            configurable: true
          });
          GraphModel2.prototype.findIOHandler = function() {
            var path = this.modelUrl;
            if (path.load != null) {
              this.handler = path;
            } else if (this.loadOptions.requestInit != null) {
              this.handler = tfOps.io.browserHTTPRequest(path, this.loadOptions);
            } else {
              var handlers = tfOps.io.getLoadHandlers(path, this.loadOptions);
              if (handlers.length === 0) {
                handlers.push(tfOps.io.browserHTTPRequest(path, this.loadOptions));
              } else if (handlers.length > 1) {
                throw new Error("Found more than one (" + handlers.length + ") load handlers for " + ("URL '" + [path] + "'"));
              }
              this.handler = handlers[0];
            }
          };
          GraphModel2.prototype.load = function() {
            return __awaiter2(this, void 0, void 0, function() {
              var artifacts;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.findIOHandler();
                    if (this.handler.load == null) {
                      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                    }
                    return [4, this.handler.load()];
                  case 1:
                    artifacts = _a.sent();
                    return [2, this.loadSync(artifacts)];
                }
              });
            });
          };
          GraphModel2.prototype.loadSync = function(artifacts) {
            this.artifacts = artifacts;
            var graph2 = this.artifacts.modelTopology;
            var signature;
            if (this.artifacts.userDefinedMetadata != null && this.artifacts.userDefinedMetadata.signature != null) {
              signature = this.artifacts.userDefinedMetadata.signature;
            } else {
              signature = this.artifacts.signature;
            }
            this.signature = signature;
            this.version = graph2.versions.producer + "." + graph2.versions.minConsumer;
            var weightMap = tfOps.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
            this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph2, this.signature));
            this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
            this.executor.resourceManager = this.resourceManager;
            if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
              var initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
              this.initializer = new GraphExecutor(initializer);
              this.initializer.weightMap = this.executor.weightMap;
              this.initializer.resourceManager = this.resourceManager;
              this.initializer.executeAsync({}, []);
            }
            return true;
          };
          GraphModel2.prototype.save = function(handlerOrURL, config) {
            return __awaiter2(this, void 0, void 0, function() {
              var handlers;
              return __generator2(this, function(_a) {
                if (typeof handlerOrURL === "string") {
                  handlers = tfOps.io.getSaveHandlers(handlerOrURL);
                  if (handlers.length === 0) {
                    throw new Error("Cannot find any save handlers for URL '" + handlerOrURL + "'");
                  } else if (handlers.length > 1) {
                    throw new Error("Found more than one (" + handlers.length + ") save handlers for " + ("URL '" + handlerOrURL + "'"));
                  }
                  handlerOrURL = handlers[0];
                }
                if (handlerOrURL.save == null) {
                  throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                }
                return [2, handlerOrURL.save(this.artifacts)];
              });
            });
          };
          GraphModel2.prototype.predict = function(inputs, config) {
            return this.execute(inputs, this.outputNodes);
          };
          GraphModel2.prototype.normalizeInputs = function(inputs) {
            if (!(inputs instanceof tfOps.Tensor) && !Array.isArray(inputs)) {
              return inputs;
            }
            inputs = Array.isArray(inputs) ? inputs : [inputs];
            if (inputs.length !== this.inputNodes.length) {
              throw new Error("Input tensor count mismatch," + ("the graph model has " + this.inputNodes.length + " placeholders, ") + ("while there are " + inputs.length + " input tensors."));
            }
            return this.inputNodes.reduce(function(map2, inputName, i) {
              map2[inputName] = inputs[i];
              return map2;
            }, {});
          };
          GraphModel2.prototype.normalizeOutputs = function(outputs) {
            outputs = outputs || this.outputNodes;
            return !Array.isArray(outputs) ? [outputs] : outputs;
          };
          GraphModel2.prototype.execute = function(inputs, outputs) {
            inputs = this.normalizeInputs(inputs);
            outputs = this.normalizeOutputs(outputs);
            var result2 = this.executor.execute(inputs, outputs);
            return result2.length > 1 ? result2 : result2[0];
          };
          GraphModel2.prototype.executeAsync = function(inputs, outputs) {
            return __awaiter2(this, void 0, void 0, function() {
              var result2;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    inputs = this.normalizeInputs(inputs);
                    outputs = this.normalizeOutputs(outputs);
                    return [4, this.executor.executeAsync(inputs, outputs)];
                  case 1:
                    result2 = _a.sent();
                    return [2, result2.length > 1 ? result2 : result2[0]];
                }
              });
            });
          };
          GraphModel2.prototype.convertTensorMapToTensorsMap = function(map2) {
            return Object.keys(map2).reduce(function(newMap, key) {
              newMap[key] = [map2[key]];
              return newMap;
            }, {});
          };
          GraphModel2.prototype.dispose = function() {
            this.executor.dispose();
            if (this.initializer) {
              this.initializer.dispose();
            }
            this.resourceManager.dispose();
          };
          return GraphModel2;
        }();
        function loadGraphModel2(modelUrl, options) {
          if (options === void 0) {
            options = {};
          }
          return __awaiter2(this, void 0, void 0, function() {
            var model;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (modelUrl == null) {
                    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
                  }
                  if (options == null) {
                    options = {};
                  }
                  if (options.fromTFHub) {
                    if (modelUrl.load == null) {
                      if (!modelUrl.endsWith("/")) {
                        modelUrl = modelUrl + "/";
                      }
                      modelUrl = "" + modelUrl + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM;
                    }
                  }
                  model = new GraphModel(modelUrl, options);
                  return [4, model.load()];
                case 1:
                  _a.sent();
                  return [2, model];
              }
            });
          });
        }
        var version = "3.6.0";
        exports.GraphModel = GraphModel;
        exports.deregisterOp = deregisterOp;
        exports.loadGraphModel = loadGraphModel2;
        exports.registerOp = registerOp;
        exports.version_converter = version;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/decode_part_map.js
    var require_decode_part_map = __commonJS({
      "node_modules/@tensorflow-models/body-pix/decode_part_map.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodeOnlyPartSegmentation = exports.decodePartSegmentation = exports.toMaskTensor = void 0;
        var tf2 = require_tf_core_node();
        function toFlattenedOneHotPartMap(partHeatmapScores) {
          var numParts = partHeatmapScores.shape[2];
          var partMapLocations = tf2.argMax(partHeatmapScores, 2);
          var partMapFlattened = tf2.reshape(partMapLocations, [-1]);
          return tf2.oneHot(partMapFlattened, numParts);
        }
        function clipByMask2d(image2, mask) {
          return tf2.mul(image2, mask);
        }
        function toMaskTensor(segmentScores, threshold) {
          return tf2.tidy(function() {
            return tf2.cast(tf2.greater(segmentScores, tf2.scalar(threshold)), "int32");
          });
        }
        exports.toMaskTensor = toMaskTensor;
        function decodePartSegmentation(segmentationMask, partHeatmapScores) {
          var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];
          return tf2.tidy(function() {
            var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);
            var partNumbers = tf2.expandDims(tf2.range(0, numParts, 1, "int32"), 1);
            var partMapFlattened = tf2.cast(tf2.matMul(flattenedMap, partNumbers), "int32");
            var partMap = tf2.reshape(partMapFlattened, [partMapHeight, partMapWidth]);
            var partMapShiftedUpForClipping = tf2.add(partMap, tf2.scalar(1, "int32"));
            return tf2.sub(clipByMask2d(partMapShiftedUpForClipping, segmentationMask), tf2.scalar(1, "int32"));
          });
        }
        exports.decodePartSegmentation = decodePartSegmentation;
        function decodeOnlyPartSegmentation(partHeatmapScores) {
          var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];
          return tf2.tidy(function() {
            var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);
            var partNumbers = tf2.expandDims(tf2.range(0, numParts, 1, "int32"), 1);
            var partMapFlattened = tf2.cast(tf2.matMul(flattenedMap, partNumbers), "int32");
            return tf2.reshape(partMapFlattened, [partMapHeight, partMapWidth]);
          });
        }
        exports.decodeOnlyPartSegmentation = decodeOnlyPartSegmentation;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/base_model.js
    var require_base_model = __commonJS({
      "node_modules/@tensorflow-models/body-pix/base_model.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.BaseModel = void 0;
        var tf2 = require_tf_core_node();
        var BaseModel2 = function() {
          function BaseModel3(model, outputStride) {
            this.model = model;
            this.outputStride = outputStride;
            var inputShape = this.model.inputs[0].shape;
            tf2.util.assert(inputShape[1] === -1 && inputShape[2] === -1, function() {
              return "Input shape [" + inputShape[1] + ", " + inputShape[2] + "] must both be equal to or -1";
            });
          }
          BaseModel3.prototype.predict = function(input) {
            var _this = this;
            return tf2.tidy(function() {
              var asFloat = _this.preprocessInput(tf2.cast(input, "float32"));
              var asBatch = tf2.expandDims(asFloat, 0);
              var results = _this.model.predict(asBatch);
              var results3d = results.map(function(y) {
                return tf2.squeeze(y, [0]);
              });
              var namedResults = _this.nameOutputResults(results3d);
              return {
                heatmapScores: tf2.sigmoid(namedResults.heatmap),
                offsets: namedResults.offsets,
                displacementFwd: namedResults.displacementFwd,
                displacementBwd: namedResults.displacementBwd,
                segmentation: namedResults.segmentation,
                partHeatmaps: namedResults.partHeatmaps,
                longOffsets: namedResults.longOffsets,
                partOffsets: namedResults.partOffsets
              };
            });
          };
          BaseModel3.prototype.dispose = function() {
            this.model.dispose();
          };
          return BaseModel3;
        }();
        exports.BaseModel = BaseModel2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/mobilenet.js
    var require_mobilenet = __commonJS({
      "node_modules/@tensorflow-models/body-pix/mobilenet.js"(exports) {
        "use strict";
        var __extends2 = exports && exports.__extends || function() {
          var extendStatics2 = function(d, b) {
            extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (b2.hasOwnProperty(p))
                  d2[p] = b2[p];
            };
            return extendStatics2(d, b);
          };
          return function(d, b) {
            extendStatics2(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.MobileNet = void 0;
        var tf2 = require_tf_core_node();
        var base_model_1 = require_base_model();
        var MobileNet2 = function(_super) {
          __extends2(MobileNet3, _super);
          function MobileNet3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          MobileNet3.prototype.preprocessInput = function(input) {
            return tf2.tidy(function() {
              return tf2.sub(tf2.div(input, 127.5), 1);
            });
          };
          MobileNet3.prototype.nameOutputResults = function(results) {
            var offsets = results[0], segmentation = results[1], partHeatmaps = results[2], longOffsets = results[3], heatmap = results[4], displacementFwd = results[5], displacementBwd = results[6], partOffsets = results[7];
            return {
              offsets,
              segmentation,
              partHeatmaps,
              longOffsets,
              heatmap,
              displacementFwd,
              displacementBwd,
              partOffsets
            };
          };
          return MobileNet3;
        }(base_model_1.BaseModel);
        exports.MobileNet = MobileNet2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/keypoints.js
    var require_keypoints = __commonJS({
      "node_modules/@tensorflow-models/body-pix/keypoints.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CONNECTED_PART_INDICES = exports.POSE_CHAIN = exports.PART_IDS = exports.NUM_KEYPOINTS = exports.PART_NAMES = void 0;
        exports.PART_NAMES = [
          "nose",
          "leftEye",
          "rightEye",
          "leftEar",
          "rightEar",
          "leftShoulder",
          "rightShoulder",
          "leftElbow",
          "rightElbow",
          "leftWrist",
          "rightWrist",
          "leftHip",
          "rightHip",
          "leftKnee",
          "rightKnee",
          "leftAnkle",
          "rightAnkle"
        ];
        exports.NUM_KEYPOINTS = exports.PART_NAMES.length;
        exports.PART_IDS = exports.PART_NAMES.reduce(function(result2, jointName, i) {
          result2[jointName] = i;
          return result2;
        }, {});
        var CONNECTED_PART_NAMES = [
          ["leftHip", "leftShoulder"],
          ["leftElbow", "leftShoulder"],
          ["leftElbow", "leftWrist"],
          ["leftHip", "leftKnee"],
          ["leftKnee", "leftAnkle"],
          ["rightHip", "rightShoulder"],
          ["rightElbow", "rightShoulder"],
          ["rightElbow", "rightWrist"],
          ["rightHip", "rightKnee"],
          ["rightKnee", "rightAnkle"],
          ["leftShoulder", "rightShoulder"],
          ["leftHip", "rightHip"]
        ];
        exports.POSE_CHAIN = [
          ["nose", "leftEye"],
          ["leftEye", "leftEar"],
          ["nose", "rightEye"],
          ["rightEye", "rightEar"],
          ["nose", "leftShoulder"],
          ["leftShoulder", "leftElbow"],
          ["leftElbow", "leftWrist"],
          ["leftShoulder", "leftHip"],
          ["leftHip", "leftKnee"],
          ["leftKnee", "leftAnkle"],
          ["nose", "rightShoulder"],
          ["rightShoulder", "rightElbow"],
          ["rightElbow", "rightWrist"],
          ["rightShoulder", "rightHip"],
          ["rightHip", "rightKnee"],
          ["rightKnee", "rightAnkle"]
        ];
        exports.CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(function(_a) {
          var jointNameA = _a[0], jointNameB = _a[1];
          return [exports.PART_IDS[jointNameA], exports.PART_IDS[jointNameB]];
        });
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/util.js
    var require_util3 = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/util.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.clampVector = exports.addVectors = exports.squaredDistance = exports.clamp = exports.fillArray = exports.getImageCoords = exports.getOffsetPoint = exports.getScale = void 0;
        var keypoints_1 = require_keypoints();
        function getScale(_a, _b, padding) {
          var height = _a[0], width = _a[1];
          var inputResolutionY = _b[0], inputResolutionX = _b[1];
          var padT = padding.top, padB = padding.bottom, padL = padding.left, padR = padding.right;
          var scaleY = inputResolutionY / (padT + padB + height);
          var scaleX = inputResolutionX / (padL + padR + width);
          return [scaleX, scaleY];
        }
        exports.getScale = getScale;
        function getOffsetPoint2(y, x, keypoint, offsets) {
          return {
            y: offsets.get(y, x, keypoint),
            x: offsets.get(y, x, keypoint + keypoints_1.NUM_KEYPOINTS)
          };
        }
        exports.getOffsetPoint = getOffsetPoint2;
        function getImageCoords2(part, outputStride, offsets) {
          var heatmapY = part.heatmapY, heatmapX = part.heatmapX, keypoint = part.id;
          var _a = getOffsetPoint2(heatmapY, heatmapX, keypoint, offsets), y = _a.y, x = _a.x;
          return {
            x: part.heatmapX * outputStride + x,
            y: part.heatmapY * outputStride + y
          };
        }
        exports.getImageCoords = getImageCoords2;
        function fillArray(element, size) {
          var result2 = new Array(size);
          for (var i = 0; i < size; i++) {
            result2[i] = element;
          }
          return result2;
        }
        exports.fillArray = fillArray;
        function clamp3(a, min2, max2) {
          if (a < min2) {
            return min2;
          }
          if (a > max2) {
            return max2;
          }
          return a;
        }
        exports.clamp = clamp3;
        function squaredDistance2(y1, x1, y2, x2) {
          var dy = y2 - y1;
          var dx = x2 - x1;
          return dy * dy + dx * dx;
        }
        exports.squaredDistance = squaredDistance2;
        function addVectors2(a, b) {
          return { x: a.x + b.x, y: a.y + b.y };
        }
        exports.addVectors = addVectors2;
        function clampVector(a, min2, max2) {
          return { y: clamp3(a.y, min2, max2), x: clamp3(a.x, min2, max2) };
        }
        exports.clampVector = clampVector;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_masks_cpu.js
    var require_decode_multiple_masks_cpu = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_masks_cpu.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodeMultiplePartMasksCPU = exports.decodeMultipleMasksCPU = void 0;
        var keypoints_1 = require_keypoints();
        var util_1 = require_util3();
        function computeDistance(embedding, pose, minPartScore) {
          if (minPartScore === void 0) {
            minPartScore = 0.3;
          }
          var distance = 0;
          var numKpt = 0;
          for (var p = 0; p < embedding.length; p++) {
            if (pose.keypoints[p].score > minPartScore) {
              numKpt += 1;
              distance += Math.pow(embedding[p].x - pose.keypoints[p].position.x, 2) + Math.pow(embedding[p].y - pose.keypoints[p].position.y, 2);
            }
          }
          if (numKpt === 0) {
            distance = Infinity;
          } else {
            distance = distance / numKpt;
          }
          return distance;
        }
        function convertToPositionInOuput(position, _a, _b, stride) {
          var padT = _a[0], padL = _a[1];
          var scaleX = _b[0], scaleY = _b[1];
          var y = Math.round(((padT + position.y + 1) * scaleY - 1) / stride);
          var x = Math.round(((padL + position.x + 1) * scaleX - 1) / stride);
          return { x, y };
        }
        function getEmbedding(location, keypointIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, _a) {
          var height = _a[0], width = _a[1];
          var newLocation = convertToPosition(location);
          var nn = newLocation.y * outputResolutionX + newLocation.x;
          var dy = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn) + keypointIndex];
          var dx = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];
          var y = location.y + dy;
          var x = location.x + dx;
          for (var t = 0; t < refineSteps; t++) {
            y = Math.min(y, height - 1);
            x = Math.min(x, width - 1);
            var newPos = convertToPosition({ x, y });
            var nn_1 = newPos.y * outputResolutionX + newPos.x;
            dy = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn_1) + keypointIndex];
            dx = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn_1 + 1) + keypointIndex];
            y = y + dy;
            x = x + dx;
          }
          return { x, y };
        }
        function matchEmbeddingToInstance(location, longOffsets, poses, numKptForMatching, _a, _b, outputResolutionX, _c, stride, refineSteps) {
          var padT = _a[0], padL = _a[1];
          var scaleX = _b[0], scaleY = _b[1];
          var height = _c[0], width = _c[1];
          var embed = [];
          var convertToPosition = function(pair) {
            return convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);
          };
          for (var keypointsIndex = 0; keypointsIndex < numKptForMatching; keypointsIndex++) {
            var embedding = getEmbedding(location, keypointsIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, [height, width]);
            embed.push(embedding);
          }
          var kMin = -1;
          var kMinDist = Infinity;
          for (var k = 0; k < poses.length; k++) {
            var dist = computeDistance(embed, poses[k]);
            if (dist < kMinDist) {
              kMin = k;
              kMinDist = dist;
            }
          }
          return kMin;
        }
        function getOutputResolution(_a, stride) {
          var inputResolutionY = _a[0], inputResolutionX = _a[1];
          var outputResolutionX = Math.round((inputResolutionX - 1) / stride + 1);
          var outputResolutionY = Math.round((inputResolutionY - 1) / stride + 1);
          return [outputResolutionX, outputResolutionY];
        }
        function decodeMultipleMasksCPU(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {
          var inHeight = _a[0], inWidth = _a[1];
          if (numKptForMatching === void 0) {
            numKptForMatching = 5;
          }
          var dataArrays = posesAboveScore.map(function(x) {
            return new Uint8Array(height * width).fill(0);
          });
          var padT = padding.top, padL = padding.left;
          var _b = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];
          var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];
          for (var i = 0; i < height; i += 1) {
            for (var j = 0; j < width; j += 1) {
              var n = i * width + j;
              var prob = segmentation[n];
              if (prob === 1) {
                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);
                if (kMin >= 0) {
                  dataArrays[kMin][n] = 1;
                }
              }
            }
          }
          return dataArrays;
        }
        exports.decodeMultipleMasksCPU = decodeMultipleMasksCPU;
        function decodeMultiplePartMasksCPU(segmentation, longOffsets, partSegmentaion, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {
          var inHeight = _a[0], inWidth = _a[1];
          if (numKptForMatching === void 0) {
            numKptForMatching = 5;
          }
          var dataArrays = posesAboveScore.map(function(x) {
            return new Int32Array(height * width).fill(-1);
          });
          var padT = padding.top, padL = padding.left;
          var _b = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];
          var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];
          for (var i = 0; i < height; i += 1) {
            for (var j = 0; j < width; j += 1) {
              var n = i * width + j;
              var prob = segmentation[n];
              if (prob === 1) {
                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);
                if (kMin >= 0) {
                  dataArrays[kMin][n] = partSegmentaion[n];
                }
              }
            }
          }
          return dataArrays;
        }
        exports.decodeMultiplePartMasksCPU = decodeMultiplePartMasksCPU;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_masks_webgl.js
    var require_decode_multiple_masks_webgl = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_masks_webgl.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodeMultipleMasksWebGl = void 0;
        var tf2 = require_tf_core_node();
        var keypoints_1 = require_keypoints();
        var util_1 = require_util3();
        function decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, minKptScore, maxNumPeople) {
          var inHeight = _a[0], inWidth = _a[1];
          var _b = segmentation.shape, origHeight = _b[0], origWidth = _b[1];
          var _c = longOffsets.shape.slice(0, 2), outHeight = _c[0], outWidth = _c[1];
          var shapedLongOffsets = tf2.reshape(longOffsets, [outHeight, outWidth, 2, keypoints_1.NUM_KEYPOINTS]);
          var poseVals = new Float32Array(maxNumPeople * keypoints_1.NUM_KEYPOINTS * 3).fill(0);
          for (var i = 0; i < posesAboveScore.length; i++) {
            var poseOffset = i * keypoints_1.NUM_KEYPOINTS * 3;
            var pose = posesAboveScore[i];
            for (var kp = 0; kp < keypoints_1.NUM_KEYPOINTS; kp++) {
              var keypoint = pose.keypoints[kp];
              var offset = poseOffset + kp * 3;
              poseVals[offset] = keypoint.score;
              poseVals[offset + 1] = keypoint.position.y;
              poseVals[offset + 2] = keypoint.position.x;
            }
          }
          var _d = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _d[0], scaleY = _d[1];
          var posesTensor = tf2.tensor(poseVals, [maxNumPeople, keypoints_1.NUM_KEYPOINTS, 3]);
          var padT = padding.top, padL = padding.left;
          var program = {
            variableNames: ["segmentation", "longOffsets", "poses"],
            outputShape: [origHeight, origWidth],
            userCode: "\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, " + padT + ", " + scaleY + ", " + stride + ");\n      float stridedW = convertToPositionInOutputFloat(\n        w, " + padL + ", " + scaleX + ", " + stride + ");\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < " + maxNumPeople + "; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < " + keypoints_1.NUM_KEYPOINTS + "; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < " + refineSteps + "; s++) {\n            int yRounded = round(min(y, float(" + (height - 1) + ")));\n            int xRounded = round(min(x, float(" + (width - 1) + ")));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, " + padT + ", " + scaleY + ", " + stride + ");\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, " + padL + ", " + scaleX + ", " + stride + ");\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > " + minKptScore + ") {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  "
          };
          var webglBackend = tf2.backend();
          return webglBackend.compileAndRun(program, [segmentation, shapedLongOffsets, posesTensor]);
        }
        exports.decodeMultipleMasksWebGl = decodeMultipleMasksWebGl;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/decode_instance_masks.js
    var require_decode_instance_masks = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/decode_instance_masks.js"(exports) {
        "use strict";
        var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step3(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step3(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step3(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step3((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator2 = exports && exports.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step3([n, v]);
            };
          }
          function step3(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodePersonInstancePartMasks = exports.decodePersonInstanceMasks = exports.toPersonKPartSegmentation = exports.toPersonKSegmentation = void 0;
        var tf2 = require_tf_core_node();
        var tfjs_core_1 = require_tf_core_node();
        var decode_multiple_masks_cpu_1 = require_decode_multiple_masks_cpu();
        var decode_multiple_masks_webgl_1 = require_decode_multiple_masks_webgl();
        function toPersonKSegmentation(segmentation, k) {
          return tf2.tidy(function() {
            return tf2.cast(tf2.equal(segmentation, tf2.scalar(k)), "int32");
          });
        }
        exports.toPersonKSegmentation = toPersonKSegmentation;
        function toPersonKPartSegmentation(segmentation, bodyParts, k) {
          return tf2.tidy(function() {
            return tf2.sub(tf2.mul(tf2.cast(tf2.equal(segmentation, tf2.scalar(k)), "int32"), tf2.add(bodyParts, 1)), 1);
          });
        }
        exports.toPersonKPartSegmentation = toPersonKPartSegmentation;
        function isWebGlBackend() {
          return tfjs_core_1.getBackend() === "webgl";
        }
        function decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {
          var inHeight = _a[0], inWidth = _a[1];
          if (minPoseScore === void 0) {
            minPoseScore = 0.2;
          }
          if (refineSteps === void 0) {
            refineSteps = 8;
          }
          if (minKeypointScore === void 0) {
            minKeypointScore = 0.3;
          }
          if (maxNumPeople === void 0) {
            maxNumPeople = 10;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var posesAboveScore, personSegmentationsData, personSegmentations, segmentationsData, longOffsetsData;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  posesAboveScore = poses.filter(function(pose) {
                    return pose.score >= minPoseScore;
                  });
                  if (!isWebGlBackend())
                    return [3, 2];
                  personSegmentations = tf2.tidy(function() {
                    var masksTensorInfo = decode_multiple_masks_webgl_1.decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);
                    var masksTensor = tf2.engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);
                    return posesAboveScore.map(function(_, k) {
                      return toPersonKSegmentation(masksTensor, k);
                    });
                  });
                  return [4, Promise.all(personSegmentations.map(function(mask) {
                    return mask.data();
                  }))];
                case 1:
                  personSegmentationsData = _b.sent();
                  personSegmentations.forEach(function(x) {
                    return x.dispose();
                  });
                  return [3, 5];
                case 2:
                  return [4, segmentation.data()];
                case 3:
                  segmentationsData = _b.sent();
                  return [4, longOffsets.data()];
                case 4:
                  longOffsetsData = _b.sent();
                  personSegmentationsData = decode_multiple_masks_cpu_1.decodeMultipleMasksCPU(segmentationsData, longOffsetsData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);
                  _b.label = 5;
                case 5:
                  return [2, personSegmentationsData.map(function(data, i) {
                    return { data, pose: posesAboveScore[i], width, height };
                  })];
              }
            });
          });
        }
        exports.decodePersonInstanceMasks = decodePersonInstanceMasks;
        function decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {
          var inHeight = _a[0], inWidth = _a[1];
          if (minPoseScore === void 0) {
            minPoseScore = 0.2;
          }
          if (refineSteps === void 0) {
            refineSteps = 8;
          }
          if (minKeypointScore === void 0) {
            minKeypointScore = 0.3;
          }
          if (maxNumPeople === void 0) {
            maxNumPeople = 10;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var posesAboveScore, partSegmentationsByPersonData, partSegmentations, segmentationsData, longOffsetsData, partSegmentaionData;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  posesAboveScore = poses.filter(function(pose) {
                    return pose.score >= minPoseScore;
                  });
                  if (!isWebGlBackend())
                    return [3, 2];
                  partSegmentations = tf2.tidy(function() {
                    var masksTensorInfo = decode_multiple_masks_webgl_1.decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);
                    var masksTensor = tf2.engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);
                    return posesAboveScore.map(function(_, k) {
                      return toPersonKPartSegmentation(masksTensor, partSegmentation, k);
                    });
                  });
                  return [4, Promise.all(partSegmentations.map(function(x) {
                    return x.data();
                  }))];
                case 1:
                  partSegmentationsByPersonData = _b.sent();
                  partSegmentations.forEach(function(x) {
                    return x.dispose();
                  });
                  return [3, 6];
                case 2:
                  return [4, segmentation.data()];
                case 3:
                  segmentationsData = _b.sent();
                  return [4, longOffsets.data()];
                case 4:
                  longOffsetsData = _b.sent();
                  return [4, partSegmentation.data()];
                case 5:
                  partSegmentaionData = _b.sent();
                  partSegmentationsByPersonData = decode_multiple_masks_cpu_1.decodeMultiplePartMasksCPU(segmentationsData, longOffsetsData, partSegmentaionData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);
                  _b.label = 6;
                case 6:
                  return [2, partSegmentationsByPersonData.map(function(data, k) {
                    return { pose: posesAboveScore[k], data, height, width };
                  })];
              }
            });
          });
        }
        exports.decodePersonInstancePartMasks = decodePersonInstancePartMasks;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/max_heap.js
    var require_max_heap = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/max_heap.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.MaxHeap = void 0;
        function half2(k) {
          return Math.floor(k / 2);
        }
        var MaxHeap2 = function() {
          function MaxHeap3(maxSize, getElementValue) {
            this.priorityQueue = new Array(maxSize);
            this.numberOfElements = -1;
            this.getElementValue = getElementValue;
          }
          MaxHeap3.prototype.enqueue = function(x) {
            this.priorityQueue[++this.numberOfElements] = x;
            this.swim(this.numberOfElements);
          };
          MaxHeap3.prototype.dequeue = function() {
            var max2 = this.priorityQueue[0];
            this.exchange(0, this.numberOfElements--);
            this.sink(0);
            this.priorityQueue[this.numberOfElements + 1] = null;
            return max2;
          };
          MaxHeap3.prototype.empty = function() {
            return this.numberOfElements === -1;
          };
          MaxHeap3.prototype.size = function() {
            return this.numberOfElements + 1;
          };
          MaxHeap3.prototype.all = function() {
            return this.priorityQueue.slice(0, this.numberOfElements + 1);
          };
          MaxHeap3.prototype.max = function() {
            return this.priorityQueue[0];
          };
          MaxHeap3.prototype.swim = function(k) {
            while (k > 0 && this.less(half2(k), k)) {
              this.exchange(k, half2(k));
              k = half2(k);
            }
          };
          MaxHeap3.prototype.sink = function(k) {
            while (2 * k <= this.numberOfElements) {
              var j = 2 * k;
              if (j < this.numberOfElements && this.less(j, j + 1)) {
                j++;
              }
              if (!this.less(k, j)) {
                break;
              }
              this.exchange(k, j);
              k = j;
            }
          };
          MaxHeap3.prototype.getValueAt = function(i) {
            return this.getElementValue(this.priorityQueue[i]);
          };
          MaxHeap3.prototype.less = function(i, j) {
            return this.getValueAt(i) < this.getValueAt(j);
          };
          MaxHeap3.prototype.exchange = function(i, j) {
            var t = this.priorityQueue[i];
            this.priorityQueue[i] = this.priorityQueue[j];
            this.priorityQueue[j] = t;
          };
          return MaxHeap3;
        }();
        exports.MaxHeap = MaxHeap2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/build_part_with_score_queue.js
    var require_build_part_with_score_queue = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/build_part_with_score_queue.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.buildPartWithScoreQueue = void 0;
        var max_heap_1 = require_max_heap();
        function scoreIsMaximumInLocalWindow2(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {
          var _a = scores.shape, height = _a[0], width = _a[1];
          var localMaximum = true;
          var yStart = Math.max(heatmapY - localMaximumRadius, 0);
          var yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
          for (var yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
            var xStart = Math.max(heatmapX - localMaximumRadius, 0);
            var xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
            for (var xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
              if (scores.get(yCurrent, xCurrent, keypointId) > score) {
                localMaximum = false;
                break;
              }
            }
            if (!localMaximum) {
              break;
            }
          }
          return localMaximum;
        }
        function buildPartWithScoreQueue2(scoreThreshold, localMaximumRadius, scores) {
          var _a = scores.shape, height = _a[0], width = _a[1], numKeypoints = _a[2];
          var queue = new max_heap_1.MaxHeap(height * width * numKeypoints, function(_a2) {
            var score2 = _a2.score;
            return score2;
          });
          for (var heatmapY = 0; heatmapY < height; ++heatmapY) {
            for (var heatmapX = 0; heatmapX < width; ++heatmapX) {
              for (var keypointId = 0; keypointId < numKeypoints; ++keypointId) {
                var score = scores.get(heatmapY, heatmapX, keypointId);
                if (score < scoreThreshold) {
                  continue;
                }
                if (scoreIsMaximumInLocalWindow2(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {
                  queue.enqueue({ score, part: { heatmapY, heatmapX, id: keypointId } });
                }
              }
            }
          }
          return queue;
        }
        exports.buildPartWithScoreQueue = buildPartWithScoreQueue2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/decode_pose.js
    var require_decode_pose = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/decode_pose.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodePose = void 0;
        var keypoints_1 = require_keypoints();
        var util_1 = require_util3();
        var util_2 = require_util3();
        var parentChildrenTuples2 = keypoints_1.POSE_CHAIN.map(function(_a) {
          var parentJoinName = _a[0], childJoinName = _a[1];
          return [keypoints_1.PART_IDS[parentJoinName], keypoints_1.PART_IDS[childJoinName]];
        });
        var parentToChildEdges2 = parentChildrenTuples2.map(function(_a) {
          var childJointId = _a[1];
          return childJointId;
        });
        var childToParentEdges2 = parentChildrenTuples2.map(function(_a) {
          var parentJointId = _a[0];
          return parentJointId;
        });
        function getDisplacement2(edgeId, point, displacements) {
          var numEdges = displacements.shape[2] / 2;
          return {
            y: displacements.get(point.y, point.x, edgeId),
            x: displacements.get(point.y, point.x, numEdges + edgeId)
          };
        }
        function getStridedIndexNearPoint2(point, outputStride, height, width) {
          return {
            y: util_1.clamp(Math.round(point.y / outputStride), 0, height - 1),
            x: util_1.clamp(Math.round(point.x / outputStride), 0, width - 1)
          };
        }
        function traverseToTargetKeypoint2(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements, offsetRefineStep) {
          if (offsetRefineStep === void 0) {
            offsetRefineStep = 2;
          }
          var _a = scoresBuffer.shape, height = _a[0], width = _a[1];
          var sourceKeypointIndices = getStridedIndexNearPoint2(sourceKeypoint.position, outputStride, height, width);
          var displacement = getDisplacement2(edgeId, sourceKeypointIndices, displacements);
          var displacedPoint = util_2.addVectors(sourceKeypoint.position, displacement);
          var targetKeypoint = displacedPoint;
          for (var i = 0; i < offsetRefineStep; i++) {
            var targetKeypointIndices = getStridedIndexNearPoint2(targetKeypoint, outputStride, height, width);
            var offsetPoint = util_1.getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId, offsets);
            targetKeypoint = util_2.addVectors({
              x: targetKeypointIndices.x * outputStride,
              y: targetKeypointIndices.y * outputStride
            }, { x: offsetPoint.x, y: offsetPoint.y });
          }
          var targetKeyPointIndices = getStridedIndexNearPoint2(targetKeypoint, outputStride, height, width);
          var score = scoresBuffer.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);
          return { position: targetKeypoint, part: keypoints_1.PART_NAMES[targetKeypointId], score };
        }
        function decodePose2(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {
          var numParts = scores.shape[2];
          var numEdges = parentToChildEdges2.length;
          var instanceKeypoints = new Array(numParts);
          var rootPart = root.part, rootScore = root.score;
          var rootPoint = util_2.getImageCoords(rootPart, outputStride, offsets);
          instanceKeypoints[rootPart.id] = {
            score: rootScore,
            part: keypoints_1.PART_NAMES[rootPart.id],
            position: rootPoint
          };
          for (var edge = numEdges - 1; edge >= 0; --edge) {
            var sourceKeypointId = parentToChildEdges2[edge];
            var targetKeypointId = childToParentEdges2[edge];
            if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
              instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint2(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);
            }
          }
          for (var edge = 0; edge < numEdges; ++edge) {
            var sourceKeypointId = childToParentEdges2[edge];
            var targetKeypointId = parentToChildEdges2[edge];
            if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
              instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint2(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);
            }
          }
          return instanceKeypoints;
        }
        exports.decodePose = decodePose2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_poses.js
    var require_decode_multiple_poses = __commonJS({
      "node_modules/@tensorflow-models/body-pix/multi_person/decode_multiple_poses.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.decodeMultiplePoses = void 0;
        var build_part_with_score_queue_1 = require_build_part_with_score_queue();
        var decode_pose_1 = require_decode_pose();
        var util_1 = require_util3();
        function withinNmsRadiusOfCorrespondingPoint2(poses, squaredNmsRadius, _a, keypointId) {
          var x = _a.x, y = _a.y;
          return poses.some(function(_a2) {
            var keypoints = _a2.keypoints;
            var correspondingKeypoint = keypoints[keypointId].position;
            return util_1.squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
          });
        }
        function getInstanceScore2(existingPoses, squaredNmsRadius, instanceKeypoints) {
          var notOverlappedKeypointScores = instanceKeypoints.reduce(function(result2, _a, keypointId) {
            var position = _a.position, score = _a.score;
            if (!withinNmsRadiusOfCorrespondingPoint2(existingPoses, squaredNmsRadius, position, keypointId)) {
              result2 += score;
            }
            return result2;
          }, 0);
          return notOverlappedKeypointScores /= instanceKeypoints.length;
        }
        var kLocalMaximumRadius2 = 1;
        function decodeMultiplePoses2(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {
          if (scoreThreshold === void 0) {
            scoreThreshold = 0.5;
          }
          if (nmsRadius === void 0) {
            nmsRadius = 20;
          }
          var poses = [];
          var queue = build_part_with_score_queue_1.buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius2, scoresBuffer);
          var squaredNmsRadius = nmsRadius * nmsRadius;
          while (poses.length < maxPoseDetections && !queue.empty()) {
            var root = queue.dequeue();
            var rootImageCoords = util_1.getImageCoords(root.part, outputStride, offsetsBuffer);
            if (withinNmsRadiusOfCorrespondingPoint2(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {
              continue;
            }
            var keypoints = decode_pose_1.decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);
            var score = getInstanceScore2(poses, squaredNmsRadius, keypoints);
            poses.push({ keypoints, score });
          }
          return poses;
        }
        exports.decodeMultiplePoses = decodeMultiplePoses2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/resnet.js
    var require_resnet = __commonJS({
      "node_modules/@tensorflow-models/body-pix/resnet.js"(exports) {
        "use strict";
        var __extends2 = exports && exports.__extends || function() {
          var extendStatics2 = function(d, b) {
            extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (b2.hasOwnProperty(p))
                  d2[p] = b2[p];
            };
            return extendStatics2(d, b);
          };
          return function(d, b) {
            extendStatics2(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ResNet = void 0;
        var tf2 = require_tf_core_node();
        var base_model_1 = require_base_model();
        var imageNetMean2 = [-123.15, -115.9, -103.06];
        var ResNet2 = function(_super) {
          __extends2(ResNet3, _super);
          function ResNet3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ResNet3.prototype.preprocessInput = function(input) {
            return tf2.add(input, imageNetMean2);
          };
          ResNet3.prototype.nameOutputResults = function(results) {
            var displacementBwd = results[0], displacementFwd = results[1], heatmap = results[2], longOffsets = results[3], offsets = results[4], partHeatmaps = results[5], segmentation = results[6], partOffsets = results[7];
            return {
              offsets,
              segmentation,
              partHeatmaps,
              longOffsets,
              heatmap,
              displacementFwd,
              displacementBwd,
              partOffsets
            };
          };
          return ResNet3;
        }(base_model_1.BaseModel);
        exports.ResNet = ResNet2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/saved_models.js
    var require_saved_models = __commonJS({
      "node_modules/@tensorflow-models/body-pix/saved_models.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.mobileNetSavedModel = exports.resNet50SavedModel = void 0;
        var RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/";
        var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";
        function resNet50SavedModel(stride, quantBytes) {
          var graphJson = "model-stride" + stride + ".json";
          if (quantBytes === 4) {
            return RESNET50_BASE_URL + "float/" + graphJson;
          } else {
            return RESNET50_BASE_URL + ("quant" + quantBytes + "/") + graphJson;
          }
        }
        exports.resNet50SavedModel = resNet50SavedModel;
        function mobileNetSavedModel(stride, multiplier, quantBytes) {
          var toStr = { 1: "100", 0.75: "075", 0.5: "050" };
          var graphJson = "model-stride" + stride + ".json";
          if (quantBytes === 4) {
            return MOBILENET_BASE_URL + ("float/" + toStr[multiplier] + "/") + graphJson;
          } else {
            return MOBILENET_BASE_URL + ("quant" + quantBytes + "/" + toStr[multiplier] + "/") + graphJson;
          }
        }
        exports.mobileNetSavedModel = mobileNetSavedModel;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/util.js
    var require_util4 = __commonJS({
      "node_modules/@tensorflow-models/body-pix/util.js"(exports) {
        "use strict";
        var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step3(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step3(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step3(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step3((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator2 = exports && exports.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step3([n, v]);
            };
          }
          function step3(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        var _a;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.scaleAndFlipPoses = exports.flipPosesHorizontal = exports.flipPoseHorizontal = exports.scalePoses = exports.scalePose = exports.toTensorBuffers3D = exports.padAndResizeTo = exports.resize2d = exports.removePaddingAndResizeBack = exports.scaleAndCropToInputTensorShape = exports.resizeAndPadTo = exports.toInputTensor = exports.toInputResolutionHeightAndWidth = exports.toValidInputResolution = exports.getInputSize = void 0;
        var tf2 = require_tf_core_node();
        function getSizeFromImageLikeElement(input) {
          if ("offsetHeight" in input && input.offsetHeight !== 0 && "offsetWidth" in input && input.offsetWidth !== 0) {
            return [input.offsetHeight, input.offsetWidth];
          } else if (input.height != null && input.width != null) {
            return [input.height, input.width];
          } else {
            throw new Error("HTMLImageElement must have height and width attributes set.");
          }
        }
        function getSizeFromVideoElement(input) {
          if (input.hasAttribute("height") && input.hasAttribute("width")) {
            return [input.height, input.width];
          } else {
            return [input.videoHeight, input.videoWidth];
          }
        }
        function getInputSize(input) {
          if (typeof HTMLCanvasElement !== "undefined" && input instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && input instanceof OffscreenCanvas || typeof HTMLImageElement !== "undefined" && input instanceof HTMLImageElement) {
            return getSizeFromImageLikeElement(input);
          } else if (typeof ImageData !== "undefined" && input instanceof ImageData) {
            return [input.height, input.width];
          } else if (typeof HTMLVideoElement !== "undefined" && input instanceof HTMLVideoElement) {
            return getSizeFromVideoElement(input);
          } else if (input instanceof tf2.Tensor) {
            return [input.shape[0], input.shape[1]];
          } else {
            throw new Error("error: Unknown input type: " + input + ".");
          }
        }
        exports.getInputSize = getInputSize;
        function isValidInputResolution2(resolution, outputStride) {
          return (resolution - 1) % outputStride === 0;
        }
        function toValidInputResolution(inputResolution, outputStride) {
          if (isValidInputResolution2(inputResolution, outputStride)) {
            return inputResolution;
          }
          return Math.floor(inputResolution / outputStride) * outputStride + 1;
        }
        exports.toValidInputResolution = toValidInputResolution;
        var INTERNAL_RESOLUTION_STRING_OPTIONS = {
          low: "low",
          medium: "medium",
          high: "high",
          full: "full"
        };
        var INTERNAL_RESOLUTION_PERCENTAGES = (_a = {}, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = 0.25, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = 0.5, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = 0.75, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1, _a);
        var MIN_INTERNAL_RESOLUTION = 0.1;
        var MAX_INTERNAL_RESOLUTION = 2;
        function toInternalResolutionPercentage(internalResolution) {
          if (typeof internalResolution === "string") {
            var result2 = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];
            tf2.util.assert(typeof result2 === "number", function() {
              return "string value of inputResolution must be one of " + Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS).join(",") + " but was " + internalResolution + ".";
            });
            return result2;
          } else {
            tf2.util.assert(typeof internalResolution === "number" && internalResolution <= MAX_INTERNAL_RESOLUTION && internalResolution >= MIN_INTERNAL_RESOLUTION, function() {
              return "inputResolution must be a string or number between " + MIN_INTERNAL_RESOLUTION + " and " + MAX_INTERNAL_RESOLUTION + ", but " + ("was " + internalResolution);
            });
            return internalResolution;
          }
        }
        function toInputResolutionHeightAndWidth(internalResolution, outputStride, _a2) {
          var inputHeight = _a2[0], inputWidth = _a2[1];
          var internalResolutionPercentage = toInternalResolutionPercentage(internalResolution);
          return [
            toValidInputResolution(inputHeight * internalResolutionPercentage, outputStride),
            toValidInputResolution(inputWidth * internalResolutionPercentage, outputStride)
          ];
        }
        exports.toInputResolutionHeightAndWidth = toInputResolutionHeightAndWidth;
        function toInputTensor2(input) {
          return input instanceof tf2.Tensor ? input : tf2.browser.fromPixels(input);
        }
        exports.toInputTensor = toInputTensor2;
        function resizeAndPadTo(imageTensor, _a2, flipHorizontal) {
          var targetH = _a2[0], targetW = _a2[1];
          if (flipHorizontal === void 0) {
            flipHorizontal = false;
          }
          var _b = imageTensor.shape, height = _b[0], width = _b[1];
          var targetAspect = targetW / targetH;
          var aspect = width / height;
          var resizeW;
          var resizeH;
          var padL;
          var padR;
          var padT;
          var padB;
          if (aspect > targetAspect) {
            resizeW = targetW;
            resizeH = Math.ceil(resizeW / aspect);
            var padHeight = targetH - resizeH;
            padL = 0;
            padR = 0;
            padT = Math.floor(padHeight / 2);
            padB = targetH - (resizeH + padT);
          } else {
            resizeH = targetH;
            resizeW = Math.ceil(targetH * aspect);
            var padWidth = targetW - resizeW;
            padL = Math.floor(padWidth / 2);
            padR = targetW - (resizeW + padL);
            padT = 0;
            padB = 0;
          }
          var resizedAndPadded = tf2.tidy(function() {
            var resized;
            if (flipHorizontal) {
              resized = tf2.image.resizeBilinear(tf2.reverse(imageTensor, 1), [resizeH, resizeW]);
            } else {
              resized = tf2.image.resizeBilinear(imageTensor, [resizeH, resizeW]);
            }
            var padded = tf2.pad3d(resized, [[padT, padB], [padL, padR], [0, 0]]);
            return padded;
          });
          return { resizedAndPadded, paddedBy: [[padT, padB], [padL, padR]] };
        }
        exports.resizeAndPadTo = resizeAndPadTo;
        function scaleAndCropToInputTensorShape(tensor, _a2, _b, _c, applySigmoidActivation) {
          var inputTensorHeight = _a2[0], inputTensorWidth = _a2[1];
          var resizedAndPaddedHeight = _b[0], resizedAndPaddedWidth = _b[1];
          var _d = _c[0], padT = _d[0], padB = _d[1], _e = _c[1], padL = _e[0], padR = _e[1];
          if (applySigmoidActivation === void 0) {
            applySigmoidActivation = false;
          }
          return tf2.tidy(function() {
            var inResizedAndPadded = tf2.image.resizeBilinear(tensor, [resizedAndPaddedHeight, resizedAndPaddedWidth], true);
            if (applySigmoidActivation) {
              inResizedAndPadded = tf2.sigmoid(inResizedAndPadded);
            }
            return removePaddingAndResizeBack(inResizedAndPadded, [inputTensorHeight, inputTensorWidth], [[padT, padB], [padL, padR]]);
          });
        }
        exports.scaleAndCropToInputTensorShape = scaleAndCropToInputTensorShape;
        function removePaddingAndResizeBack(resizedAndPadded, _a2, _b) {
          var originalHeight = _a2[0], originalWidth = _a2[1];
          var _c = _b[0], padT = _c[0], padB = _c[1], _d = _b[1], padL = _d[0], padR = _d[1];
          return tf2.tidy(function() {
            var batchedImage = tf2.expandDims(resizedAndPadded);
            return tf2.squeeze(tf2.image.cropAndResize(batchedImage, [[
              padT / (originalHeight + padT + padB - 1),
              padL / (originalWidth + padL + padR - 1),
              (padT + originalHeight - 1) / (originalHeight + padT + padB - 1),
              (padL + originalWidth - 1) / (originalWidth + padL + padR - 1)
            ]], [0], [originalHeight, originalWidth]), [0]);
          });
        }
        exports.removePaddingAndResizeBack = removePaddingAndResizeBack;
        function resize2d(tensor, resolution, nearestNeighbor) {
          return tf2.tidy(function() {
            var batchedImage = tf2.expandDims(tensor, 2);
            return tf2.squeeze(tf2.image.resizeBilinear(batchedImage, resolution, nearestNeighbor));
          });
        }
        exports.resize2d = resize2d;
        function padAndResizeTo2(input, _a2) {
          var targetH = _a2[0], targetW = _a2[1];
          var _b = getInputSize(input), height = _b[0], width = _b[1];
          var targetAspect = targetW / targetH;
          var aspect = width / height;
          var _c = [0, 0, 0, 0], padT = _c[0], padB = _c[1], padL = _c[2], padR = _c[3];
          if (aspect < targetAspect) {
            padT = 0;
            padB = 0;
            padL = Math.round(0.5 * (targetAspect * height - width));
            padR = Math.round(0.5 * (targetAspect * height - width));
          } else {
            padT = Math.round(0.5 * (1 / targetAspect * width - height));
            padB = Math.round(0.5 * (1 / targetAspect * width - height));
            padL = 0;
            padR = 0;
          }
          var resized = tf2.tidy(function() {
            var imageTensor = toInputTensor2(input);
            imageTensor = tf2.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);
            return tf2.image.resizeBilinear(imageTensor, [targetH, targetW]);
          });
          return { resized, padding: { top: padT, left: padL, right: padR, bottom: padB } };
        }
        exports.padAndResizeTo = padAndResizeTo2;
        function toTensorBuffers3D2(tensors) {
          return __awaiter2(this, void 0, void 0, function() {
            return __generator2(this, function(_a2) {
              return [2, Promise.all(tensors.map(function(tensor) {
                return tensor.buffer();
              }))];
            });
          });
        }
        exports.toTensorBuffers3D = toTensorBuffers3D2;
        function scalePose2(pose, scaleY, scaleX, offsetY, offsetX) {
          if (offsetY === void 0) {
            offsetY = 0;
          }
          if (offsetX === void 0) {
            offsetX = 0;
          }
          return {
            score: pose.score,
            keypoints: pose.keypoints.map(function(_a2) {
              var score = _a2.score, part = _a2.part, position = _a2.position;
              return {
                score,
                part,
                position: {
                  x: position.x * scaleX + offsetX,
                  y: position.y * scaleY + offsetY
                }
              };
            })
          };
        }
        exports.scalePose = scalePose2;
        function scalePoses2(poses, scaleY, scaleX, offsetY, offsetX) {
          if (offsetY === void 0) {
            offsetY = 0;
          }
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {
            return poses;
          }
          return poses.map(function(pose) {
            return scalePose2(pose, scaleY, scaleX, offsetY, offsetX);
          });
        }
        exports.scalePoses = scalePoses2;
        function flipPoseHorizontal3(pose, imageWidth) {
          return {
            score: pose.score,
            keypoints: pose.keypoints.map(function(_a2) {
              var score = _a2.score, part = _a2.part, position = _a2.position;
              return {
                score,
                part,
                position: { x: imageWidth - 1 - position.x, y: position.y }
              };
            })
          };
        }
        exports.flipPoseHorizontal = flipPoseHorizontal3;
        function flipPosesHorizontal2(poses, imageWidth) {
          if (imageWidth <= 0) {
            return poses;
          }
          return poses.map(function(pose) {
            return flipPoseHorizontal3(pose, imageWidth);
          });
        }
        exports.flipPosesHorizontal = flipPosesHorizontal2;
        function scaleAndFlipPoses2(poses, _a2, _b, padding, flipHorizontal) {
          var height = _a2[0], width = _a2[1];
          var inputResolutionHeight = _b[0], inputResolutionWidth = _b[1];
          var scaleY = (height + padding.top + padding.bottom) / inputResolutionHeight;
          var scaleX = (width + padding.left + padding.right) / inputResolutionWidth;
          var scaledPoses = scalePoses2(poses, scaleY, scaleX, -padding.top, -padding.left);
          if (flipHorizontal) {
            return flipPosesHorizontal2(scaledPoses, width);
          } else {
            return scaledPoses;
          }
        }
        exports.scaleAndFlipPoses = scaleAndFlipPoses2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/body_pix_model.js
    var require_body_pix_model = __commonJS({
      "node_modules/@tensorflow-models/body-pix/body_pix_model.js"(exports) {
        "use strict";
        var __assign2 = exports && exports.__assign || function() {
          __assign2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign2.apply(this, arguments);
        };
        var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step3(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step3(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step3(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step3((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator2 = exports && exports.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step3([n, v]);
            };
          }
          function step3(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.load = exports.BodyPix = exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = exports.PERSON_INFERENCE_CONFIG = void 0;
        var tfconv = require_tf_converter_node();
        var tf2 = require_tf_core_node();
        var decode_part_map_1 = require_decode_part_map();
        var mobilenet_1 = require_mobilenet();
        var decode_instance_masks_1 = require_decode_instance_masks();
        var decode_multiple_poses_1 = require_decode_multiple_poses();
        var resnet_1 = require_resnet();
        var saved_models_1 = require_saved_models();
        var util_1 = require_util4();
        var APPLY_SIGMOID_ACTIVATION = true;
        var FLIP_POSES_AFTER_SCALING = false;
        var MOBILENET_V1_CONFIG = {
          architecture: "MobileNetV1",
          outputStride: 16,
          quantBytes: 4,
          multiplier: 0.75
        };
        var VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"];
        var VALID_STRIDE = {
          "MobileNetV1": [8, 16, 32],
          "ResNet50": [32, 16]
        };
        var VALID_MULTIPLIER = {
          "MobileNetV1": [0.5, 0.75, 1],
          "ResNet50": [1]
        };
        var VALID_QUANT_BYTES = [1, 2, 4];
        function validateModelConfig(config) {
          config = config || MOBILENET_V1_CONFIG;
          if (config.architecture == null) {
            config.architecture = "MobileNetV1";
          }
          if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {
            throw new Error("Invalid architecture " + config.architecture + ". " + ("Should be one of " + VALID_ARCHITECTURE));
          }
          if (config.outputStride == null) {
            config.outputStride = 16;
          }
          if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {
            throw new Error("Invalid outputStride " + config.outputStride + ". " + ("Should be one of " + VALID_STRIDE[config.architecture] + " ") + ("for architecture " + config.architecture + "."));
          }
          if (config.multiplier == null) {
            config.multiplier = 1;
          }
          if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {
            throw new Error("Invalid multiplier " + config.multiplier + ". " + ("Should be one of " + VALID_MULTIPLIER[config.architecture] + " ") + ("for architecture " + config.architecture + "."));
          }
          if (config.quantBytes == null) {
            config.quantBytes = 4;
          }
          if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {
            throw new Error("Invalid quantBytes " + config.quantBytes + ". " + ("Should be one of " + VALID_QUANT_BYTES + " ") + ("for architecture " + config.architecture + "."));
          }
          return config;
        }
        exports.PERSON_INFERENCE_CONFIG = {
          flipHorizontal: false,
          internalResolution: "medium",
          segmentationThreshold: 0.7,
          maxDetections: 10,
          scoreThreshold: 0.4,
          nmsRadius: 20
        };
        exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {
          flipHorizontal: false,
          internalResolution: "medium",
          segmentationThreshold: 0.7,
          maxDetections: 10,
          scoreThreshold: 0.4,
          nmsRadius: 20,
          minKeypointScore: 0.3,
          refineSteps: 10
        };
        function validatePersonInferenceConfig(config) {
          var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius;
          if (segmentationThreshold < 0 || segmentationThreshold > 1) {
            throw new Error("segmentationThreshold " + segmentationThreshold + ". Should be in range [0.0, 1.0]");
          }
          if (maxDetections <= 0) {
            throw new Error("Invalid maxDetections " + maxDetections + ". Should be > 0");
          }
          if (scoreThreshold < 0 || scoreThreshold > 1) {
            throw new Error("Invalid scoreThreshold " + scoreThreshold + ". Should be in range [0.0, 1.0]");
          }
          if (nmsRadius <= 0) {
            throw new Error("Invalid nmsRadius " + nmsRadius + ".");
          }
        }
        function validateMultiPersonInstanceInferenceConfig(config) {
          var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius, minKeypointScore = config.minKeypointScore, refineSteps = config.refineSteps;
          if (segmentationThreshold < 0 || segmentationThreshold > 1) {
            throw new Error("segmentationThreshold " + segmentationThreshold + ". Should be in range [0.0, 1.0]");
          }
          if (maxDetections <= 0) {
            throw new Error("Invalid maxDetections " + maxDetections + ". Should be > 0");
          }
          if (scoreThreshold < 0 || scoreThreshold > 1) {
            throw new Error("Invalid scoreThreshold " + scoreThreshold + ". Should be in range [0.0, 1.0]");
          }
          if (nmsRadius <= 0) {
            throw new Error("Invalid nmsRadius " + nmsRadius + ".");
          }
          if (minKeypointScore < 0 || minKeypointScore > 1) {
            throw new Error("Invalid minKeypointScore " + minKeypointScore + ".Should be in range [0.0, 1.0]");
          }
          if (refineSteps <= 0 || refineSteps > 20) {
            throw new Error("Invalid refineSteps " + refineSteps + ".Should be in range [1, 20]");
          }
        }
        var BodyPix = function() {
          function BodyPix2(net) {
            this.baseModel = net;
          }
          BodyPix2.prototype.predictForPersonSegmentation = function(input) {
            var _a = this.baseModel.predict(input), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;
            return {
              segmentLogits: segmentation,
              heatmapScores,
              offsets,
              displacementFwd,
              displacementBwd
            };
          };
          BodyPix2.prototype.predictForPersonSegmentationAndPart = function(input) {
            var _a = this.baseModel.predict(input), segmentation = _a.segmentation, partHeatmaps = _a.partHeatmaps, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;
            return {
              segmentLogits: segmentation,
              partHeatmapLogits: partHeatmaps,
              heatmapScores,
              offsets,
              displacementFwd,
              displacementBwd
            };
          };
          BodyPix2.prototype.predictForMultiPersonInstanceSegmentationAndPart = function(input) {
            var _a = this.baseModel.predict(input), segmentation = _a.segmentation, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, partHeatmaps = _a.partHeatmaps;
            return {
              segmentLogits: segmentation,
              longOffsets,
              heatmapScores,
              offsets,
              displacementFwd,
              displacementBwd,
              partHeatmaps
            };
          };
          BodyPix2.prototype.segmentPersonActivation = function(input, internalResolution, segmentationThreshold) {
            var _this = this;
            if (segmentationThreshold === void 0) {
              segmentationThreshold = 0.5;
            }
            var _a = util_1.getInputSize(input), height = _a[0], width = _a[1];
            var internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);
            var _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
            var _c = tf2.tidy(function() {
              var _a2 = _this.predictForPersonSegmentation(resized), segmentLogits = _a2.segmentLogits, heatmapScores2 = _a2.heatmapScores, offsets2 = _a2.offsets, displacementFwd2 = _a2.displacementFwd, displacementBwd2 = _a2.displacementBwd;
              var _b2 = resized.shape, resizedHeight = _b2[0], resizedWidth = _b2[1];
              var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
              return {
                segmentation: decode_part_map_1.toMaskTensor(tf2.squeeze(scaledSegmentScores), segmentationThreshold),
                heatmapScores: heatmapScores2,
                offsets: offsets2,
                displacementFwd: displacementFwd2,
                displacementBwd: displacementBwd2
              };
            }), segmentation = _c.segmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;
            resized.dispose();
            return {
              segmentation,
              heatmapScores,
              offsets,
              displacementFwd,
              displacementBwd,
              padding,
              internalResolutionHeightAndWidth
            };
          };
          BodyPix2.prototype.segmentPerson = function(input, config) {
            if (config === void 0) {
              config = exports.PERSON_INFERENCE_CONFIG;
            }
            return __awaiter2(this, void 0, void 0, function() {
              var _a, segmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, result2, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;
              return __generator2(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    config = __assign2(__assign2({}, exports.PERSON_INFERENCE_CONFIG), config);
                    validatePersonInferenceConfig(config);
                    _a = this.segmentPersonActivation(input, config.internalResolution, config.segmentationThreshold), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;
                    _b = segmentation.shape, height = _b[0], width = _b[1];
                    return [4, segmentation.data()];
                  case 1:
                    result2 = _c.sent();
                    segmentation.dispose();
                    return [4, util_1.toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];
                  case 2:
                    tensorBuffers = _c.sent();
                    scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
                    poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);
                    poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);
                    heatmapScores.dispose();
                    offsets.dispose();
                    displacementFwd.dispose();
                    displacementBwd.dispose();
                    return [2, { height, width, data: result2, allPoses: poses }];
                }
              });
            });
          };
          BodyPix2.prototype.segmentMultiPerson = function(input, config) {
            if (config === void 0) {
              config = exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG;
            }
            return __awaiter2(this, void 0, void 0, function() {
              var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;
              var _this = this;
              return __generator2(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    config = __assign2(__assign2({}, exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config);
                    validateMultiPersonInstanceInferenceConfig(config);
                    _a = util_1.getInputSize(input), height = _a[0], width = _a[1];
                    internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);
                    _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
                    _c = tf2.tidy(function() {
                      var _a2 = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a2.segmentLogits, longOffsets2 = _a2.longOffsets, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd;
                      var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
                      var longOffsetsResized = false;
                      var scaledLongOffsets;
                      if (longOffsetsResized) {
                        scaledLongOffsets = util_1.scaleAndCropToInputTensorShape(longOffsets2, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
                      } else {
                        scaledLongOffsets = longOffsets2;
                      }
                      var segmentation2 = decode_part_map_1.toMaskTensor(tf2.squeeze(scaledSegmentScores), config.segmentationThreshold);
                      return {
                        segmentation: segmentation2,
                        longOffsets: scaledLongOffsets,
                        heatmapScoresRaw: heatmapScores,
                        offsetsRaw: offsets,
                        displacementFwdRaw: displacementFwd,
                        displacementBwdRaw: displacementBwd
                      };
                    }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw;
                    return [4, util_1.toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];
                  case 1:
                    tensorBuffers = _d.sent();
                    scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
                    poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);
                    poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);
                    return [4, decode_instance_masks_1.decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];
                  case 2:
                    instanceMasks = _d.sent();
                    resized.dispose();
                    segmentation.dispose();
                    longOffsets.dispose();
                    heatmapScoresRaw.dispose();
                    offsetsRaw.dispose();
                    displacementFwdRaw.dispose();
                    displacementBwdRaw.dispose();
                    return [2, instanceMasks];
                }
              });
            });
          };
          BodyPix2.prototype.segmentPersonPartsActivation = function(input, internalResolution, segmentationThreshold) {
            var _this = this;
            if (segmentationThreshold === void 0) {
              segmentationThreshold = 0.5;
            }
            var _a = util_1.getInputSize(input), height = _a[0], width = _a[1];
            var internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);
            var _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
            var _c = tf2.tidy(function() {
              var _a2 = _this.predictForPersonSegmentationAndPart(resized), segmentLogits = _a2.segmentLogits, partHeatmapLogits = _a2.partHeatmapLogits, heatmapScores2 = _a2.heatmapScores, offsets2 = _a2.offsets, displacementFwd2 = _a2.displacementFwd, displacementBwd2 = _a2.displacementBwd;
              var _b2 = resized.shape, resizedHeight = _b2[0], resizedWidth = _b2[1];
              var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
              var scaledPartHeatmapScore = util_1.scaleAndCropToInputTensorShape(partHeatmapLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
              var segmentation = decode_part_map_1.toMaskTensor(tf2.squeeze(scaledSegmentScores), segmentationThreshold);
              return {
                partSegmentation: decode_part_map_1.decodePartSegmentation(segmentation, scaledPartHeatmapScore),
                heatmapScores: heatmapScores2,
                offsets: offsets2,
                displacementFwd: displacementFwd2,
                displacementBwd: displacementBwd2
              };
            }), partSegmentation = _c.partSegmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;
            resized.dispose();
            return {
              partSegmentation,
              heatmapScores,
              offsets,
              displacementFwd,
              displacementBwd,
              padding,
              internalResolutionHeightAndWidth
            };
          };
          BodyPix2.prototype.segmentPersonParts = function(input, config) {
            if (config === void 0) {
              config = exports.PERSON_INFERENCE_CONFIG;
            }
            return __awaiter2(this, void 0, void 0, function() {
              var _a, partSegmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, data, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;
              return __generator2(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    config = __assign2(__assign2({}, exports.PERSON_INFERENCE_CONFIG), config);
                    validatePersonInferenceConfig(config);
                    _a = this.segmentPersonPartsActivation(input, config.internalResolution, config.segmentationThreshold), partSegmentation = _a.partSegmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;
                    _b = partSegmentation.shape, height = _b[0], width = _b[1];
                    return [4, partSegmentation.data()];
                  case 1:
                    data = _c.sent();
                    partSegmentation.dispose();
                    return [4, util_1.toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];
                  case 2:
                    tensorBuffers = _c.sent();
                    scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
                    poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);
                    poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);
                    heatmapScores.dispose();
                    offsets.dispose();
                    displacementFwd.dispose();
                    displacementBwd.dispose();
                    return [2, { height, width, data, allPoses: poses }];
                }
              });
            });
          };
          BodyPix2.prototype.segmentMultiPersonParts = function(input, config) {
            if (config === void 0) {
              config = exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG;
            }
            return __awaiter2(this, void 0, void 0, function() {
              var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, partSegmentation, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;
              var _this = this;
              return __generator2(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    config = __assign2(__assign2({}, exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config);
                    validateMultiPersonInstanceInferenceConfig(config);
                    _a = util_1.getInputSize(input), height = _a[0], width = _a[1];
                    internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);
                    _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
                    _c = tf2.tidy(function() {
                      var _a2 = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a2.segmentLogits, longOffsets2 = _a2.longOffsets, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd, partHeatmaps = _a2.partHeatmaps;
                      var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
                      var scaledPartSegmentationScores = util_1.scaleAndCropToInputTensorShape(partHeatmaps, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);
                      var scaledLongOffsets = longOffsets2;
                      var segmentation2 = decode_part_map_1.toMaskTensor(tf2.squeeze(scaledSegmentScores), config.segmentationThreshold);
                      var partSegmentation2 = decode_part_map_1.decodeOnlyPartSegmentation(scaledPartSegmentationScores);
                      return {
                        segmentation: segmentation2,
                        longOffsets: scaledLongOffsets,
                        heatmapScoresRaw: heatmapScores,
                        offsetsRaw: offsets,
                        displacementFwdRaw: displacementFwd,
                        displacementBwdRaw: displacementBwd,
                        partSegmentation: partSegmentation2
                      };
                    }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw, partSegmentation = _c.partSegmentation;
                    return [4, util_1.toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];
                  case 1:
                    tensorBuffers = _d.sent();
                    scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
                    poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);
                    poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);
                    return [4, decode_instance_masks_1.decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];
                  case 2:
                    instanceMasks = _d.sent();
                    resized.dispose();
                    segmentation.dispose();
                    longOffsets.dispose();
                    heatmapScoresRaw.dispose();
                    offsetsRaw.dispose();
                    displacementFwdRaw.dispose();
                    displacementBwdRaw.dispose();
                    partSegmentation.dispose();
                    return [2, instanceMasks];
                }
              });
            });
          };
          BodyPix2.prototype.dispose = function() {
            this.baseModel.dispose();
          };
          return BodyPix2;
        }();
        exports.BodyPix = BodyPix;
        function loadMobileNet(config) {
          return __awaiter2(this, void 0, void 0, function() {
            var outputStride, quantBytes, multiplier, url, graphModel, mobilenet;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  outputStride = config.outputStride;
                  quantBytes = config.quantBytes;
                  multiplier = config.multiplier;
                  if (tf2 == null) {
                    throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
                  }
                  url = saved_models_1.mobileNetSavedModel(outputStride, multiplier, quantBytes);
                  return [4, tfconv.loadGraphModel(config.modelUrl || url)];
                case 1:
                  graphModel = _a.sent();
                  mobilenet = new mobilenet_1.MobileNet(graphModel, outputStride);
                  return [2, new BodyPix(mobilenet)];
              }
            });
          });
        }
        function loadResNet(config) {
          return __awaiter2(this, void 0, void 0, function() {
            var outputStride, quantBytes, url, graphModel, resnet;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  outputStride = config.outputStride;
                  quantBytes = config.quantBytes;
                  if (tf2 == null) {
                    throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
                  }
                  url = saved_models_1.resNet50SavedModel(outputStride, quantBytes);
                  return [4, tfconv.loadGraphModel(config.modelUrl || url)];
                case 1:
                  graphModel = _a.sent();
                  resnet = new resnet_1.ResNet(graphModel, outputStride);
                  return [2, new BodyPix(resnet)];
              }
            });
          });
        }
        function load3(config) {
          if (config === void 0) {
            config = MOBILENET_V1_CONFIG;
          }
          return __awaiter2(this, void 0, void 0, function() {
            return __generator2(this, function(_a) {
              config = validateModelConfig(config);
              if (config.architecture === "ResNet50") {
                return [2, loadResNet(config)];
              } else if (config.architecture === "MobileNetV1") {
                return [2, loadMobileNet(config)];
              } else {
                return [2, null];
              }
              return [2];
            });
          });
        }
        exports.load = load3;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/blur.js
    var require_blur = __commonJS({
      "node_modules/@tensorflow-models/body-pix/blur.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.cpuBlur = void 0;
        function cpuBlur(canvas, image2, blur) {
          var ctx = canvas.getContext("2d");
          var sum4 = 0;
          var delta = 5;
          var alphaLeft = 1 / (2 * Math.PI * delta * delta);
          var step3 = blur < 3 ? 1 : 2;
          for (var y = -blur; y <= blur; y += step3) {
            for (var x = -blur; x <= blur; x += step3) {
              var weight = alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));
              sum4 += weight;
            }
          }
          for (var y = -blur; y <= blur; y += step3) {
            for (var x = -blur; x <= blur; x += step3) {
              ctx.globalAlpha = alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum4 * blur;
              ctx.drawImage(image2, x, y);
            }
          }
          ctx.globalAlpha = 1;
        }
        exports.cpuBlur = cpuBlur;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/output_rendering_util.js
    var require_output_rendering_util = __commonJS({
      "node_modules/@tensorflow-models/body-pix/output_rendering_util.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.blurBodyPart = exports.drawBokehEffect = exports.drawPixelatedMask = exports.drawMask = exports.toColoredPartMask = exports.toMask = void 0;
        var blur_1 = require_blur();
        var util_1 = require_util4();
        var offScreenCanvases = {};
        function isSafari() {
          return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        }
        function assertSameDimensions(_a, _b, nameA, nameB) {
          var widthA = _a.width, heightA = _a.height;
          var widthB = _b.width, heightB = _b.height;
          if (widthA !== widthB || heightA !== heightB) {
            throw new Error("error: dimensions must match. " + nameA + " has dimensions " + widthA + "x" + heightA + ", " + nameB + " has dimensions " + widthB + "x" + heightB);
          }
        }
        function flipCanvasHorizontal(canvas) {
          var ctx = canvas.getContext("2d");
          ctx.scale(-1, 1);
          ctx.translate(-canvas.width, 0);
        }
        function drawWithCompositing(ctx, image2, compositeOperation) {
          ctx.globalCompositeOperation = compositeOperation;
          ctx.drawImage(image2, 0, 0);
        }
        function createOffScreenCanvas() {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(0, 0);
          } else {
            throw new Error("Cannot create a canvas in this context");
          }
        }
        function ensureOffscreenCanvasCreated(id) {
          if (!offScreenCanvases[id]) {
            offScreenCanvases[id] = createOffScreenCanvas();
          }
          return offScreenCanvases[id];
        }
        function drawAndBlurImageOnCanvas(image2, blurAmount, canvas) {
          var height = image2.height, width = image2.width;
          var ctx = canvas.getContext("2d");
          canvas.width = width;
          canvas.height = height;
          ctx.clearRect(0, 0, width, height);
          ctx.save();
          if (isSafari()) {
            blur_1.cpuBlur(canvas, image2, blurAmount);
          } else {
            ctx.filter = "blur(" + blurAmount + "px)";
            ctx.drawImage(image2, 0, 0, width, height);
          }
          ctx.restore();
        }
        function drawAndBlurImageOnOffScreenCanvas(image2, blurAmount, offscreenCanvasName) {
          var canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);
          if (blurAmount === 0) {
            renderImageToCanvas(image2, canvas);
          } else {
            drawAndBlurImageOnCanvas(image2, blurAmount, canvas);
          }
          return canvas;
        }
        function renderImageToCanvas(image2, canvas) {
          var width = image2.width, height = image2.height;
          canvas.width = width;
          canvas.height = height;
          var ctx = canvas.getContext("2d");
          ctx.drawImage(image2, 0, 0, width, height);
        }
        function renderImageDataToCanvas(image2, canvas) {
          canvas.width = image2.width;
          canvas.height = image2.height;
          var ctx = canvas.getContext("2d");
          ctx.putImageData(image2, 0, 0);
        }
        function renderImageDataToOffScreenCanvas(image2, canvasName) {
          var canvas = ensureOffscreenCanvasCreated(canvasName);
          renderImageDataToCanvas(image2, canvas);
          return canvas;
        }
        function toMask2(personOrPartSegmentation, foreground, background, drawContour, foregroundIds) {
          if (foreground === void 0) {
            foreground = {
              r: 0,
              g: 0,
              b: 0,
              a: 0
            };
          }
          if (background === void 0) {
            background = {
              r: 0,
              g: 0,
              b: 0,
              a: 255
            };
          }
          if (drawContour === void 0) {
            drawContour = false;
          }
          if (foregroundIds === void 0) {
            foregroundIds = [1];
          }
          if (Array.isArray(personOrPartSegmentation) && personOrPartSegmentation.length === 0) {
            return null;
          }
          var multiPersonOrPartSegmentation;
          if (!Array.isArray(personOrPartSegmentation)) {
            multiPersonOrPartSegmentation = [personOrPartSegmentation];
          } else {
            multiPersonOrPartSegmentation = personOrPartSegmentation;
          }
          var _a = multiPersonOrPartSegmentation[0], width = _a.width, height = _a.height;
          var bytes = new Uint8ClampedArray(width * height * 4);
          function drawStroke(bytes2, row, column, width2, radius, color2) {
            if (color2 === void 0) {
              color2 = { r: 0, g: 255, b: 255, a: 255 };
            }
            for (var i2 = -radius; i2 <= radius; i2++) {
              for (var j2 = -radius; j2 <= radius; j2++) {
                if (i2 !== 0 && j2 !== 0) {
                  var n = (row + i2) * width2 + (column + j2);
                  bytes2[4 * n + 0] = color2.r;
                  bytes2[4 * n + 1] = color2.g;
                  bytes2[4 * n + 2] = color2.b;
                  bytes2[4 * n + 3] = color2.a;
                }
              }
            }
          }
          function isSegmentationBoundary(segmentationData, row, column, width2, foregroundIds2, radius) {
            if (foregroundIds2 === void 0) {
              foregroundIds2 = [1];
            }
            if (radius === void 0) {
              radius = 1;
            }
            var numberBackgroundPixels = 0;
            for (var i2 = -radius; i2 <= radius; i2++) {
              var _loop_2 = function(j3) {
                if (i2 !== 0 && j3 !== 0) {
                  var n_1 = (row + i2) * width2 + (column + j3);
                  if (!foregroundIds2.some(function(id) {
                    return id === segmentationData[n_1];
                  })) {
                    numberBackgroundPixels += 1;
                  }
                }
              };
              for (var j2 = -radius; j2 <= radius; j2++) {
                _loop_2(j2);
              }
            }
            return numberBackgroundPixels > 0;
          }
          for (var i = 0; i < height; i += 1) {
            var _loop_1 = function(j2) {
              var n = i * width + j2;
              bytes[4 * n + 0] = background.r;
              bytes[4 * n + 1] = background.g;
              bytes[4 * n + 2] = background.b;
              bytes[4 * n + 3] = background.a;
              var _loop_3 = function(k3) {
                if (foregroundIds.some(function(id) {
                  return id === multiPersonOrPartSegmentation[k3].data[n];
                })) {
                  bytes[4 * n] = foreground.r;
                  bytes[4 * n + 1] = foreground.g;
                  bytes[4 * n + 2] = foreground.b;
                  bytes[4 * n + 3] = foreground.a;
                  var isBoundary = isSegmentationBoundary(multiPersonOrPartSegmentation[k3].data, i, j2, width, foregroundIds);
                  if (drawContour && i - 1 >= 0 && i + 1 < height && j2 - 1 >= 0 && j2 + 1 < width && isBoundary) {
                    drawStroke(bytes, i, j2, width, 1);
                  }
                }
              };
              for (var k = 0; k < multiPersonOrPartSegmentation.length; k++) {
                _loop_3(k);
              }
            };
            for (var j = 0; j < width; j += 1) {
              _loop_1(j);
            }
          }
          return new ImageData(bytes, width, height);
        }
        exports.toMask = toMask2;
        var RAINBOW_PART_COLORS = [
          [110, 64, 170],
          [143, 61, 178],
          [178, 60, 178],
          [210, 62, 167],
          [238, 67, 149],
          [255, 78, 125],
          [255, 94, 99],
          [255, 115, 75],
          [255, 140, 56],
          [239, 167, 47],
          [217, 194, 49],
          [194, 219, 64],
          [175, 240, 91],
          [135, 245, 87],
          [96, 247, 96],
          [64, 243, 115],
          [40, 234, 141],
          [28, 219, 169],
          [26, 199, 194],
          [33, 176, 213],
          [47, 150, 224],
          [65, 125, 224],
          [84, 101, 214],
          [99, 81, 195]
        ];
        function toColoredPartMask2(partSegmentation, partColors) {
          if (partColors === void 0) {
            partColors = RAINBOW_PART_COLORS;
          }
          if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {
            return null;
          }
          var multiPersonPartSegmentation2;
          if (!Array.isArray(partSegmentation)) {
            multiPersonPartSegmentation2 = [partSegmentation];
          } else {
            multiPersonPartSegmentation2 = partSegmentation;
          }
          var _a = multiPersonPartSegmentation2[0], width = _a.width, height = _a.height;
          var bytes = new Uint8ClampedArray(width * height * 4);
          for (var i = 0; i < height * width; ++i) {
            var j = i * 4;
            bytes[j + 0] = 255;
            bytes[j + 1] = 255;
            bytes[j + 2] = 255;
            bytes[j + 3] = 255;
            for (var k = 0; k < multiPersonPartSegmentation2.length; k++) {
              var partId = multiPersonPartSegmentation2[k].data[i];
              if (partId !== -1) {
                var color2 = partColors[partId];
                if (!color2) {
                  throw new Error("No color could be found for part id " + partId);
                }
                bytes[j + 0] = color2[0];
                bytes[j + 1] = color2[1];
                bytes[j + 2] = color2[2];
                bytes[j + 3] = 255;
              }
            }
          }
          return new ImageData(bytes, width, height);
        }
        exports.toColoredPartMask = toColoredPartMask2;
        var CANVAS_NAMES = {
          blurred: "blurred",
          blurredMask: "blurred-mask",
          mask: "mask",
          lowresPartMask: "lowres-part-mask"
        };
        function drawMask2(canvas, image2, maskImage, maskOpacity, maskBlurAmount, flipHorizontal) {
          if (maskOpacity === void 0) {
            maskOpacity = 0.7;
          }
          if (maskBlurAmount === void 0) {
            maskBlurAmount = 0;
          }
          if (flipHorizontal === void 0) {
            flipHorizontal = false;
          }
          var _a = util_1.getInputSize(image2), height = _a[0], width = _a[1];
          canvas.width = width;
          canvas.height = height;
          var ctx = canvas.getContext("2d");
          ctx.save();
          if (flipHorizontal) {
            flipCanvasHorizontal(canvas);
          }
          ctx.drawImage(image2, 0, 0);
          ctx.globalAlpha = maskOpacity;
          if (maskImage) {
            assertSameDimensions({ width, height }, maskImage, "image", "mask");
            var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);
            var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);
            ctx.drawImage(blurredMask, 0, 0, width, height);
          }
          ctx.restore();
        }
        exports.drawMask = drawMask2;
        function drawPixelatedMask2(canvas, image2, maskImage, maskOpacity, maskBlurAmount, flipHorizontal, pixelCellWidth) {
          if (maskOpacity === void 0) {
            maskOpacity = 0.7;
          }
          if (maskBlurAmount === void 0) {
            maskBlurAmount = 0;
          }
          if (flipHorizontal === void 0) {
            flipHorizontal = false;
          }
          if (pixelCellWidth === void 0) {
            pixelCellWidth = 10;
          }
          var _a = util_1.getInputSize(image2), height = _a[0], width = _a[1];
          assertSameDimensions({ width, height }, maskImage, "image", "mask");
          var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);
          var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);
          canvas.width = blurredMask.width;
          canvas.height = blurredMask.height;
          var ctx = canvas.getContext("2d");
          ctx.save();
          if (flipHorizontal) {
            flipCanvasHorizontal(canvas);
          }
          var offscreenCanvas = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);
          var offscreenCanvasCtx = offscreenCanvas.getContext("2d");
          offscreenCanvas.width = blurredMask.width * (1 / pixelCellWidth);
          offscreenCanvas.height = blurredMask.height * (1 / pixelCellWidth);
          offscreenCanvasCtx.drawImage(blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width, canvas.height);
          for (var i = 0; i < offscreenCanvas.width; i++) {
            ctx.beginPath();
            ctx.strokeStyle = "#ffffff";
            ctx.moveTo(pixelCellWidth * i, 0);
            ctx.lineTo(pixelCellWidth * i, canvas.height);
            ctx.stroke();
          }
          for (var i = 0; i < offscreenCanvas.height; i++) {
            ctx.beginPath();
            ctx.strokeStyle = "#ffffff";
            ctx.moveTo(0, pixelCellWidth * i);
            ctx.lineTo(canvas.width, pixelCellWidth * i);
            ctx.stroke();
          }
          ctx.globalAlpha = 1 - maskOpacity;
          ctx.drawImage(image2, 0, 0, blurredMask.width, blurredMask.height);
          ctx.restore();
        }
        exports.drawPixelatedMask = drawPixelatedMask2;
        function createPersonMask(multiPersonSegmentation, edgeBlurAmount) {
          var backgroundMaskImage = toMask2(multiPersonSegmentation, { r: 0, g: 0, b: 0, a: 255 }, { r: 0, g: 0, b: 0, a: 0 });
          var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);
          if (edgeBlurAmount === 0) {
            return backgroundMask;
          } else {
            return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);
          }
        }
        function drawBokehEffect2(canvas, image2, multiPersonSegmentation, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {
          if (backgroundBlurAmount === void 0) {
            backgroundBlurAmount = 3;
          }
          if (edgeBlurAmount === void 0) {
            edgeBlurAmount = 3;
          }
          if (flipHorizontal === void 0) {
            flipHorizontal = false;
          }
          var blurredImage = drawAndBlurImageOnOffScreenCanvas(image2, backgroundBlurAmount, CANVAS_NAMES.blurred);
          canvas.width = blurredImage.width;
          canvas.height = blurredImage.height;
          var ctx = canvas.getContext("2d");
          if (Array.isArray(multiPersonSegmentation) && multiPersonSegmentation.length === 0) {
            ctx.drawImage(blurredImage, 0, 0);
            return;
          }
          var personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);
          ctx.save();
          if (flipHorizontal) {
            flipCanvasHorizontal(canvas);
          }
          var _a = util_1.getInputSize(image2), height = _a[0], width = _a[1];
          ctx.drawImage(image2, 0, 0, width, height);
          drawWithCompositing(ctx, personMask, "destination-in");
          drawWithCompositing(ctx, blurredImage, "destination-over");
          ctx.restore();
        }
        exports.drawBokehEffect = drawBokehEffect2;
        function createBodyPartMask(multiPersonPartSegmentation2, bodyPartIdsToMask, edgeBlurAmount) {
          var backgroundMaskImage = toMask2(multiPersonPartSegmentation2, { r: 0, g: 0, b: 0, a: 0 }, { r: 0, g: 0, b: 0, a: 255 }, true, bodyPartIdsToMask);
          var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);
          if (edgeBlurAmount === 0) {
            return backgroundMask;
          } else {
            return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);
          }
        }
        function blurBodyPart2(canvas, image2, partSegmentation, bodyPartIdsToBlur, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {
          if (bodyPartIdsToBlur === void 0) {
            bodyPartIdsToBlur = [0, 1];
          }
          if (backgroundBlurAmount === void 0) {
            backgroundBlurAmount = 3;
          }
          if (edgeBlurAmount === void 0) {
            edgeBlurAmount = 3;
          }
          if (flipHorizontal === void 0) {
            flipHorizontal = false;
          }
          var blurredImage = drawAndBlurImageOnOffScreenCanvas(image2, backgroundBlurAmount, CANVAS_NAMES.blurred);
          canvas.width = blurredImage.width;
          canvas.height = blurredImage.height;
          var ctx = canvas.getContext("2d");
          if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {
            ctx.drawImage(blurredImage, 0, 0);
            return;
          }
          var bodyPartMask = createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);
          ctx.save();
          if (flipHorizontal) {
            flipCanvasHorizontal(canvas);
          }
          var _a = util_1.getInputSize(image2), height = _a[0], width = _a[1];
          ctx.drawImage(image2, 0, 0, width, height);
          drawWithCompositing(ctx, bodyPartMask, "destination-in");
          drawWithCompositing(ctx, blurredImage, "destination-over");
          ctx.restore();
        }
        exports.blurBodyPart = blurBodyPart2;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/part_channels.js
    var require_part_channels = __commonJS({
      "node_modules/@tensorflow-models/body-pix/part_channels.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.PART_CHANNELS = void 0;
        exports.PART_CHANNELS = [
          "left_face",
          "right_face",
          "left_upper_arm_front",
          "left_upper_arm_back",
          "right_upper_arm_front",
          "right_upper_arm_back",
          "left_lower_arm_front",
          "left_lower_arm_back",
          "right_lower_arm_front",
          "right_lower_arm_back",
          "left_hand",
          "right_hand",
          "torso_front",
          "torso_back",
          "left_upper_leg_front",
          "left_upper_leg_back",
          "right_upper_leg_front",
          "right_upper_leg_back",
          "left_lower_leg_front",
          "left_lower_leg_back",
          "right_lower_leg_front",
          "right_lower_leg_back",
          "left_feet",
          "right_feet"
        ];
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/version.js
    var require_version = __commonJS({
      "node_modules/@tensorflow-models/body-pix/version.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.version = void 0;
        var version = "2.2.0";
        exports.version = version;
      }
    });
  
    // node_modules/@tensorflow-models/body-pix/index.js
    var require_body_pix = __commonJS({
      "node_modules/@tensorflow-models/body-pix/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var body_pix_model_1 = require_body_pix_model();
        Object.defineProperty(exports, "BodyPix", { enumerable: true, get: function() {
          return body_pix_model_1.BodyPix;
        } });
        Object.defineProperty(exports, "load", { enumerable: true, get: function() {
          return body_pix_model_1.load;
        } });
        var output_rendering_util_1 = require_output_rendering_util();
        Object.defineProperty(exports, "blurBodyPart", { enumerable: true, get: function() {
          return output_rendering_util_1.blurBodyPart;
        } });
        Object.defineProperty(exports, "drawBokehEffect", { enumerable: true, get: function() {
          return output_rendering_util_1.drawBokehEffect;
        } });
        Object.defineProperty(exports, "drawMask", { enumerable: true, get: function() {
          return output_rendering_util_1.drawMask;
        } });
        Object.defineProperty(exports, "drawPixelatedMask", { enumerable: true, get: function() {
          return output_rendering_util_1.drawPixelatedMask;
        } });
        Object.defineProperty(exports, "toColoredPartMask", { enumerable: true, get: function() {
          return output_rendering_util_1.toColoredPartMask;
        } });
        Object.defineProperty(exports, "toMask", { enumerable: true, get: function() {
          return output_rendering_util_1.toMask;
        } });
        var part_channels_1 = require_part_channels();
        Object.defineProperty(exports, "PART_CHANNELS", { enumerable: true, get: function() {
          return part_channels_1.PART_CHANNELS;
        } });
        var util_1 = require_util4();
        Object.defineProperty(exports, "flipPoseHorizontal", { enumerable: true, get: function() {
          return util_1.flipPoseHorizontal;
        } });
        Object.defineProperty(exports, "resizeAndPadTo", { enumerable: true, get: function() {
          return util_1.resizeAndPadTo;
        } });
        Object.defineProperty(exports, "scaleAndCropToInputTensorShape", { enumerable: true, get: function() {
          return util_1.scaleAndCropToInputTensorShape;
        } });
        var version_1 = require_version();
        Object.defineProperty(exports, "version", { enumerable: true, get: function() {
          return version_1.version;
        } });
      }
    });
  
    // node_modules/stats.js/build/stats.min.js
    var require_stats_min = __commonJS({
      "node_modules/stats.js/build/stats.min.js"(exports, module) {
        (function(f, e) {
          typeof exports === "object" && typeof module !== "undefined" ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : f.Stats = e();
        })(exports, function() {
          var f = function() {
            function e(a2) {
              c.appendChild(a2.dom);
              return a2;
            }
            function u(a2) {
              for (var d = 0; d < c.children.length; d++)
                c.children[d].style.display = d === a2 ? "block" : "none";
              l = a2;
            }
            var l = 0, c = document.createElement("div");
            c.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
            c.addEventListener("click", function(a2) {
              a2.preventDefault();
              u(++l % c.children.length);
            }, false);
            var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel("FPS", "#0ff", "#002")), h = e(new f.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory)
              var t = e(new f.Panel("MB", "#f08", "#201"));
            u(0);
            return { REVISION: 16, dom: c, addPanel: e, showPanel: u, begin: function() {
              k = (performance || Date).now();
            }, end: function() {
              a++;
              var c2 = (performance || Date).now();
              h.update(c2 - k, 200);
              if (c2 > g + 1e3 && (r.update(1e3 * a / (c2 - g), 100), g = c2, a = 0, t)) {
                var d = performance.memory;
                t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);
              }
              return c2;
            }, update: function() {
              k = this.end();
            }, domElement: c, setMode: u };
          };
          f.Panel = function(e, f2, l) {
            var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement("canvas");
            q.width = r;
            q.height = h;
            q.style.cssText = "width:80px;height:48px";
            var b = q.getContext("2d");
            b.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif";
            b.textBaseline = "top";
            b.fillStyle = l;
            b.fillRect(0, 0, r, h);
            b.fillStyle = f2;
            b.fillText(e, t, v);
            b.fillRect(d, m, n, p);
            b.fillStyle = l;
            b.globalAlpha = 0.9;
            b.fillRect(d, m, n, p);
            return { dom: q, update: function(h2, w) {
              c = Math.min(c, h2);
              k = Math.max(k, h2);
              b.fillStyle = l;
              b.globalAlpha = 1;
              b.fillRect(0, 0, r, m);
              b.fillStyle = f2;
              b.fillText(g(h2) + " " + e + " (" + g(c) + "-" + g(k) + ")", t, v);
              b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);
              b.fillRect(d + n - a, m, a, p);
              b.fillStyle = l;
              b.globalAlpha = 0.9;
              b.fillRect(d + n - a, m, a, g((1 - h2 / w) * p));
            } };
          };
          return f;
        });
      }
    });
  
    // ../../../tfjs/tfjs-core/dist/backends/backend.js
    var EPSILON_FLOAT32 = 1e-7;
    var EPSILON_FLOAT16 = 1e-4;
    var DataStorage = class {
      constructor(backend, dataMover) {
        this.backend = backend;
        this.dataMover = dataMover;
        this.data = new WeakMap();
        this.dataIdsCount = 0;
      }
      get(dataId) {
        if (!this.data.has(dataId)) {
          this.dataMover.moveData(this.backend, dataId);
        }
        return this.data.get(dataId);
      }
      set(dataId, value) {
        this.dataIdsCount++;
        this.data.set(dataId, value);
      }
      has(dataId) {
        return this.data.has(dataId);
      }
      delete(dataId) {
        this.dataIdsCount--;
        return this.data.delete(dataId);
      }
      numDataIds() {
        return this.dataIdsCount;
      }
    };
    var KernelBackend = class {
      refCount(dataId) {
        return notYetImplemented("refCount");
      }
      incRef(dataId) {
        return notYetImplemented("incRef");
      }
      timerAvailable() {
        return true;
      }
      time(f) {
        return notYetImplemented("time");
      }
      read(dataId) {
        return notYetImplemented("read");
      }
      readSync(dataId) {
        return notYetImplemented("readSync");
      }
      numDataIds() {
        return notYetImplemented("numDataIds");
      }
      disposeData(dataId, force) {
        return notYetImplemented("disposeData");
      }
      write(values, shape, dtype) {
        return notYetImplemented("write");
      }
      move(dataId, values, shape, dtype, refCount) {
        return notYetImplemented("move");
      }
      memory() {
        return notYetImplemented("memory");
      }
      floatPrecision() {
        return notYetImplemented("floatPrecision");
      }
      epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
      }
      dispose() {
        return notYetImplemented("dispose");
      }
    };
    function notYetImplemented(kernelName) {
      throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
    }
  
    // ../../../tfjs/tfjs-core/dist/util_base.js
    function shuffle(array) {
      let counter = array.length;
      let temp = 0;
      let index2 = 0;
      while (counter > 0) {
        index2 = Math.random() * counter | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index2];
        array[index2] = temp;
      }
    }
    function shuffleCombo(array, array2) {
      if (array.length !== array2.length) {
        throw new Error(`Array sizes must match to be shuffled together First array length was ${array.length}Second array length was ${array2.length}`);
      }
      let counter = array.length;
      let temp, temp2;
      let index2 = 0;
      while (counter > 0) {
        index2 = Math.random() * counter | 0;
        counter--;
        temp = array[counter];
        temp2 = array2[counter];
        array[counter] = array[index2];
        array2[counter] = array2[index2];
        array[index2] = temp;
        array2[index2] = temp2;
      }
    }
    function clamp(min2, x, max2) {
      return Math.max(min2, Math.min(x, max2));
    }
    function nearestLargerEven(val) {
      return val % 2 === 0 ? val : val + 1;
    }
    function sum(arr) {
      let sum4 = 0;
      for (let i = 0; i < arr.length; i++) {
        sum4 += arr[i];
      }
      return sum4;
    }
    function randUniform(a, b) {
      const r = Math.random();
      return b * r + (1 - r) * a;
    }
    function distSquared(a, b) {
      let result2 = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = Number(a[i]) - Number(b[i]);
        result2 += diff * diff;
      }
      return result2;
    }
    function assert(expr, msg) {
      if (!expr) {
        throw new Error(typeof msg === "string" ? msg : msg());
      }
    }
    function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
      assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
    function assertNonNull(a) {
      assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
    }
    function flatten(arr, result2 = [], skipTypedArray = false) {
      if (result2 == null) {
        result2 = [];
      }
      if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {
        for (let i = 0; i < arr.length; ++i) {
          flatten(arr[i], result2, skipTypedArray);
        }
      } else {
        result2.push(arr);
      }
      return result2;
    }
    function sizeFromShape(shape) {
      if (shape.length === 0) {
        return 1;
      }
      let size = shape[0];
      for (let i = 1; i < shape.length; i++) {
        size *= shape[i];
      }
      return size;
    }
    function isScalarShape(shape) {
      return shape.length === 0;
    }
    function arraysEqual(n1, n2) {
      if (n1 === n2) {
        return true;
      }
      if (n1 == null || n2 == null) {
        return false;
      }
      if (n1.length !== n2.length) {
        return false;
      }
      for (let i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
          return false;
        }
      }
      return true;
    }
    function isInt(a) {
      return a % 1 === 0;
    }
    function tanh(x) {
      if (Math.tanh != null) {
        return Math.tanh(x);
      }
      if (x === Infinity) {
        return 1;
      } else if (x === -Infinity) {
        return -1;
      } else {
        const e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
      }
    }
    function sizeToSquarishShape(size) {
      const width = Math.ceil(Math.sqrt(size));
      return [width, Math.ceil(size / width)];
    }
    function createShuffledIndices(n) {
      const shuffledIndices = new Uint32Array(n);
      for (let i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
      }
      shuffle(shuffledIndices);
      return shuffledIndices;
    }
    function rightPad(a, size) {
      if (size <= a.length) {
        return a;
      }
      return a + " ".repeat(size - a.length);
    }
    function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {
      return new Promise((resolve, reject) => {
        let tryCount = 0;
        const tryFn = () => {
          if (checkFn()) {
            resolve();
            return;
          }
          tryCount++;
          const nextBackoff = delayFn(tryCount);
          if (maxCounter != null && tryCount >= maxCounter) {
            reject();
            return;
          }
          setTimeout(tryFn, nextBackoff);
        };
        tryFn();
      });
    }
    function inferFromImplicitShape(shape, size) {
      let shapeProd = 1;
      let implicitIdx = -1;
      for (let i = 0; i < shape.length; ++i) {
        if (shape[i] >= 0) {
          shapeProd *= shape[i];
        } else if (shape[i] === -1) {
          if (implicitIdx !== -1) {
            throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
          }
          implicitIdx = i;
        } else if (shape[i] < 0) {
          throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
        }
      }
      if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
          throw Error(`Size(${size}) must match the product of shape ${shape}`);
        }
        return shape;
      }
      if (shapeProd === 0) {
        throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
      }
      if (size % shapeProd !== 0) {
        throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
      }
      const newShape = shape.slice();
      newShape[implicitIdx] = size / shapeProd;
      return newShape;
    }
    function parseAxisParam(axis, shape) {
      const rank = shape.length;
      axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
      assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
      assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
      return axis.map((a) => a < 0 ? rank + a : a);
    }
    function squeezeShape(shape, axis) {
      const newShape = [];
      const keptDims = [];
      const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
      const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
      let j = 0;
      for (let i = 0; i < shape.length; ++i) {
        if (axes != null) {
          if (axes[j] === i && shape[i] !== 1) {
            throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
          }
          if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
          }
          if (axes[j] <= i) {
            j++;
          }
        }
        if (shape[i] !== 1) {
          newShape.push(shape[i]);
          keptDims.push(i);
        }
      }
      return { newShape, keptDims };
    }
    function getTypedArrayFromDType(dtype, size) {
      let values = null;
      if (dtype == null || dtype === "float32") {
        values = new Float32Array(size);
      } else if (dtype === "int32") {
        values = new Int32Array(size);
      } else if (dtype === "bool") {
        values = new Uint8Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
      return values;
    }
    function getArrayFromDType(dtype, size) {
      let values = null;
      if (dtype == null || dtype === "float32") {
        values = new Float32Array(size);
      } else if (dtype === "int32") {
        values = new Int32Array(size);
      } else if (dtype === "bool") {
        values = new Uint8Array(size);
      } else if (dtype === "string") {
        values = new Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
      return values;
    }
    function checkConversionForErrors(vals, dtype) {
      for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
          throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
        }
      }
    }
    function isValidDtype(dtype) {
      return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
    }
    function hasEncodingLoss(oldType, newType) {
      if (newType === "complex64") {
        return false;
      }
      if (newType === "float32" && oldType !== "complex64") {
        return false;
      }
      if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
        return false;
      }
      if (newType === "bool" && oldType === "bool") {
        return false;
      }
      return true;
    }
    function isTypedArray(a) {
      return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;
    }
    function bytesPerElement(dtype) {
      if (dtype === "float32" || dtype === "int32") {
        return 4;
      } else if (dtype === "complex64") {
        return 8;
      } else if (dtype === "bool") {
        return 1;
      } else {
        throw new Error(`Unknown dtype ${dtype}`);
      }
    }
    function bytesFromStringArray(arr) {
      if (arr == null) {
        return 0;
      }
      let bytes = 0;
      arr.forEach((x) => bytes += x.length);
      return bytes;
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function inferDtype(values) {
      if (Array.isArray(values)) {
        return inferDtype(values[0]);
      }
      if (values instanceof Float32Array) {
        return "float32";
      } else if (values instanceof Int32Array || values instanceof Uint8Array) {
        return "int32";
      } else if (isNumber(values)) {
        return "float32";
      } else if (isString(values)) {
        return "string";
      } else if (isBoolean(values)) {
        return "bool";
      }
      return "float32";
    }
    function isFunction(f) {
      return !!(f && f.constructor && f.call && f.apply);
    }
    function nearestDivisor(size, start) {
      for (let i = start; i < size; ++i) {
        if (size % i === 0) {
          return i;
        }
      }
      return size;
    }
    function computeStrides(shape) {
      const rank = shape.length;
      if (rank < 2) {
        return [];
      }
      const strides = new Array(rank - 1);
      strides[rank - 2] = shape[rank - 1];
      for (let i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
      }
      return strides;
    }
    function createNestedArray(offset, shape, a, isComplex = false) {
      const ret = new Array();
      if (shape.length === 1) {
        const d = shape[0] * (isComplex ? 2 : 1);
        for (let i = 0; i < d; i++) {
          ret[i] = a[offset + i];
        }
      } else {
        const d = shape[0];
        const rest = shape.slice(1);
        const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
        for (let i = 0; i < d; i++) {
          ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);
        }
      }
      return ret;
    }
    function toNestedArray(shape, a, isComplex = false) {
      if (shape.length === 0) {
        return a[0];
      }
      const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
      if (size === 0) {
        return [];
      }
      if (size !== a.length) {
        throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? " for a complex tensor" : ""}.`);
      }
      return createNestedArray(0, shape, a, isComplex);
    }
    function makeOnesTypedArray(size, dtype) {
      const array = makeZerosTypedArray(size, dtype);
      for (let i = 0; i < array.length; i++) {
        array[i] = 1;
      }
      return array;
    }
    function makeZerosTypedArray(size, dtype) {
      if (dtype == null || dtype === "float32" || dtype === "complex64") {
        return new Float32Array(size);
      } else if (dtype === "int32") {
        return new Int32Array(size);
      } else if (dtype === "bool") {
        return new Uint8Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function makeZerosNestedTypedArray(shape, dtype) {
      const size = shape.reduce((prev, curr) => prev * curr, 1);
      if (dtype == null || dtype === "float32") {
        return toNestedArray(shape, new Float32Array(size));
      } else if (dtype === "int32") {
        return toNestedArray(shape, new Int32Array(size));
      } else if (dtype === "bool") {
        return toNestedArray(shape, new Uint8Array(size));
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function assertNonNegativeIntegerDimensions(shape) {
      shape.forEach((dimSize) => {
        assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
      });
    }
    function locToIndex(locs, rank, strides) {
      if (rank === 0) {
        return 0;
      } else if (rank === 1) {
        return locs[0];
      }
      let index2 = locs[locs.length - 1];
      for (let i = 0; i < locs.length - 1; ++i) {
        index2 += strides[i] * locs[i];
      }
      return index2;
    }
    function indexToLoc(index2, rank, strides) {
      if (rank === 0) {
        return [];
      } else if (rank === 1) {
        return [index2];
      }
      const locs = new Array(rank);
      for (let i = 0; i < locs.length - 1; ++i) {
        locs[i] = Math.floor(index2 / strides[i]);
        index2 -= locs[i] * strides[i];
      }
      locs[locs.length - 1] = index2;
      return locs;
    }
    function isPromise(object) {
      return object && object.then && typeof object.then === "function";
    }
  
    // ../../../tfjs/tfjs-core/dist/environment.js
    var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
    var Environment = class {
      constructor(global2) {
        this.global = global2;
        this.flags = {};
        this.flagRegistry = {};
        this.urlFlags = {};
        this.getQueryParams = getQueryParams;
        this.populateURLFlags();
      }
      setPlatform(platformName, platform) {
        if (this.platform != null) {
          console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`);
        }
        this.platformName = platformName;
        this.platform = platform;
      }
      registerFlag(flagName, evaluationFn, setHook) {
        this.flagRegistry[flagName] = { evaluationFn, setHook };
        if (this.urlFlags[flagName] != null) {
          const flagValue = this.urlFlags[flagName];
          console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
          this.set(flagName, flagValue);
        }
      }
      getAsync(flagName) {
        return __async(this, null, function* () {
          if (flagName in this.flags) {
            return this.flags[flagName];
          }
          this.flags[flagName] = yield this.evaluateFlag(flagName);
          return this.flags[flagName];
        });
      }
      get(flagName) {
        if (flagName in this.flags) {
          return this.flags[flagName];
        }
        const flagValue = this.evaluateFlag(flagName);
        if (isPromise(flagValue)) {
          throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
        }
        this.flags[flagName] = flagValue;
        return this.flags[flagName];
      }
      getNumber(flagName) {
        return this.get(flagName);
      }
      getBool(flagName) {
        return this.get(flagName);
      }
      getFlags() {
        return this.flags;
      }
      get features() {
        return this.flags;
      }
      set(flagName, value) {
        if (this.flagRegistry[flagName] == null) {
          throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
        }
        this.flags[flagName] = value;
        if (this.flagRegistry[flagName].setHook != null) {
          this.flagRegistry[flagName].setHook(value);
        }
      }
      evaluateFlag(flagName) {
        if (this.flagRegistry[flagName] == null) {
          throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
        }
        return this.flagRegistry[flagName].evaluationFn();
      }
      setFlags(flags) {
        this.flags = Object.assign({}, flags);
      }
      reset() {
        this.flags = {};
        this.urlFlags = {};
        this.populateURLFlags();
      }
      populateURLFlags() {
        if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
          return;
        }
        const urlParams = this.getQueryParams(this.global.location.search);
        if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
          const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
          keyValues.forEach((keyValue) => {
            const [key, value] = keyValue.split(":");
            this.urlFlags[key] = parseValue(key, value);
          });
        }
      }
    };
    function getQueryParams(queryString) {
      const params = {};
      queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
        decodeParam(params, t[0], t[1]);
        return t.join("=");
      });
      return params;
    }
    function decodeParam(params, name, value) {
      params[decodeURIComponent(name)] = decodeURIComponent(value || "");
    }
    function parseValue(flagName, value) {
      value = value.toLowerCase();
      if (value === "true" || value === "false") {
        return value === "true";
      } else if (`${+value}` === value) {
        return +value;
      }
      throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
    }
    function env() {
      return ENV;
    }
    var ENV = null;
    function setEnvironmentGlobal(environment) {
      ENV = environment;
    }
  
    // ../../../tfjs/tfjs-core/dist/global_util.js
    var globalNameSpace;
    function getGlobalNamespace() {
      if (globalNameSpace == null) {
        let ns;
        if (typeof window !== "undefined") {
          ns = window;
        } else if (typeof global !== "undefined") {
          ns = global;
        } else if (typeof process !== "undefined") {
          ns = process;
        } else if (typeof self !== "undefined") {
          ns = self;
        } else {
          throw new Error("Could not find a global object");
        }
        globalNameSpace = ns;
      }
      return globalNameSpace;
    }
    function getGlobalMap() {
      const ns = getGlobalNamespace();
      if (ns._tfGlobals == null) {
        ns._tfGlobals = new Map();
      }
      return ns._tfGlobals;
    }
    function getGlobal(key, init) {
      const globalMap = getGlobalMap();
      if (globalMap.has(key)) {
        return globalMap.get(key);
      } else {
        const singleton = init();
        globalMap.set(key, singleton);
        return globalMap.get(key);
      }
    }
  
    // ../../../tfjs/tfjs-core/dist/kernel_names.js
    var Abs = "Abs";
    var Acos = "Acos";
    var Acosh = "Acosh";
    var Add = "Add";
    var AddN = "AddN";
    var All = "All";
    var Any = "Any";
    var ArgMax = "ArgMax";
    var ArgMin = "ArgMin";
    var Asin = "Asin";
    var Asinh = "Asinh";
    var Atan = "Atan";
    var Atanh = "Atanh";
    var Atan2 = "Atan2";
    var AvgPool = "AvgPool";
    var AvgPoolGrad = "AvgPoolGrad";
    var AvgPool3D = "AvgPool3D";
    var AvgPool3DGrad = "AvgPool3DGrad";
    var BatchMatMul = "BatchMatMul";
    var BatchToSpaceND = "BatchToSpaceND";
    var Bincount = "Bincount";
    var Cast = "Cast";
    var Ceil = "Ceil";
    var ClipByValue = "ClipByValue";
    var Complex = "Complex";
    var ComplexAbs = "ComplexAbs";
    var Concat = "Concat";
    var Conv2D = "Conv2D";
    var Conv2DBackpropFilter = "Conv2DBackpropFilter";
    var Conv2DBackpropInput = "Conv2DBackpropInput";
    var Conv3D = "Conv3D";
    var Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
    var Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
    var Cos = "Cos";
    var Cosh = "Cosh";
    var Cumsum = "Cumsum";
    var CropAndResize = "CropAndResize";
    var DenseBincount = "DenseBincount";
    var DepthToSpace = "DepthToSpace";
    var DepthwiseConv2dNative = "DepthwiseConv2dNative";
    var DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
    var DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
    var Diag = "Diag";
    var Dilation2D = "Dilation2D";
    var RealDiv = "RealDiv";
    var Einsum = "Einsum";
    var Elu = "Elu";
    var EluGrad = "EluGrad";
    var Erf = "Erf";
    var Equal = "Equal";
    var Exp = "Exp";
    var ExpandDims = "ExpandDims";
    var Expm1 = "Expm1";
    var FFT = "FFT";
    var Fill = "Fill";
    var FlipLeftRight = "FlipLeftRight";
    var Floor = "Floor";
    var FloorDiv = "FloorDiv";
    var FusedBatchNorm = "FusedBatchNorm";
    var GatherV2 = "GatherV2";
    var GatherNd = "GatherNd";
    var Greater = "Greater";
    var GreaterEqual = "GreaterEqual";
    var Identity = "Identity";
    var IFFT = "IFFT";
    var Imag = "Imag";
    var IsFinite = "IsFinite";
    var IsInf = "IsInf";
    var IsNan = "IsNan";
    var LeakyRelu = "LeakyRelu";
    var Less = "Less";
    var LessEqual = "LessEqual";
    var LinSpace = "LinSpace";
    var Log = "Log";
    var Log1p = "Log1p";
    var LogicalAnd = "LogicalAnd";
    var LogicalNot = "LogicalNot";
    var LogicalOr = "LogicalOr";
    var LRN = "LRN";
    var LRNGrad = "LRNGrad";
    var Max = "Max";
    var Maximum = "Maximum";
    var MaxPool = "MaxPool";
    var MaxPoolGrad = "MaxPoolGrad";
    var MaxPool3D = "MaxPool3D";
    var MaxPool3DGrad = "MaxPool3DGrad";
    var MaxPoolWithArgmax = "MaxPoolWithArgmax";
    var Mean = "Mean";
    var Min = "Min";
    var Minimum = "Minimum";
    var MirrorPad = "MirrorPad";
    var Mod = "Mod";
    var Multinomial = "Multinomial";
    var Multiply = "Multiply";
    var Neg = "Neg";
    var NotEqual = "NotEqual";
    var NonMaxSuppressionV3 = "NonMaxSuppressionV3";
    var NonMaxSuppressionV4 = "NonMaxSuppressionV4";
    var NonMaxSuppressionV5 = "NonMaxSuppressionV5";
    var OnesLike = "OnesLike";
    var OneHot = "OneHot";
    var Pack = "Pack";
    var PadV2 = "PadV2";
    var Pow = "Pow";
    var Prelu = "Prelu";
    var Prod = "Prod";
    var Range = "Range";
    var Real = "Real";
    var Reciprocal = "Reciprocal";
    var Relu = "Relu";
    var Reshape = "Reshape";
    var ResizeNearestNeighbor = "ResizeNearestNeighbor";
    var ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
    var ResizeBilinear = "ResizeBilinear";
    var ResizeBilinearGrad = "ResizeBilinearGrad";
    var Relu6 = "Relu6";
    var Reverse = "Reverse";
    var Round = "Round";
    var Rsqrt = "Rsqrt";
    var ScatterNd = "ScatterNd";
    var Select = "Select";
    var Selu = "Selu";
    var Slice = "Slice";
    var Sin = "Sin";
    var Sinh = "Sinh";
    var Sign = "Sign";
    var Sigmoid = "Sigmoid";
    var Softplus = "Softplus";
    var Sqrt = "Sqrt";
    var Sum = "Sum";
    var SpaceToBatchND = "SpaceToBatchND";
    var SplitV = "SplitV";
    var Softmax = "Softmax";
    var SparseFillEmptyRows = "SparseFillEmptyRows";
    var SparseReshape = "SparseReshape";
    var SparseSegmentMean = "SparseSegmentMean";
    var SparseSegmentSum = "SparseSegmentSum";
    var SparseToDense = "SparseToDense";
    var SquaredDifference = "SquaredDifference";
    var Square = "Square";
    var StridedSlice = "StridedSlice";
    var StringNGrams = "StringNGrams";
    var StringSplit = "StringSplit";
    var StringToHashBucketFast = "StringToHashBucketFast";
    var Sub = "Sub";
    var Tan = "Tan";
    var Tanh = "Tanh";
    var Tile = "Tile";
    var TopK = "TopK";
    var Transform = "Transform";
    var Transpose = "Transpose";
    var Unique = "Unique";
    var Unpack = "Unpack";
    var UnsortedSegmentSum = "UnsortedSegmentSum";
    var ZerosLike = "ZerosLike";
    var Step = "Step";
    var FromPixels = "FromPixels";
    var RotateWithOffset = "RotateWithOffset";
    var _FusedMatMul = "_FusedMatMul";
    var FusedConv2D = "FusedConv2D";
    var FusedDepthwiseConv2D = "FusedDepthwiseConv2D";
  
    // ../../../tfjs/tfjs-core/dist/kernel_registry.js
    var kernelRegistry = getGlobal("kernelRegistry", () => new Map());
    var gradRegistry = getGlobal("gradRegistry", () => new Map());
    function getKernel(kernelName, backendName) {
      const key = makeKey(kernelName, backendName);
      return kernelRegistry.get(key);
    }
    function getGradient(kernelName) {
      return gradRegistry.get(kernelName);
    }
    function getKernelsForBackend(backendName) {
      const it = kernelRegistry.entries();
      const result2 = [];
      while (true) {
        const { done, value } = it.next();
        if (done) {
          break;
        }
        const [key, config] = value;
        const [backend] = key.split("_");
        if (backend === backendName) {
          result2.push(config);
        }
      }
      return result2;
    }
    function registerKernel(config) {
      const { kernelName, backendName } = config;
      const key = makeKey(kernelName, backendName);
      if (kernelRegistry.has(key)) {
        console.warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
      }
      kernelRegistry.set(key, config);
    }
    function makeKey(kernelName, backendName) {
      return `${backendName}_${kernelName}`;
    }
  
    // ../../../tfjs/tfjs-core/dist/util.js
    var util_exports = {};
    __export(util_exports, {
      arraysEqual: () => arraysEqual,
      assert: () => assert,
      assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
      assertNonNull: () => assertNonNull,
      assertShapesMatch: () => assertShapesMatch,
      bytesFromStringArray: () => bytesFromStringArray,
      bytesPerElement: () => bytesPerElement,
      checkConversionForErrors: () => checkConversionForErrors,
      clamp: () => clamp,
      computeStrides: () => computeStrides,
      createScalarValue: () => createScalarValue,
      createShuffledIndices: () => createShuffledIndices,
      decodeString: () => decodeString,
      distSquared: () => distSquared,
      encodeString: () => encodeString,
      fetch: () => fetch3,
      fingerPrint64: () => fingerPrint64,
      flatten: () => flatten,
      getArrayFromDType: () => getArrayFromDType,
      getTypedArrayFromDType: () => getTypedArrayFromDType,
      hasEncodingLoss: () => hasEncodingLoss,
      hexToLong: () => hexToLong,
      indexToLoc: () => indexToLoc,
      inferDtype: () => inferDtype,
      inferFromImplicitShape: () => inferFromImplicitShape,
      isBoolean: () => isBoolean,
      isFunction: () => isFunction,
      isInt: () => isInt,
      isNumber: () => isNumber,
      isPromise: () => isPromise,
      isScalarShape: () => isScalarShape,
      isString: () => isString,
      isTypedArray: () => isTypedArray,
      isValidDtype: () => isValidDtype,
      locToIndex: () => locToIndex,
      makeOnesTypedArray: () => makeOnesTypedArray,
      makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
      makeZerosTypedArray: () => makeZerosTypedArray,
      nearestDivisor: () => nearestDivisor,
      nearestLargerEven: () => nearestLargerEven,
      now: () => now,
      parseAxisParam: () => parseAxisParam,
      randUniform: () => randUniform,
      repeatedTry: () => repeatedTry,
      rightPad: () => rightPad,
      shuffle: () => shuffle,
      shuffleCombo: () => shuffleCombo,
      sizeFromShape: () => sizeFromShape,
      sizeToSquarishShape: () => sizeToSquarishShape,
      squeezeShape: () => squeezeShape,
      sum: () => sum,
      tanh: () => tanh,
      toNestedArray: () => toNestedArray,
      toTypedArray: () => toTypedArray
    });
  
    // ../../../tfjs/tfjs-core/dist/hash_util.js
    var LongExports = __toModule(require_long());
    var Long = LongExports.default || LongExports;
    function hexToLong(hex) {
      return Long.fromString(hex, true, 16);
    }
    var k0 = hexToLong("c3a5c85c97cb3127");
    var k1 = hexToLong("b492b66fbe98f273");
    var k2 = hexToLong("9ae16a3b2f90404f");
    function shiftMix(val) {
      return val.xor(val.shru(47));
    }
    function fetch2(s, offset, numBytes) {
      const bytes = s.slice(offset, offset + numBytes);
      return Long.fromBytes(Array.from(bytes), true, true);
    }
    function fetch64(s, offset) {
      return fetch2(s, offset, 8);
    }
    function fetch32(s, offset) {
      return fetch2(s, offset, 4);
    }
    function rotate64(val, shift) {
      return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
    }
    function hashLen16(u, v, mul3 = hexToLong("9ddfea08eb382d69")) {
      let a = u.xor(v).mul(mul3);
      a = a.xor(a.shru(47));
      let b = v.xor(a).mul(mul3);
      b = b.xor(b.shru(47));
      b = b.mul(mul3);
      return b;
    }
    function weakHashLen32WithSeeds(w, x, y, z, a, b) {
      a = a.add(w);
      b = rotate64(b.add(a).add(z), 21);
      const c = a;
      a = a.add(x);
      a = a.add(y);
      b = b.add(rotate64(a, 44));
      return [a.add(z), b.add(c)];
    }
    function weakHashLen32WithSeedsStr(s, offset, a, b) {
      return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);
    }
    function hashLen0to16(s, len = s.length) {
      if (len >= 8) {
        const mul3 = k2.add(len * 2);
        const a = fetch64(s, 0).add(k2);
        const b = fetch64(s, len - 8);
        const c = rotate64(b, 37).mul(mul3).add(a);
        const d = rotate64(a, 25).add(b).mul(mul3);
        return hashLen16(c, d, mul3);
      }
      if (len >= 4) {
        const mul3 = k2.add(len * 2);
        const a = fetch32(s, 0);
        return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul3);
      }
      if (len > 0) {
        const a = s[0];
        const b = s[len >> 1];
        const c = s[len - 1];
        const y = a + (b << 8);
        const z = len + (c << 2);
        return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);
      }
      return k2;
    }
    function hashLen17to32(s, len = s.length) {
      const mul3 = k2.add(len * 2);
      const a = fetch64(s, 0).mul(k1);
      const b = fetch64(s, 8);
      const c = fetch64(s, len - 8).mul(mul3);
      const d = fetch64(s, len - 16).mul(k2);
      return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul3);
    }
    function hashLen33to64(s, len = s.length) {
      const mul3 = k2.add(len * 2);
      const a = fetch64(s, 0).mul(k2);
      const b = fetch64(s, 8);
      const c = fetch64(s, len - 8).mul(mul3);
      const d = fetch64(s, len - 16).mul(k2);
      const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);
      const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul3);
      const e = fetch64(s, 16).mul(mul3);
      const f = fetch64(s, 24);
      const g = y.add(fetch64(s, len - 32)).mul(mul3);
      const h = z.add(fetch64(s, len - 24)).mul(mul3);
      return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul3);
    }
    function fingerPrint64(s, len = s.length) {
      const seed = Long.fromNumber(81, true);
      if (len <= 32) {
        if (len <= 16) {
          return hashLen0to16(s, len);
        } else {
          return hashLen17to32(s, len);
        }
      } else if (len <= 64) {
        return hashLen33to64(s, len);
      }
      let x = seed;
      let y = seed.mul(k1).add(113);
      let z = shiftMix(y.mul(k2).add(113)).mul(k2);
      let v = [Long.UZERO, Long.UZERO];
      let w = [Long.UZERO, Long.UZERO];
      x = x.mul(k2).add(fetch64(s, 0));
      let offset = 0;
      const end = (len - 1 >> 6) * 64;
      const last64 = end + (len - 1 & 63) - 63;
      do {
        x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);
        y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);
        x = x.xor(w[1]);
        y = y.add(v[0]).add(fetch64(s, offset + 40));
        z = rotate64(z.add(w[0]), 33).mul(k1);
        v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));
        w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
        [z, x] = [x, z];
        offset += 64;
      } while (offset !== end);
      const mul3 = k1.add(z.and(255).shl(1));
      offset = last64;
      w[0] = w[0].add(len - 1 & 63);
      v[0] = v[0].add(w[0]);
      w[0] = w[0].add(v[0]);
      x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul3);
      y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul3);
      x = x.xor(w[1].mul(9));
      y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));
      z = rotate64(z.add(w[0]), 33).mul(mul3);
      v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul3), x.add(w[0]));
      w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
      [z, x] = [x, z];
      return hashLen16(hashLen16(v[0], w[0], mul3).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul3).add(x), mul3);
    }
  
    // ../../../tfjs/tfjs-core/dist/util.js
    function createScalarValue(value, dtype) {
      if (dtype === "string") {
        return encodeString(value);
      }
      return toTypedArray([value], dtype);
    }
    function noConversionNeeded(a, dtype) {
      return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
    }
    function toTypedArray(a, dtype) {
      if (dtype === "string") {
        throw new Error("Cannot convert a string[] to a TypedArray");
      }
      if (Array.isArray(a)) {
        a = flatten(a);
      }
      if (env().getBool("DEBUG")) {
        checkConversionForErrors(a, dtype);
      }
      if (noConversionNeeded(a, dtype)) {
        return a;
      }
      if (dtype == null || dtype === "float32" || dtype === "complex64") {
        return new Float32Array(a);
      } else if (dtype === "int32") {
        return new Int32Array(a);
      } else if (dtype === "bool") {
        const bool = new Uint8Array(a.length);
        for (let i = 0; i < bool.length; ++i) {
          if (Math.round(a[i]) !== 0) {
            bool[i] = 1;
          }
        }
        return bool;
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function now() {
      return env().platform.now();
    }
    function fetch3(path, requestInits) {
      return env().platform.fetch(path, requestInits);
    }
    function encodeString(s, encoding = "utf-8") {
      encoding = encoding || "utf-8";
      return env().platform.encode(s, encoding);
    }
    function decodeString(bytes, encoding = "utf-8") {
      encoding = encoding || "utf-8";
      return env().platform.decode(bytes, encoding);
    }
  
    // ../../../tfjs/tfjs-core/dist/profiler.js
    var Profiler = class {
      constructor(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
          this.logger = new Logger();
        }
      }
      profileKernel(kernelName, inputs, f) {
        let outputs;
        const holdResultWrapperFn = () => {
          outputs = f();
        };
        let timer;
        const start = now();
        if (this.backendTimer.timerAvailable()) {
          timer = this.backendTimer.time(holdResultWrapperFn);
        } else {
          holdResultWrapperFn();
          for (const output of outputs) {
            output.dataSync();
          }
          timer = Promise.resolve({ kernelMs: now() - start });
        }
        if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
          for (let i = 0; i < outputs.length; i++) {
            const output = outputs[i];
            output.data().then((tensorVals) => {
              checkComputationForErrors(tensorVals, output.dtype, kernelName);
            });
          }
        }
        const kernelProfile = {
          kernelName,
          outputs,
          inputs,
          timeMs: timer.then((timing) => timing.kernelMs),
          extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
        };
        return kernelProfile;
      }
      logKernelProfile(kernelProfile) {
        const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
        outputs.forEach((result2) => {
          Promise.all([result2.data(), timeMs, extraInfo]).then((valueContainer) => {
            this.logger.logKernelProfile(kernelName, result2, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
          });
        });
      }
    };
    function checkComputationForErrors(vals, dtype, kernelName) {
      if (dtype !== "float32") {
        return false;
      }
      for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
          console.warn(`Found ${num} in the result of '${kernelName}'`);
          return true;
        }
      }
      return false;
    }
    var Logger = class {
      logKernelProfile(name, result2, vals, timeMs, inputs, extraInfo) {
        const time = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
        const paddedName = rightPad(name, 25);
        const rank = result2.rank;
        const size = result2.size;
        const shape = rightPad(result2.shape.toString(), 14);
        let inputShapesDescription = "";
        for (const name2 in inputs) {
          const input = inputs[name2];
          if (input != null) {
            const inputShape = input.shape || result2.shape;
            const inputRank = inputShape.length;
            inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
          }
        }
        console.log(`%c${paddedName}	%c${time}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
      }
    };
  
    // ../../../tfjs/tfjs-core/dist/tape.js
    function getFilteredNodesXToY(tape, xs, y) {
      const tensorsFromX = {};
      const nodesFromX = {};
      for (let i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
      }
      for (let i = 0; i < tape.length; i++) {
        const node = tape[i];
        const nodeInputs = node.inputs;
        for (const inputName in nodeInputs) {
          const input = nodeInputs[inputName];
          let anyInputFromX = false;
          for (let j = 0; j < xs.length; j++) {
            if (tensorsFromX[input.id]) {
              node.outputs.forEach((output) => tensorsFromX[output.id] = true);
              anyInputFromX = true;
              nodesFromX[node.id] = true;
              break;
            }
          }
          if (anyInputFromX) {
            break;
          }
        }
      }
      const tensorsLeadToY = {};
      tensorsLeadToY[y.id] = true;
      const nodesToY = {};
      for (let i = tape.length - 1; i >= 0; i--) {
        const node = tape[i];
        const nodeInputs = node.inputs;
        for (let j = 0; j < node.outputs.length; j++) {
          if (tensorsLeadToY[node.outputs[j].id]) {
            for (const inputName in nodeInputs) {
              tensorsLeadToY[nodeInputs[inputName].id] = true;
              nodesToY[node.id] = true;
            }
            break;
          }
        }
      }
      const filteredTape = [];
      for (let i = 0; i < tape.length; i++) {
        const node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
          const prunedInputs = {};
          for (const inputName in node.inputs) {
            const nodeInput = node.inputs[inputName];
            if (tensorsFromX[nodeInput.id]) {
              prunedInputs[inputName] = nodeInput;
            }
          }
          const prunedNode = Object.assign({}, node);
          prunedNode.inputs = prunedInputs;
          prunedNode.outputs = node.outputs;
          filteredTape.push(prunedNode);
        }
      }
      return filteredTape;
    }
    function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy3, add5) {
      for (let i = filteredTape.length - 1; i >= 0; i--) {
        const node = filteredTape[i];
        const dys = [];
        node.outputs.forEach((o) => {
          const gradTensor = tensorAccumulatedGradientMap[o.id];
          if (gradTensor != null) {
            dys.push(gradTensor);
          } else {
            dys.push(null);
          }
        });
        if (node.gradient == null) {
          throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
        }
        const inputGradients = node.gradient(dys);
        for (const inputName in node.inputs) {
          if (!(inputName in inputGradients)) {
            throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
          }
          const dx = tidy3(() => inputGradients[inputName]());
          if (dx.dtype !== "float32") {
            throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
          }
          const x = node.inputs[inputName];
          if (!arraysEqual(dx.shape, x.shape)) {
            throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
          }
          if (tensorAccumulatedGradientMap[x.id] == null) {
            tensorAccumulatedGradientMap[x.id] = dx;
          } else {
            const curGradient = tensorAccumulatedGradientMap[x.id];
            tensorAccumulatedGradientMap[x.id] = add5(curGradient, dx);
            curGradient.dispose();
          }
        }
      }
    }
  
    // ../../../tfjs/tfjs-core/dist/tensor_format.js
    var FORMAT_LIMIT_NUM_VALS = 20;
    var FORMAT_NUM_FIRST_LAST_VALS = 3;
    var FORMAT_NUM_SIG_DIGITS = 7;
    function tensorToString(vals, shape, dtype, verbose) {
      const strides = computeStrides(shape);
      const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
      const rank = shape.length;
      const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
      const lines = ["Tensor"];
      if (verbose) {
        lines.push(`  dtype: ${dtype}`);
        lines.push(`  rank: ${rank}`);
        lines.push(`  shape: [${shape}]`);
        lines.push(`  values:`);
      }
      lines.push(valsLines.map((l) => "    " + l).join("\n"));
      return lines.join("\n");
    }
    function computeMaxSizePerColumn(vals, shape, dtype, strides) {
      const n = sizeFromShape(shape);
      const numCols = strides[strides.length - 1];
      const padPerCol = new Array(numCols).fill(0);
      const rank = shape.length;
      const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
      if (rank > 1) {
        for (let row = 0; row < n / numCols; row++) {
          const offset = row * numCols;
          for (let j = 0; j < numCols; j++) {
            padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
          }
        }
      }
      return padPerCol;
    }
    function valToString(val, pad, dtype) {
      let valStr;
      if (Array.isArray(val)) {
        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
      } else if (isString(val)) {
        valStr = `'${val}'`;
      } else if (dtype === "bool") {
        valStr = boolNumToString(val);
      } else {
        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
      }
      return rightPad(valStr, pad);
    }
    function boolNumToString(v) {
      return v === 0 ? "false" : "true";
    }
    function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
      const storagePerElement = dtype === "complex64" ? 2 : 1;
      const size = shape[0];
      const rank = shape.length;
      if (rank === 0) {
        if (dtype === "complex64") {
          const complexTuple = createComplexTuples(vals);
          return [valToString(complexTuple[0], 0, dtype)];
        }
        if (dtype === "bool") {
          return [boolNumToString(vals[0])];
        }
        return [vals[0].toString()];
      }
      if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
          const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
          let firstVals = Array.from(vals.slice(0, firstValsSize));
          let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
          if (dtype === "complex64") {
            firstVals = createComplexTuples(firstVals);
            lastVals = createComplexTuples(lastVals);
          }
          return [
            "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
          ];
        }
        const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
        return [
          "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
        ];
      }
      const subshape = shape.slice(1);
      const substrides = strides.slice(1);
      const stride = strides[0] * storagePerElement;
      const lines = [];
      if (size > FORMAT_LIMIT_NUM_VALS) {
        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
        }
        lines.push("...");
        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
      } else {
        for (let i = 0; i < size; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
      }
      const sep = rank === 2 ? "," : "";
      lines[0] = "[" + lines[0] + sep;
      for (let i = 1; i < lines.length - 1; i++) {
        lines[i] = " " + lines[i] + sep;
      }
      let newLineSep = ",\n";
      for (let i = 2; i < rank; i++) {
        newLineSep += "\n";
      }
      lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
      return lines;
    }
    function createComplexTuples(vals) {
      const complexTuples = [];
      for (let i = 0; i < vals.length; i += 2) {
        complexTuples.push([vals[i], vals[i + 1]]);
      }
      return complexTuples;
    }
  
    // ../../../tfjs/tfjs-core/dist/tensor.js
    var TensorBuffer = class {
      constructor(shape, dtype, values) {
        this.dtype = dtype;
        this.shape = shape.slice();
        this.size = sizeFromShape(shape);
        if (values != null) {
          const n = values.length;
          assert(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
        }
        if (dtype === "complex64") {
          throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
        }
        this.values = values || getArrayFromDType(dtype, this.size);
        this.strides = computeStrides(shape);
      }
      set(value, ...locs) {
        if (locs.length === 0) {
          locs = [0];
        }
        assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
        const index2 = this.locToIndex(locs);
        this.values[index2] = value;
      }
      get(...locs) {
        if (locs.length === 0) {
          locs = [0];
        }
        let i = 0;
        for (const loc of locs) {
          if (loc < 0 || loc >= this.shape[i]) {
            const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
            throw new Error(msg);
          }
          i++;
        }
        let index2 = locs[locs.length - 1];
        for (let i2 = 0; i2 < locs.length - 1; ++i2) {
          index2 += this.strides[i2] * locs[i2];
        }
        return this.values[index2];
      }
      locToIndex(locs) {
        if (this.rank === 0) {
          return 0;
        } else if (this.rank === 1) {
          return locs[0];
        }
        let index2 = locs[locs.length - 1];
        for (let i = 0; i < locs.length - 1; ++i) {
          index2 += this.strides[i] * locs[i];
        }
        return index2;
      }
      indexToLoc(index2) {
        if (this.rank === 0) {
          return [];
        } else if (this.rank === 1) {
          return [index2];
        }
        const locs = new Array(this.shape.length);
        for (let i = 0; i < locs.length - 1; ++i) {
          locs[i] = Math.floor(index2 / this.strides[i]);
          index2 -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index2;
        return locs;
      }
      get rank() {
        return this.shape.length;
      }
      toTensor() {
        return trackerFn().makeTensor(this.values, this.shape, this.dtype);
      }
    };
    var trackerFn = null;
    var opHandler = null;
    var deprecationWarningFn = null;
    function setTensorTracker(fn) {
      trackerFn = fn;
    }
    function setOpHandler(handler) {
      opHandler = handler;
    }
    function setDeprecationWarningFn(fn) {
      deprecationWarningFn = fn;
    }
    var Tensor = class {
      constructor(shape, dtype, dataId, id) {
        this.kept = false;
        this.isDisposedInternal = false;
        this.shape = shape.slice();
        this.dtype = dtype || "float32";
        this.size = sizeFromShape(shape);
        this.strides = computeStrides(shape);
        this.dataId = dataId;
        this.id = id;
        this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
      }
      get rank() {
        return this.shape.length;
      }
      buffer() {
        return __async(this, null, function* () {
          const vals = yield this.data();
          return opHandler.buffer(this.shape, this.dtype, vals);
        });
      }
      bufferSync() {
        return opHandler.buffer(this.shape, this.dtype, this.dataSync());
      }
      array() {
        return __async(this, null, function* () {
          const vals = yield this.data();
          return toNestedArray(this.shape, vals, this.dtype === "complex64");
        });
      }
      arraySync() {
        return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
      }
      data() {
        return __async(this, null, function* () {
          this.throwIfDisposed();
          const data = trackerFn().read(this.dataId);
          if (this.dtype === "string") {
            const bytes = yield data;
            try {
              return bytes.map((b) => decodeString(b));
            } catch (_a) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
          }
          return data;
        });
      }
      dataSync() {
        this.throwIfDisposed();
        const data = trackerFn().readSync(this.dataId);
        if (this.dtype === "string") {
          try {
            return data.map((b) => decodeString(b));
          } catch (_a) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
          }
        }
        return data;
      }
      bytes() {
        return __async(this, null, function* () {
          this.throwIfDisposed();
          const data = yield trackerFn().read(this.dataId);
          if (this.dtype === "string") {
            return data;
          } else {
            return new Uint8Array(data.buffer);
          }
        });
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        trackerFn().disposeTensor(this);
        this.isDisposedInternal = true;
      }
      get isDisposed() {
        return this.isDisposedInternal;
      }
      throwIfDisposed() {
        if (this.isDisposed) {
          throw new Error(`Tensor is disposed.`);
        }
      }
      print(verbose = false) {
        return opHandler.print(this, verbose);
      }
      clone() {
        this.throwIfDisposed();
        return opHandler.clone(this);
      }
      toString(verbose = false) {
        const vals = this.dataSync();
        return tensorToString(vals, this.shape, this.dtype, verbose);
      }
      cast(dtype) {
        this.throwIfDisposed();
        return opHandler.cast(this, dtype);
      }
      variable(trainable = true, name, dtype) {
        this.throwIfDisposed();
        return trackerFn().makeVariable(this, trainable, name, dtype);
      }
    };
    Object.defineProperty(Tensor, Symbol.hasInstance, {
      value: (instance) => {
        return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
      }
    });
    function getGlobalTensorClass() {
      return getGlobal("Tensor", () => {
        return Tensor;
      });
    }
    getGlobalTensorClass();
    var Variable = class extends Tensor {
      constructor(initialValue, trainable, name, tensorId) {
        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
        this.trainable = trainable;
        this.name = name;
      }
      assign(newValue) {
        if (newValue.dtype !== this.dtype) {
          throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
        }
        if (!arraysEqual(newValue.shape, this.shape)) {
          throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
        }
        trackerFn().disposeTensor(this);
        this.dataId = newValue.dataId;
        trackerFn().incRef(this, null);
      }
      dispose() {
        trackerFn().disposeVariable(this);
        this.isDisposedInternal = true;
      }
    };
    Object.defineProperty(Variable, Symbol.hasInstance, {
      value: (instance) => {
        return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
      }
    });
  
    // ../../../tfjs/tfjs-core/dist/types.js
    var Rank;
    (function(Rank2) {
      Rank2["R0"] = "R0";
      Rank2["R1"] = "R1";
      Rank2["R2"] = "R2";
      Rank2["R3"] = "R3";
      Rank2["R4"] = "R4";
      Rank2["R5"] = "R5";
      Rank2["R6"] = "R6";
    })(Rank || (Rank = {}));
    var UpcastInt32AndMap;
    (function(UpcastInt32AndMap2) {
      UpcastInt32AndMap2["float32"] = "float32";
      UpcastInt32AndMap2["int32"] = "int32";
      UpcastInt32AndMap2["bool"] = "int32";
      UpcastInt32AndMap2["complex64"] = "complex64";
    })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
    var UpcastBoolAndMap;
    (function(UpcastBoolAndMap2) {
      UpcastBoolAndMap2["float32"] = "float32";
      UpcastBoolAndMap2["int32"] = "int32";
      UpcastBoolAndMap2["bool"] = "bool";
      UpcastBoolAndMap2["complex64"] = "complex64";
    })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
    var UpcastFloat32AndMap;
    (function(UpcastFloat32AndMap2) {
      UpcastFloat32AndMap2["float32"] = "float32";
      UpcastFloat32AndMap2["int32"] = "float32";
      UpcastFloat32AndMap2["bool"] = "float32";
      UpcastFloat32AndMap2["complex64"] = "complex64";
    })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
    var UpcastComplex64AndMap;
    (function(UpcastComplex64AndMap2) {
      UpcastComplex64AndMap2["float32"] = "complex64";
      UpcastComplex64AndMap2["int32"] = "complex64";
      UpcastComplex64AndMap2["bool"] = "complex64";
      UpcastComplex64AndMap2["complex64"] = "complex64";
    })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
    var upcastTypeMap = {
      "float32": UpcastFloat32AndMap,
      "int32": UpcastInt32AndMap,
      "bool": UpcastBoolAndMap,
      "complex64": UpcastComplex64AndMap
    };
    function upcastType(typeA, typeB) {
      if (typeA === "string" || typeB === "string") {
        if (typeA === "string" && typeB === "string") {
          return "string";
        }
        throw new Error(`Can not upcast ${typeA} with ${typeB}`);
      }
      return upcastTypeMap[typeA][typeB];
    }
    function sumOutType(type) {
      return upcastType(type, "int32");
    }
  
    // ../../../tfjs/tfjs-core/dist/tensor_util.js
    function makeTypesMatch(a, b) {
      if (a.dtype === b.dtype) {
        return [a, b];
      }
      const dtype = upcastType(a.dtype, b.dtype);
      return [a.cast(dtype), b.cast(dtype)];
    }
    function getTensorsInContainer(result2) {
      const list = [];
      const seen = new Set();
      walkTensorContainer(result2, list, seen);
      return list;
    }
    function walkTensorContainer(container, list, seen) {
      if (container == null) {
        return;
      }
      if (container instanceof Tensor) {
        list.push(container);
        return;
      }
      if (!isIterable(container)) {
        return;
      }
      const iterable = container;
      for (const k in iterable) {
        const val = iterable[k];
        if (!seen.has(val)) {
          seen.add(val);
          walkTensorContainer(val, list, seen);
        }
      }
    }
    function isIterable(obj) {
      return Array.isArray(obj) || typeof obj === "object";
    }
  
    // ../../../tfjs/tfjs-core/dist/engine.js
    function isRegisteredKernelInvocation(kernelInvocation) {
      return kernelInvocation.kernelName != null;
    }
    var EngineState = class {
      constructor() {
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numStringTensors = 0;
        this.numDataBuffers = 0;
        this.gradientDepth = 0;
        this.kernelDepth = 0;
        this.scopeStack = [];
        this.numDataMovesStack = [];
        this.nextScopeId = 0;
        this.tensorInfo = new WeakMap();
        this.profiling = false;
        this.activeProfile = {
          newBytes: 0,
          newTensors: 0,
          peakBytes: 0,
          kernels: [],
          result: null,
          get kernelNames() {
            return Array.from(new Set(this.kernels.map((k) => k.name)));
          }
        };
      }
      dispose() {
        for (const variableName in this.registeredVariables) {
          this.registeredVariables[variableName].dispose();
        }
      }
    };
    var Engine = class {
      constructor(ENV4) {
        this.ENV = ENV4;
        this.registry = {};
        this.registryFactory = {};
        this.pendingBackendInitId = 0;
        this.state = new EngineState();
      }
      ready() {
        return __async(this, null, function* () {
          if (this.pendingBackendInit != null) {
            return this.pendingBackendInit.then(() => {
            });
          }
          if (this.backendInstance != null) {
            return;
          }
          const sortedBackends = this.getSortedBackends();
          for (let i = 0; i < sortedBackends.length; i++) {
            const backendName = sortedBackends[i];
            const success = yield this.initializeBackend(backendName).success;
            if (success) {
              yield this.setBackend(backendName);
              return;
            }
          }
          throw new Error(`Could not initialize any backends, all backend initializations failed.`);
        });
      }
      get backend() {
        if (this.pendingBackendInit != null) {
          throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        if (this.backendInstance == null) {
          const { name, asyncInit } = this.initializeBackendsAndReturnBest();
          if (asyncInit) {
            throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
          }
          this.setBackend(name);
        }
        return this.backendInstance;
      }
      backendNames() {
        return Object.keys(this.registryFactory);
      }
      findBackend(backendName) {
        if (!(backendName in this.registry)) {
          if (backendName in this.registryFactory) {
            const { asyncInit } = this.initializeBackend(backendName);
            if (asyncInit) {
              return null;
            }
          } else {
            return null;
          }
        }
        return this.registry[backendName];
      }
      findBackendFactory(backendName) {
        if (!(backendName in this.registryFactory)) {
          return null;
        }
        return this.registryFactory[backendName].factory;
      }
      registerBackend(backendName, factory, priority = 1) {
        if (backendName in this.registryFactory) {
          console.warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
          return false;
        }
        this.registryFactory[backendName] = { factory, priority };
        return true;
      }
      setBackend(backendName) {
        return __async(this, null, function* () {
          if (this.registryFactory[backendName] == null) {
            throw new Error(`Backend name '${backendName}' not found in registry`);
          }
          this.backendName = backendName;
          if (this.registry[backendName] == null) {
            this.backendInstance = null;
            const { success, asyncInit } = this.initializeBackend(backendName);
            const result2 = asyncInit ? yield success : success;
            if (!result2) {
              return false;
            }
          }
          this.backendInstance = this.registry[backendName];
          this.setupRegisteredKernels();
          this.profiler = new Profiler(this.backendInstance);
          return true;
        });
      }
      setupRegisteredKernels() {
        const kernels = getKernelsForBackend(this.backendName);
        kernels.forEach((kernel) => {
          if (kernel.setupFunc != null) {
            kernel.setupFunc(this.backendInstance);
          }
        });
      }
      disposeRegisteredKernels(backendName) {
        const kernels = getKernelsForBackend(backendName);
        kernels.forEach((kernel) => {
          if (kernel.disposeFunc != null) {
            kernel.disposeFunc(this.registry[backendName]);
          }
        });
      }
      initializeBackend(backendName) {
        const registryFactoryEntry = this.registryFactory[backendName];
        if (registryFactoryEntry == null) {
          throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
        }
        try {
          const backend = registryFactoryEntry.factory();
          if (backend && !(backend instanceof KernelBackend) && typeof backend.then === "function") {
            const promiseId = ++this.pendingBackendInitId;
            const success = backend.then((backendInstance) => {
              if (promiseId < this.pendingBackendInitId) {
                return false;
              }
              this.registry[backendName] = backendInstance;
              this.pendingBackendInit = null;
              return true;
            }).catch((err) => {
              if (promiseId < this.pendingBackendInitId) {
                return false;
              }
              this.pendingBackendInit = null;
              console.warn(`Initialization of backend ${backendName} failed`);
              console.warn(err.stack || err.message);
              return false;
            });
            this.pendingBackendInit = success;
            return { success, asyncInit: true };
          } else {
            this.registry[backendName] = backend;
            return { success: true, asyncInit: false };
          }
        } catch (err) {
          console.warn(`Initialization of backend ${backendName} failed`);
          console.warn(err.stack || err.message);
          return { success: false, asyncInit: false };
        }
      }
      removeBackend(backendName) {
        if (!(backendName in this.registryFactory)) {
          throw new Error(`${backendName} backend not found in registry`);
        }
        if (this.backendName === backendName && this.pendingBackendInit != null) {
          this.pendingBackendInitId++;
        }
        if (backendName in this.registry) {
          this.disposeRegisteredKernels(backendName);
          this.registry[backendName].dispose();
          delete this.registry[backendName];
        }
        delete this.registryFactory[backendName];
        if (this.backendName === backendName) {
          this.pendingBackendInit = null;
          this.backendName = null;
          this.backendInstance = null;
        }
      }
      getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) {
          throw new Error("No backend found in registry.");
        }
        return Object.keys(this.registryFactory).sort((a, b) => {
          return this.registryFactory[b].priority - this.registryFactory[a].priority;
        });
      }
      initializeBackendsAndReturnBest() {
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
          const backendName = sortedBackends[i];
          const { success, asyncInit } = this.initializeBackend(backendName);
          if (asyncInit || success) {
            return { name: backendName, asyncInit };
          }
        }
        throw new Error(`Could not initialize any backends, all backend initializations failed.`);
      }
      moveData(backend, dataId) {
        const info = this.state.tensorInfo.get(dataId);
        const srcBackend = info.backend;
        const values = this.readSync(dataId);
        const refCount = srcBackend.refCount(dataId);
        srcBackend.disposeData(dataId, true);
        info.backend = backend;
        backend.move(dataId, values, info.shape, info.dtype, refCount);
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        }
      }
      tidy(nameOrFn, fn) {
        let name = null;
        if (fn == null) {
          if (typeof nameOrFn !== "function") {
            throw new Error("Please provide a function to tidy()");
          }
          fn = nameOrFn;
        } else {
          if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
            throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          }
          if (typeof fn !== "function") {
            throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          }
          name = nameOrFn;
        }
        let result2;
        return this.scopedRun(() => this.startScope(name), () => this.endScope(result2), () => {
          result2 = fn();
          if (result2 instanceof Promise) {
            console.error("Cannot return a Promise inside of tidy.");
          }
          return result2;
        });
      }
      scopedRun(start, end, f) {
        start();
        try {
          const res = f();
          end();
          return res;
        } catch (ex) {
          end();
          throw ex;
        }
      }
      nextTensorId() {
        return Engine.nextTensorId++;
      }
      nextVariableId() {
        return Engine.nextVariableId++;
      }
      clone(x) {
        const y = ENGINE.runKernel(Identity, { x });
        const inputs = { x };
        const grad = (dy) => ({
          x: () => {
            const dtype = "float32";
            const gradInputs = { x: dy };
            const attrs = { dtype };
            return ENGINE.runKernel(Cast, gradInputs, attrs);
          }
        });
        const saved = [];
        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
        return y;
      }
      runKernel(kernelName, inputs, attrs) {
        const hasKernel = getKernel(kernelName, this.backendName) != null;
        if (!hasKernel) {
          throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
        }
        return this.runKernelFunc({ kernelName, inputs, attrs });
      }
      shouldCheckForMemLeaks() {
        return this.ENV.getBool("IS_TEST");
      }
      checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
        const numDataIdsAfter = this.backend.numDataIds();
        let numOutputDataIds = 0;
        outInfos.forEach((info) => {
          numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
        });
        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
        if (dataIdsLeaked > 0) {
          throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
        }
      }
      runKernelFunc(kernelParams) {
        let outputs;
        let saved = [];
        const isTapeOn = this.isTapeOn();
        const startingBytecount = this.state.numBytes;
        const startingNumTensors = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack.push(0);
        }
        let kernelFunc;
        if (this.backendName == null) {
          this.backend;
        }
        let out;
        const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
        if (isRegisteredKernelInvocation(kernelParams)) {
          const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
          if (this.backendName == null) {
            this.backend;
          }
          const kernel = getKernel(kernelName, this.backendName);
          assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
          kernelFunc = () => {
            const numDataIdsBefore = this.backend.numDataIds();
            out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
            const outInfos = Array.isArray(out) ? out : [out];
            if (this.shouldCheckForMemLeaks()) {
              this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
            }
            const outTensors = outInfos.map((outInfo) => {
              if (outInfo.rank != null) {
                return outInfo;
              }
              const { dataId, shape, dtype } = outInfo;
              return this.makeTensorFromDataId(dataId, shape, dtype);
            });
            if (isTapeOn) {
              const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
              saved = this.saveTensorsForBackwardMode(tensorsToSave);
            }
            return outTensors;
          };
        } else {
          const { forwardFunc } = kernelParams;
          const saveFunc = (tensors) => {
            if (!isTapeOn) {
              return;
            }
            saved = tensors.map((tensor) => this.keep(this.clone(tensor)));
          };
          kernelFunc = () => {
            const numDataIdsBefore = this.backend.numDataIds();
            out = this.tidy(() => forwardFunc(this.backend, saveFunc));
            const outs = Array.isArray(out) ? out : [out];
            if (this.shouldCheckForMemLeaks()) {
              this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
            }
            return outs;
          };
        }
        const { inputs, attrs } = kernelParams;
        const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
        let kernelProfile;
        this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
          if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
            outputs = kernelFunc();
          } else {
            kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
            if (this.ENV.getBool("DEBUG")) {
              this.profiler.logKernelProfile(kernelProfile);
            }
            outputs = kernelProfile.outputs;
          }
        });
        if (isTapeOn) {
          this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
        }
        if (this.state.profiling) {
          this.state.activeProfile.kernels.push({
            name: kernelOrScopeName,
            bytesAdded: this.state.numBytes - startingBytecount,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - startingNumTensors,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
            outputShapes: outputs.map((item) => item.shape),
            kernelTimeMs: kernelProfile.timeMs,
            extraInfo: kernelProfile.extraInfo
          });
        }
        return Array.isArray(out) ? outputs : outputs[0];
      }
      saveTensorsForBackwardMode(tensors) {
        const saved = tensors.map((tensor) => this.keep(this.clone(tensor)));
        return saved;
      }
      getTensorsForGradient(kernelName, inputs, outputs) {
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
          const inputsToSave = gradConfig.inputsToSave || [];
          const outputsToSave = gradConfig.outputsToSave || [];
          let inputTensorsToSave;
          if (gradConfig.saveAllInputs) {
            assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
            inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
          } else {
            inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
          }
          const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
          return inputTensorsToSave.concat(outputTensorsToSave);
        }
        return [];
      }
      makeTensor(values, shape, dtype, backend) {
        if (values == null) {
          throw new Error("Values passed to engine.makeTensor() are null");
        }
        dtype = dtype || "float32";
        backend = backend || this.backend;
        let backendVals = values;
        if (dtype === "string" && isString(values[0])) {
          backendVals = values.map((d) => encodeString(d));
        }
        const dataId = backend.write(backendVals, shape, dtype);
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        if (dtype === "string") {
          const info = this.state.tensorInfo.get(dataId);
          const newBytes = bytesFromStringArray(backendVals);
          this.state.numBytes += newBytes - info.bytes;
          info.bytes = newBytes;
        }
        return t;
      }
      makeTensorFromDataId(dataId, shape, dtype, backend) {
        dtype = dtype || "float32";
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        return t;
      }
      makeVariable(initialValue, trainable = true, name, dtype) {
        name = name || this.nextVariableId().toString();
        if (dtype != null && dtype !== initialValue.dtype) {
          initialValue = initialValue.cast(dtype);
        }
        const v = new Variable(initialValue, trainable, name, this.nextTensorId());
        if (this.state.registeredVariables[v.name] != null) {
          throw new Error(`Variable with name ${v.name} was already registered`);
        }
        this.state.registeredVariables[v.name] = v;
        this.incRef(v, this.backend);
        return v;
      }
      trackTensor(a, backend) {
        this.state.numTensors++;
        if (a.dtype === "string") {
          this.state.numStringTensors++;
        }
        let bytes = 0;
        if (a.dtype !== "complex64" && a.dtype !== "string") {
          bytes = a.size * bytesPerElement(a.dtype);
        }
        this.state.numBytes += bytes;
        if (!this.state.tensorInfo.has(a.dataId)) {
          this.state.numDataBuffers++;
          this.state.tensorInfo.set(a.dataId, {
            backend: backend || this.backend,
            dtype: a.dtype,
            shape: a.shape,
            bytes
          });
        }
        if (!(a instanceof Variable)) {
          this.track(a);
        }
      }
      incRef(a, backend) {
        this.trackTensor(a, backend);
        this.backend.incRef(a.dataId);
      }
      removeDataId(dataId, backend) {
        if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend) {
          this.state.tensorInfo.delete(dataId);
          this.state.numDataBuffers--;
        }
      }
      disposeTensor(a) {
        if (!this.state.tensorInfo.has(a.dataId)) {
          return;
        }
        const info = this.state.tensorInfo.get(a.dataId);
        this.state.numTensors--;
        if (a.dtype === "string") {
          this.state.numStringTensors--;
          this.state.numBytes -= info.bytes;
        }
        if (a.dtype !== "complex64" && a.dtype !== "string") {
          const bytes = a.size * bytesPerElement(a.dtype);
          this.state.numBytes -= bytes;
        }
        if (info.backend.disposeData(a.dataId)) {
          this.removeDataId(a.dataId, info.backend);
        }
      }
      disposeVariables() {
        for (const varName in this.state.registeredVariables) {
          const v = this.state.registeredVariables[varName];
          this.disposeVariable(v);
        }
      }
      disposeVariable(v) {
        this.disposeTensor(v);
        if (this.state.registeredVariables[v.name] != null) {
          delete this.state.registeredVariables[v.name];
        }
      }
      memory() {
        const info = this.backend.memory();
        info.numTensors = this.state.numTensors;
        info.numDataBuffers = this.state.numDataBuffers;
        info.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
          info.unreliable = true;
          if (info.reasons == null) {
            info.reasons = [];
          }
          info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
        }
        return info;
      }
      profile(query) {
        return __async(this, null, function* () {
          this.state.profiling = true;
          const startBytes = this.state.numBytes;
          const startNumTensors = this.state.numTensors;
          this.state.activeProfile.kernels = [];
          this.state.activeProfile.result = yield query();
          this.state.profiling = false;
          this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
          this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
          this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
          for (const kernel of this.state.activeProfile.kernels) {
            kernel.kernelTimeMs = yield kernel.kernelTimeMs;
            kernel.extraInfo = yield kernel.extraInfo;
          }
          return this.state.activeProfile;
        });
      }
      isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
      }
      addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
        const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
          gradientsFunc = gradConfig.gradFunc;
        }
        if (gradientsFunc != null) {
          tapeNode.gradient = (dys) => {
            dys = dys.map((dy, i) => {
              if (dy == null) {
                const output = outputs[i];
                const vals = makeZerosTypedArray(output.size, output.dtype);
                return this.makeTensor(vals, output.shape, output.dtype);
              }
              return dy;
            });
            return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
          };
        }
        this.state.activeTape.push(tapeNode);
      }
      keep(result2) {
        result2.kept = true;
        return result2;
      }
      startTape() {
        if (this.state.gradientDepth === 0) {
          this.state.activeTape = [];
        }
        this.state.gradientDepth++;
      }
      endTape() {
        this.state.gradientDepth--;
      }
      startScope(name) {
        const scopeInfo = {
          track: [],
          name: "unnamed scope",
          id: this.state.nextScopeId++
        };
        if (name) {
          scopeInfo.name = name;
        }
        this.state.scopeStack.push(scopeInfo);
        this.state.activeScope = scopeInfo;
      }
      endScope(result2) {
        const tensorsToTrackInParent = getTensorsInContainer(result2);
        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
        for (let i = 0; i < this.state.activeScope.track.length; i++) {
          const tensor = this.state.activeScope.track[i];
          if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {
            tensor.dispose();
          }
        }
        const oldScope = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
        tensorsToTrackInParent.forEach((tensor) => {
          if (!tensor.kept && tensor.scopeId === oldScope.id) {
            this.track(tensor);
          }
        });
      }
      gradients(f, xs, dy, allowNoGradients = false) {
        assert(xs.length > 0, () => "gradients() received an empty list of xs.");
        if (dy != null && dy.dtype !== "float32") {
          throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
        }
        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
        assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
        const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
          throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        }
        return this.tidy("backward", () => {
          const accumulatedGradientMap = {};
          accumulatedGradientMap[y.id] = dy == null ? ones(y.shape) : dy;
          backpropagateGradients(accumulatedGradientMap, filteredTape, (f2) => this.tidy(f2), add);
          const grads = xs.map((x) => accumulatedGradientMap[x.id]);
          if (this.state.gradientDepth === 0) {
            this.state.activeTape.forEach((node) => {
              for (const tensor of node.saved) {
                tensor.dispose();
              }
            });
            this.state.activeTape = null;
          }
          return { value: y, grads };
        });
      }
      customGrad(f) {
        assert(isFunction(f), () => "The f passed in customGrad(f) must be a function.");
        return (...inputs) => {
          assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
          let res;
          const inputMap = {};
          inputs.forEach((input, i) => {
            inputMap[i] = input;
          });
          const forwardFunc = (_, save2) => {
            res = f(...[...inputs, save2]);
            assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
            assert(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
            return res.value;
          };
          const backwardsFunc = (dy, saved) => {
            const gradRes = res.gradFunc(dy, saved);
            const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
            assert(grads.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
            assert(grads.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
            const gradMap = {};
            grads.forEach((grad, i) => {
              gradMap[i] = () => grad;
            });
            return gradMap;
          };
          return this.runKernelFunc({
            forwardFunc,
            backwardsFunc,
            inputs: inputMap
          });
        };
      }
      readSync(dataId) {
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
      }
      read(dataId) {
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.read(dataId);
      }
      time(query) {
        return __async(this, null, function* () {
          const start = now();
          const timingInfo = yield this.backend.time(query);
          timingInfo.wallMs = now() - start;
          return timingInfo;
        });
      }
      track(result2) {
        if (this.state.activeScope != null) {
          result2.scopeId = this.state.activeScope.id;
          this.state.activeScope.track.push(result2);
        }
        return result2;
      }
      get registeredVariables() {
        return this.state.registeredVariables;
      }
      reset() {
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new EngineState();
        for (const backendName in this.registry) {
          this.disposeRegisteredKernels(backendName);
          this.registry[backendName].dispose();
          delete this.registry[backendName];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
      }
    };
    Engine.nextTensorId = 0;
    Engine.nextVariableId = 0;
    function ones(shape) {
      const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
      return ENGINE.makeTensor(values, shape, "float32");
    }
    function getOrMakeEngine() {
      const ns = getGlobalNamespace();
      if (ns._tfengine == null) {
        const environment = new Environment(ns);
        ns._tfengine = new Engine(environment);
      }
      setEnvironmentGlobal(ns._tfengine.ENV);
      setTensorTracker(() => ns._tfengine);
      return ns._tfengine;
    }
    var ENGINE = getOrMakeEngine();
    function add(a, b) {
      const inputs = { a, b };
      return ENGINE.runKernel(Add, inputs);
    }
  
    // ../../../tfjs/tfjs-core/dist/device_util.js
    var device_util_exports = {};
    __export(device_util_exports, {
      isBrowser: () => isBrowser,
      isMobile: () => isMobile
    });
    function _isNavigatorDefined() {
      return typeof navigator !== "undefined" && navigator != null;
    }
    function isMobile(nav) {
      if (nav || _isNavigatorDefined()) {
        if (!nav) {
          nav = navigator;
        }
        if (nav.product === "ReactNative") {
          return true;
        }
        const a = nav.userAgent || nav.vendor || window.opera;
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
      }
      return false;
    }
    function isBrowser() {
      return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
    }
  
    // ../../../tfjs/tfjs-core/dist/flags.js
    var ENV2 = env();
    ENV2.registerFlag("DEBUG", () => false, (debugValue) => {
      if (debugValue) {
        console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
      }
    });
    ENV2.registerFlag("IS_BROWSER", () => isBrowser());
    ENV2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
    ENV2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
    ENV2.registerFlag("PROD", () => false);
    ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV2.getBool("DEBUG"));
    ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
    ENV2.registerFlag("IS_TEST", () => false);
    ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
    ENV2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  
    // ../../../tfjs/tfjs-core/dist/tensor_util_env.js
    function inferShape(val, dtype) {
      let firstElem = val;
      if (isTypedArray(val)) {
        return dtype === "string" ? [] : [val.length];
      }
      if (!Array.isArray(val)) {
        return [];
      }
      const shape = [];
      while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
      }
      if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
        deepAssertShapeConsistency(val, shape, []);
      }
      return shape;
    }
    function deepAssertShapeConsistency(val, shape, indices) {
      indices = indices || [];
      if (!Array.isArray(val) && !isTypedArray(val)) {
        assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
        return;
      }
      assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
      assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
      const subShape = shape.slice(1);
      for (let i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
      }
    }
    function assertDtype(expectedDtype, actualDType, argName, functionName) {
      if (expectedDtype === "string_or_numeric") {
        return;
      }
      if (expectedDtype == null) {
        throw new Error(`Expected dtype cannot be null.`);
      }
      if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
      }
    }
    function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
      if (x instanceof Tensor) {
        assertDtype(parseAsDtype, x.dtype, argName, functionName);
        return x;
      }
      let inferredDtype = inferDtype(x);
      if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
        inferredDtype = parseAsDtype;
      }
      assertDtype(parseAsDtype, inferredDtype, argName, functionName);
      if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
        const type = x == null ? "null" : x.constructor.name;
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
      }
      const inferredShape = inferShape(x, inferredDtype);
      if (!isTypedArray(x) && !Array.isArray(x)) {
        x = [x];
      }
      const skipTypedArray = true;
      const values = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);
      return ENGINE.makeTensor(values, inferredShape, inferredDtype);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/operation.js
    var OP_SCOPE_SUFFIX = "__op";
    function op(f) {
      const keys = Object.keys(f);
      if (keys.length !== 1) {
        throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
      }
      let opName = keys[0];
      const fn = f[opName];
      if (opName.endsWith("_")) {
        opName = opName.substring(0, opName.length - 1);
      }
      opName = opName + OP_SCOPE_SUFFIX;
      const f2 = (...args) => {
        ENGINE.startScope(opName);
        try {
          const result2 = fn(...args);
          if (isPromise(result2)) {
            console.error("Cannot return a Promise inside of tidy.");
          }
          ENGINE.endScope(result2);
          return result2;
        } catch (ex) {
          ENGINE.endScope(null);
          throw ex;
        }
      };
      Object.defineProperty(f2, "name", { value: opName, configurable: true });
      return f2;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/complex.js
    function complex_(real3, imag2) {
      const $real = convertToTensor(real3, "real", "complex");
      const $imag = convertToTensor(imag2, "imag", "complex");
      assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
      const inputs = { real: $real, imag: $imag };
      return ENGINE.runKernel(Complex, inputs);
    }
    var complex = op({ complex_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/tensor_ops_util.js
    function makeTensor(values, shape, inferredShape, dtype) {
      if (dtype == null) {
        dtype = inferDtype(values);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
      }
      if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
        throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
      }
      if (shape != null) {
        assertNonNegativeIntegerDimensions(shape);
        const providedSize = sizeFromShape(shape);
        const inferredSize = sizeFromShape(inferredShape);
        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
        for (let i = 0; i < inferredShape.length; ++i) {
          const inferred = inferredShape[i];
          const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
          assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
        }
      }
      if (!isTypedArray(values) && !Array.isArray(values)) {
        values = [values];
      }
      shape = shape || inferredShape;
      values = dtype !== "string" ? toTypedArray(values, dtype) : flatten(values, [], true);
      return ENGINE.makeTensor(values, shape, dtype);
    }
  
    // ../../../tfjs/tfjs-core/dist/io/io_utils.js
    var useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
    function stringByteLength(str) {
      if (useNodeBuffer) {
        return Buffer.byteLength(str);
      }
      return new Blob([str]).size;
    }
    function arrayBufferToBase64String(buffer2) {
      if (useNodeBuffer) {
        return Buffer.from(buffer2).toString("base64");
      }
      const buf = new Uint8Array(buffer2);
      let s = "";
      for (let i = 0, l = buf.length; i < l; i++) {
        s += String.fromCharCode(buf[i]);
      }
      return btoa(s);
    }
    function base64StringToArrayBuffer(str) {
      if (useNodeBuffer) {
        const buf = Buffer.from(str, "base64");
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      }
      const s = atob(str);
      const buffer2 = new Uint8Array(s.length);
      for (let i = 0; i < s.length; ++i) {
        buffer2.set([s.charCodeAt(i)], i);
      }
      return buffer2.buffer;
    }
    function concatenateArrayBuffers(buffers) {
      if (buffers.length === 1) {
        return buffers[0];
      }
      let totalByteLength = 0;
      buffers.forEach((buffer2) => {
        totalByteLength += buffer2.byteLength;
      });
      const temp = new Uint8Array(totalByteLength);
      let offset = 0;
      buffers.forEach((buffer2) => {
        temp.set(new Uint8Array(buffer2), offset);
        offset += buffer2.byteLength;
      });
      return temp.buffer;
    }
    function getModelArtifactsInfoForJSON(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("Expected JSON model topology, received ArrayBuffer.");
      }
      return {
        dateSaved: new Date(),
        modelTopologyType: "JSON",
        modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
      };
    }
  
    // ../../../tfjs/tfjs-core/dist/io/router_registry.js
    var IORouterRegistry = class {
      constructor() {
        this.saveRouters = [];
        this.loadRouters = [];
      }
      static getInstance() {
        if (IORouterRegistry.instance == null) {
          IORouterRegistry.instance = new IORouterRegistry();
        }
        return IORouterRegistry.instance;
      }
      static registerSaveRouter(saveRouter) {
        IORouterRegistry.getInstance().saveRouters.push(saveRouter);
      }
      static registerLoadRouter(loadRouter) {
        IORouterRegistry.getInstance().loadRouters.push(loadRouter);
      }
      static getSaveHandlers(url) {
        return IORouterRegistry.getHandlers(url, "save");
      }
      static getLoadHandlers(url, loadOptions) {
        return IORouterRegistry.getHandlers(url, "load", loadOptions);
      }
      static getHandlers(url, handlerType, loadOptions) {
        const validHandlers = [];
        const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
        routers.forEach((router) => {
          const handler = router(url, loadOptions);
          if (handler !== null) {
            validHandlers.push(handler);
          }
        });
        return validHandlers;
      }
    };
  
    // ../../../tfjs/tfjs-core/dist/io/indexed_db.js
    var DATABASE_NAME = "tensorflowjs";
    var DATABASE_VERSION = 1;
    var MODEL_STORE_NAME = "models_store";
    var INFO_STORE_NAME = "model_info_store";
    function getIndexedDBFactory() {
      if (!env().getBool("IS_BROWSER")) {
        throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
      }
      const theWindow = typeof window === "undefined" ? self : window;
      const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
      if (factory == null) {
        throw new Error("The current browser does not appear to support IndexedDB.");
      }
      return factory;
    }
    function setUpDatabase(openRequest) {
      const db = openRequest.result;
      db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
      db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
    }
    var BrowserIndexedDB = class {
      constructor(modelPath) {
        this.indexedDB = getIndexedDBFactory();
        if (modelPath == null || !modelPath) {
          throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        }
        this.modelPath = modelPath;
      }
      save(modelArtifacts) {
        return __async(this, null, function* () {
          if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          }
          return this.databaseAction(this.modelPath, modelArtifacts);
        });
      }
      load() {
        return __async(this, null, function* () {
          return this.databaseAction(this.modelPath);
        });
      }
      databaseAction(modelPath, modelArtifacts) {
        return new Promise((resolve, reject) => {
          const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
          openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
          openRequest.onsuccess = () => {
            const db = openRequest.result;
            if (modelArtifacts == null) {
              const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const getRequest = modelStore.get(this.modelPath);
              getRequest.onsuccess = () => {
                if (getRequest.result == null) {
                  db.close();
                  return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
                } else {
                  resolve(getRequest.result.modelArtifacts);
                }
              };
              getRequest.onerror = (error) => {
                db.close();
                return reject(getRequest.error);
              };
              modelTx.oncomplete = () => db.close();
            } else {
              const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
              const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
              let infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
              let modelTx;
              putInfoRequest.onsuccess = () => {
                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                const putModelRequest = modelStore.put({
                  modelPath: this.modelPath,
                  modelArtifacts,
                  modelArtifactsInfo
                });
                putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
                putModelRequest.onerror = (error) => {
                  infoStore = infoTx.objectStore(INFO_STORE_NAME);
                  const deleteInfoRequest = infoStore.delete(this.modelPath);
                  deleteInfoRequest.onsuccess = () => {
                    db.close();
                    return reject(putModelRequest.error);
                  };
                  deleteInfoRequest.onerror = (error2) => {
                    db.close();
                    return reject(putModelRequest.error);
                  };
                };
              };
              putInfoRequest.onerror = (error) => {
                db.close();
                return reject(putInfoRequest.error);
              };
              infoTx.oncomplete = () => {
                if (modelTx == null) {
                  db.close();
                } else {
                  modelTx.oncomplete = () => db.close();
                }
              };
            }
          };
          openRequest.onerror = (error) => reject(openRequest.error);
        });
      }
    };
    BrowserIndexedDB.URL_SCHEME = "indexeddb://";
    var indexedDBRouter = (url) => {
      if (!env().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
          return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(indexedDBRouter);
    IORouterRegistry.registerLoadRouter(indexedDBRouter);
    function browserIndexedDB(modelPath) {
      return new BrowserIndexedDB(modelPath);
    }
    function maybeStripScheme(key) {
      return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
    }
    var BrowserIndexedDBManager = class {
      constructor() {
        this.indexedDB = getIndexedDBFactory();
      }
      listModels() {
        return __async(this, null, function* () {
          return new Promise((resolve, reject) => {
            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
            openRequest.onsuccess = () => {
              const db = openRequest.result;
              const tx = db.transaction(INFO_STORE_NAME, "readonly");
              const store = tx.objectStore(INFO_STORE_NAME);
              const getAllInfoRequest = store.getAll();
              getAllInfoRequest.onsuccess = () => {
                const out = {};
                for (const item of getAllInfoRequest.result) {
                  out[item.modelPath] = item.modelArtifactsInfo;
                }
                resolve(out);
              };
              getAllInfoRequest.onerror = (error) => {
                db.close();
                return reject(getAllInfoRequest.error);
              };
              tx.oncomplete = () => db.close();
            };
            openRequest.onerror = (error) => reject(openRequest.error);
          });
        });
      }
      removeModel(path) {
        return __async(this, null, function* () {
          path = maybeStripScheme(path);
          return new Promise((resolve, reject) => {
            const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
            openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
            openRequest.onsuccess = () => {
              const db = openRequest.result;
              const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
              const infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const getInfoRequest = infoStore.get(path);
              let modelTx;
              getInfoRequest.onsuccess = () => {
                if (getInfoRequest.result == null) {
                  db.close();
                  return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
                } else {
                  const deleteInfoRequest = infoStore.delete(path);
                  const deleteModelData = () => {
                    modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                    const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                    const deleteModelRequest = modelStore.delete(path);
                    deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
                    deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
                  };
                  deleteInfoRequest.onsuccess = deleteModelData;
                  deleteInfoRequest.onerror = (error) => {
                    deleteModelData();
                    db.close();
                    return reject(getInfoRequest.error);
                  };
                }
              };
              getInfoRequest.onerror = (error) => {
                db.close();
                return reject(getInfoRequest.error);
              };
              infoTx.oncomplete = () => {
                if (modelTx == null) {
                  db.close();
                } else {
                  modelTx.oncomplete = () => db.close();
                }
              };
            };
            openRequest.onerror = (error) => reject(openRequest.error);
          });
        });
      }
    };
  
    // ../../../tfjs/tfjs-core/dist/io/local_storage.js
    var PATH_SEPARATOR = "/";
    var PATH_PREFIX = "tensorflowjs_models";
    var INFO_SUFFIX = "info";
    var MODEL_TOPOLOGY_SUFFIX = "model_topology";
    var WEIGHT_SPECS_SUFFIX = "weight_specs";
    var WEIGHT_DATA_SUFFIX = "weight_data";
    var MODEL_METADATA_SUFFIX = "model_metadata";
    function getModelKeys(path) {
      return {
        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
        modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
      };
    }
    function getModelPathFromKey(key) {
      const items = key.split(PATH_SEPARATOR);
      if (items.length < 3) {
        throw new Error(`Invalid key format: ${key}`);
      }
      return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
    }
    function maybeStripScheme2(key) {
      return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
    }
    var BrowserLocalStorage = class {
      constructor(modelPath) {
        if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
          throw new Error("The current environment does not support local storage.");
        }
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) {
          throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        }
        this.modelPath = modelPath;
        this.keys = getModelKeys(this.modelPath);
      }
      save(modelArtifacts) {
        return __async(this, null, function* () {
          if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          } else {
            const topology = JSON.stringify(modelArtifacts.modelTopology);
            const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
            try {
              this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
              this.LS.setItem(this.keys.topology, topology);
              this.LS.setItem(this.keys.weightSpecs, weightSpecs);
              this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));
              const result2 = {
                format: modelArtifacts.format,
                generatedBy: modelArtifacts.generatedBy,
                convertedBy: modelArtifacts.convertedBy
              };
              if (modelArtifacts.signature != null) {
                result2.signature = modelArtifacts.signature;
              }
              if (modelArtifacts.userDefinedMetadata != null) {
                result2.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
              }
              if (modelArtifacts.modelInitializer != null) {
                result2.modelInitializer = modelArtifacts.modelInitializer;
              }
              this.LS.setItem(this.keys.modelMetadata, JSON.stringify(result2));
              return { modelArtifactsInfo };
            } catch (err) {
              this.LS.removeItem(this.keys.info);
              this.LS.removeItem(this.keys.topology);
              this.LS.removeItem(this.keys.weightSpecs);
              this.LS.removeItem(this.keys.weightData);
              this.LS.removeItem(this.keys.modelMetadata);
              throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
            }
          }
        });
      }
      load() {
        return __async(this, null, function* () {
          const info = JSON.parse(this.LS.getItem(this.keys.info));
          if (info == null) {
            throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
          }
          if (info.modelTopologyType !== "JSON") {
            throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
          }
          const out = {};
          const topology = JSON.parse(this.LS.getItem(this.keys.topology));
          if (topology == null) {
            throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
          }
          out.modelTopology = topology;
          const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
          if (weightSpecs == null) {
            throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
          }
          out.weightSpecs = weightSpecs;
          const metadataString = this.LS.getItem(this.keys.modelMetadata);
          if (metadataString != null) {
            const metadata = JSON.parse(metadataString);
            out.format = metadata["format"];
            out.generatedBy = metadata["generatedBy"];
            out.convertedBy = metadata["convertedBy"];
            if (metadata["signature"] != null) {
              out.signature = metadata["signature"];
            }
            if (metadata["userDefinedMetadata"] != null) {
              out.userDefinedMetadata = metadata["userDefinedMetadata"];
            }
            if (metadata["modelInitializer"] != null) {
              out.modelInitializer = metadata["modelInitializer"];
            }
          }
          const weightDataBase64 = this.LS.getItem(this.keys.weightData);
          if (weightDataBase64 == null) {
            throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
          }
          out.weightData = base64StringToArrayBuffer(weightDataBase64);
          return out;
        });
      }
    };
    BrowserLocalStorage.URL_SCHEME = "localstorage://";
    var localStorageRouter = (url) => {
      if (!env().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
          return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(localStorageRouter);
    IORouterRegistry.registerLoadRouter(localStorageRouter);
    function browserLocalStorage(modelPath) {
      return new BrowserLocalStorage(modelPath);
    }
    var BrowserLocalStorageManager = class {
      constructor() {
        assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
        assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
        this.LS = window.localStorage;
      }
      listModels() {
        return __async(this, null, function* () {
          const out = {};
          const prefix = PATH_PREFIX + PATH_SEPARATOR;
          const suffix = PATH_SEPARATOR + INFO_SUFFIX;
          for (let i = 0; i < this.LS.length; ++i) {
            const key = this.LS.key(i);
            if (key.startsWith(prefix) && key.endsWith(suffix)) {
              const modelPath = getModelPathFromKey(key);
              out[modelPath] = JSON.parse(this.LS.getItem(key));
            }
          }
          return out;
        });
      }
      removeModel(path) {
        return __async(this, null, function* () {
          path = maybeStripScheme2(path);
          const keys = getModelKeys(path);
          if (this.LS.getItem(keys.info) == null) {
            throw new Error(`Cannot find model at path '${path}'`);
          }
          const info = JSON.parse(this.LS.getItem(keys.info));
          this.LS.removeItem(keys.info);
          this.LS.removeItem(keys.topology);
          this.LS.removeItem(keys.weightSpecs);
          this.LS.removeItem(keys.weightData);
          return info;
        });
      }
    };
  
    // ../../../tfjs/tfjs-core/dist/io/model_management.js
    var URL_SCHEME_SUFFIX = "://";
    var ModelStoreManagerRegistry = class {
      constructor() {
        this.managers = {};
      }
      static getInstance() {
        if (ModelStoreManagerRegistry.instance == null) {
          ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
        }
        return ModelStoreManagerRegistry.instance;
      }
      static registerManager(scheme, manager) {
        assert(scheme != null, () => "scheme must not be undefined or null.");
        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
          scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
        }
        assert(scheme.length > 0, () => "scheme must not be an empty string.");
        const registry = ModelStoreManagerRegistry.getInstance();
        assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
        registry.managers[scheme] = manager;
      }
      static getManager(scheme) {
        const manager = this.getInstance().managers[scheme];
        if (manager == null) {
          throw new Error(`Cannot find model manager for scheme '${scheme}'`);
        }
        return manager;
      }
      static getSchemes() {
        return Object.keys(this.getInstance().managers);
      }
    };
  
    // ../../../tfjs/tfjs-core/dist/platforms/platform_browser.js
    var PlatformBrowser = class {
      fetch(path, init) {
        return fetch(path, init);
      }
      now() {
        return performance.now();
      }
      encode(text, encoding) {
        if (encoding !== "utf-8" && encoding !== "utf8") {
          throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
        }
        if (this.textEncoder == null) {
          this.textEncoder = new TextEncoder();
        }
        return this.textEncoder.encode(text);
      }
      decode(bytes, encoding) {
        return new TextDecoder(encoding).decode(bytes);
      }
    };
    if (env().get("IS_BROWSER")) {
      env().setPlatform("browser", new PlatformBrowser());
      try {
        ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
      } catch (err) {
      }
      try {
        ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
      } catch (err) {
      }
    }
  
    // ../../../tfjs/tfjs-core/dist/platforms/platform_node.js
    var getNodeFetch = {
      importFetch: () => require_browser()
    };
    var systemFetch;
    var PlatformNode = class {
      constructor() {
        this.util = require_util();
        this.textEncoder = new this.util.TextEncoder();
      }
      fetch(path, requestInits) {
        if (env().global.fetch != null) {
          return env().global.fetch(path, requestInits);
        }
        if (systemFetch == null) {
          systemFetch = getNodeFetch.importFetch();
        }
        return systemFetch(path, requestInits);
      }
      now() {
        const time = process.hrtime();
        return time[0] * 1e3 + time[1] / 1e6;
      }
      encode(text, encoding) {
        if (encoding !== "utf-8" && encoding !== "utf8") {
          throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
        }
        return this.textEncoder.encode(text);
      }
      decode(bytes, encoding) {
        if (bytes.length === 0) {
          return "";
        }
        return new this.util.TextDecoder(encoding).decode(bytes);
      }
    };
    if (env().get("IS_NODE")) {
      env().setPlatform("node", new PlatformNode());
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/buffer.js
    function buffer(shape, dtype = "float32", values) {
      dtype = dtype || "float32";
      assertNonNegativeIntegerDimensions(shape);
      return new TensorBuffer(shape, dtype, values);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/cast.js
    function cast_(x, dtype) {
      const $x = convertToTensor(x, "x", "cast");
      if (!isValidDtype(dtype)) {
        throw new Error(`Failed to cast to unknown dtype ${dtype}`);
      }
      if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
        throw new Error("Only strings can be casted to strings");
      }
      const inputs = { x: $x };
      const attrs = { dtype };
      return ENGINE.runKernel(Cast, inputs, attrs);
    }
    var cast = op({ cast_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/clone.js
    function clone_(x) {
      const $x = convertToTensor(x, "x", "clone", "string_or_numeric");
      const inputs = { x: $x };
      return ENGINE.runKernel(Identity, inputs);
    }
    var clone = op({ clone_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/print.js
    function print(x, verbose = false) {
      console.log(x.toString(verbose));
    }
  
    // ../../../tfjs/tfjs-core/dist/base_side_effects.js
    getOrMakeEngine();
    var opHandler2 = {
      buffer,
      cast,
      clone,
      print
    };
    setOpHandler(opHandler2);
  
    // ../../../tfjs/tfjs-core/dist/io/browser_files.js
    var DEFAULT_FILE_NAME_PREFIX = "model";
    var DEFAULT_JSON_EXTENSION_NAME = ".json";
    var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
    function defer(f) {
      return new Promise((resolve) => setTimeout(resolve)).then(f);
    }
    var BrowserDownloads = class {
      constructor(fileNamePrefix) {
        if (!env().getBool("IS_BROWSER")) {
          throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        }
        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
          fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
        }
        if (fileNamePrefix == null || fileNamePrefix.length === 0) {
          fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
        }
        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
      }
      save(modelArtifacts) {
        return __async(this, null, function* () {
          if (typeof document === "undefined") {
            throw new Error("Browser downloads are not supported in this environment since `document` is not present");
          }
          const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: "application/octet-stream" }));
          if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
          } else {
            const weightsManifest = [{
              paths: ["./" + this.weightDataFileName],
              weights: modelArtifacts.weightSpecs
            }];
            const modelTopologyAndWeightManifest = {
              modelTopology: modelArtifacts.modelTopology,
              format: modelArtifacts.format,
              generatedBy: modelArtifacts.generatedBy,
              convertedBy: modelArtifacts.convertedBy,
              weightsManifest
            };
            if (modelArtifacts.signature != null) {
              modelTopologyAndWeightManifest.signature = modelArtifacts.signature;
            }
            if (modelArtifacts.userDefinedMetadata != null) {
              modelTopologyAndWeightManifest.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
            }
            if (modelArtifacts.modelInitializer != null) {
              modelTopologyAndWeightManifest.modelInitializer = modelArtifacts.modelInitializer;
            }
            const modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: "application/json" }));
            const jsonAnchor = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor;
            jsonAnchor.download = this.modelTopologyFileName;
            jsonAnchor.href = modelTopologyAndWeightManifestURL;
            yield defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
            if (modelArtifacts.weightData != null) {
              const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
              weightDataAnchor.download = this.weightDataFileName;
              weightDataAnchor.href = weightsURL;
              yield defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
            }
            return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
          }
        });
      }
    };
    BrowserDownloads.URL_SCHEME = "downloads://";
    var browserDownloadsRouter = (url) => {
      if (!env().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
          return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
    function browserDownloads(fileNamePrefix = "model") {
      return new BrowserDownloads(fileNamePrefix);
    }
  
    // ../../../tfjs/tfjs-core/dist/io/progress.js
    function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
      checkPromises(promises);
      startFraction = startFraction == null ? 0 : startFraction;
      endFraction = endFraction == null ? 1 : endFraction;
      checkFraction(startFraction, endFraction);
      let resolvedPromise = 0;
      const registerMonitor = (promise) => {
        promise.then((value) => {
          const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
          onProgress(fraction);
          return value;
        });
        return promise;
      };
      function checkPromises(promises2) {
        assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
      }
      function checkFraction(startFraction2, endFraction2) {
        assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
        assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
        assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
      }
      return Promise.all(promises.map(registerMonitor));
    }
  
    // ../../../tfjs/tfjs-core/dist/io/weights_loader.js
    function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
      return __async(this, null, function* () {
        if (loadOptions == null) {
          loadOptions = {};
        }
        const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
        const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
        const fetchStartFraction = 0;
        const fetchEndFraction = 0.5;
        const responses = loadOptions.onProgress == null ? yield Promise.all(requests) : yield monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
        const bufferPromises = responses.map((response) => response.arrayBuffer());
        const bufferStartFraction = 0.5;
        const bufferEndFraction = 1;
        const buffers = loadOptions.onProgress == null ? yield Promise.all(bufferPromises) : yield monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
        return buffers;
      });
    }
  
    // ../../../tfjs/tfjs-core/dist/io/http.js
    var OCTET_STREAM_MIME_TYPE = "application/octet-stream";
    var JSON_TYPE = "application/json";
    var HTTPRequest = class {
      constructor(path, loadOptions) {
        this.DEFAULT_METHOD = "POST";
        if (loadOptions == null) {
          loadOptions = {};
        }
        this.weightPathPrefix = loadOptions.weightPathPrefix;
        this.onProgress = loadOptions.onProgress;
        this.weightUrlConverter = loadOptions.weightUrlConverter;
        if (loadOptions.fetchFunc != null) {
          assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
          this.fetch = loadOptions.fetchFunc;
        } else {
          this.fetch = env().platform.fetch;
        }
        assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
        if (Array.isArray(path)) {
          assert(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
        }
        this.path = path;
        if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
          throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        }
        this.requestInit = loadOptions.requestInit || {};
      }
      save(modelArtifacts) {
        return __async(this, null, function* () {
          if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
            throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
          }
          const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
          init.body = new FormData();
          const weightsManifest = [{
            paths: ["./model.weights.bin"],
            weights: modelArtifacts.weightSpecs
          }];
          const modelTopologyAndWeightManifest = {
            modelTopology: modelArtifacts.modelTopology,
            format: modelArtifacts.format,
            generatedBy: modelArtifacts.generatedBy,
            convertedBy: modelArtifacts.convertedBy,
            weightsManifest
          };
          if (modelArtifacts.signature != null) {
            modelTopologyAndWeightManifest.signature = modelArtifacts.signature;
          }
          if (modelArtifacts.userDefinedMetadata != null) {
            modelTopologyAndWeightManifest.userDefinedMetadata = modelArtifacts.userDefinedMetadata;
          }
          if (modelArtifacts.modelInitializer != null) {
            modelTopologyAndWeightManifest.modelInitializer = modelArtifacts.modelInitializer;
          }
          init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
          if (modelArtifacts.weightData != null) {
            init.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
          }
          const response = yield this.fetch(this.path, init);
          if (response.ok) {
            return {
              modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
              responses: [response]
            };
          } else {
            throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
          }
        });
      }
      load() {
        return __async(this, null, function* () {
          const modelConfigRequest = yield this.fetch(this.path, this.requestInit);
          if (!modelConfigRequest.ok) {
            throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
          }
          let modelConfig;
          try {
            modelConfig = yield modelConfigRequest.json();
          } catch (e) {
            let message = `Failed to parse model JSON of response from ${this.path}.`;
            if (this.path.endsWith(".pb")) {
              message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
            } else {
              message += " Please make sure the server is serving valid JSON for this request.";
            }
            throw new Error(message);
          }
          const modelTopology = modelConfig.modelTopology;
          const weightsManifest = modelConfig.weightsManifest;
          const generatedBy = modelConfig.generatedBy;
          const convertedBy = modelConfig.convertedBy;
          const format = modelConfig.format;
          const signature = modelConfig.signature;
          const userDefinedMetadata = modelConfig.userDefinedMetadata;
          if (modelTopology == null && weightsManifest == null) {
            throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
          }
          let weightSpecs;
          let weightData;
          if (weightsManifest != null) {
            const results = yield this.loadWeights(weightsManifest);
            [weightSpecs, weightData] = results;
          }
          const artifacts = {
            modelTopology,
            weightSpecs,
            weightData,
            generatedBy,
            convertedBy,
            format
          };
          if (signature != null) {
            artifacts.signature = signature;
          }
          if (userDefinedMetadata != null) {
            artifacts.userDefinedMetadata = userDefinedMetadata;
          }
          const initializer = modelConfig.modelInitializer;
          if (initializer) {
            artifacts.modelInitializer = initializer;
          }
          return artifacts;
        });
      }
      loadWeights(weightsManifest) {
        return __async(this, null, function* () {
          const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
          const [prefix, suffix] = parseUrl(weightPath);
          const pathPrefix = this.weightPathPrefix || prefix;
          const weightSpecs = [];
          for (const entry of weightsManifest) {
            weightSpecs.push(...entry.weights);
          }
          const fetchURLs = [];
          const urlPromises = [];
          for (const weightsGroup of weightsManifest) {
            for (const path of weightsGroup.paths) {
              if (this.weightUrlConverter != null) {
                urlPromises.push(this.weightUrlConverter(path));
              } else {
                fetchURLs.push(pathPrefix + path + suffix);
              }
            }
          }
          if (this.weightUrlConverter) {
            fetchURLs.push(...yield Promise.all(urlPromises));
          }
          const buffers = yield loadWeightsAsArrayBuffer(fetchURLs, {
            requestInit: this.requestInit,
            fetchFunc: this.fetch,
            onProgress: this.onProgress
          });
          return [weightSpecs, concatenateArrayBuffers(buffers)];
        });
      }
    };
    HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
    function parseUrl(url) {
      const lastSlash = url.lastIndexOf("/");
      const lastSearchParam = url.lastIndexOf("?");
      const prefix = url.substring(0, lastSlash);
      const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
      return [prefix + "/", suffix];
    }
    function isHTTPScheme(url) {
      return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
    }
    var httpRouter = (url, loadOptions) => {
      if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
        return null;
      } else {
        let isHTTP = true;
        if (Array.isArray(url)) {
          isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
        } else {
          isHTTP = isHTTPScheme(url);
        }
        if (isHTTP) {
          return http(url, loadOptions);
        }
      }
      return null;
    };
    IORouterRegistry.registerSaveRouter(httpRouter);
    IORouterRegistry.registerLoadRouter(httpRouter);
    function http(path, loadOptions) {
      return new HTTPRequest(path, loadOptions);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/gather_nd_util.js
    function prepareAndValidate(tensor, indices) {
      const tensorRank = tensor.shape.length;
      const indicesRank = indices.shape.length;
      if (tensorRank < 1) {
        throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
      }
      if (indicesRank < 1) {
        throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
      }
      if (indices.dtype !== "int32") {
        throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
      }
      if (indices.shape[indicesRank - 1] > tensorRank) {
        throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
      }
      if (sizeFromShape(tensor.shape) === 0) {
        throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor.shape}.`);
      }
      const indicesShape = indices.shape;
      const sliceRank = indicesShape[indicesShape.length - 1];
      let nResult = 1;
      for (let i = 0; i < indicesShape.length - 1; ++i) {
        nResult *= indicesShape[i];
      }
      const inputShape = tensor.shape;
      const resultShape = indicesShape.slice();
      resultShape.pop();
      let sliceSize = 1;
      for (let i = sliceRank; i < tensorRank; ++i) {
        sliceSize *= inputShape[i];
        resultShape.push(inputShape[i]);
      }
      const strides = [
        ...computeStrides(tensor.shape).map((stride) => stride / sliceSize),
        1
      ].slice(0, sliceRank);
      return [resultShape, nResult, sliceSize, strides];
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/scatter_nd_util.js
    function validateUpdateShape(shape, indices, updates) {
      const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
      const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
      const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
      if (updates.rank < batchDim) {
        throw new Error(shapeError + ` update.rank < ${batchDim}. `);
      }
      if (shape.length < sliceDim + (updates.rank - batchDim)) {
        throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
      }
      if (updates.rank !== batchDim + shape.length - sliceDim) {
        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
      }
      for (let d = 0; d < batchDim; ++d) {
        if (updates.shape[d] !== indices.shape[d]) {
          throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
        }
      }
      for (let d = 0; d < updates.rank - batchDim; ++d) {
        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
          throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
        }
      }
    }
    function validateInput(updates, indices, shape) {
      if (indices.rank < 1) {
        throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
      }
      if (updates.rank < 1) {
        throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
      }
      if (indices.dtype !== "int32") {
        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
      }
      if (shape.length < 1) {
        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
      }
      if (shape.length === 0) {
        if (indices.size === 0) {
          throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
        }
        if (updates.size === 0) {
          throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
        }
      }
      validateUpdateShape(shape, indices, updates);
    }
    function calculateShapes(updates, indices, shape) {
      const indicesRank = indices.shape.length;
      const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
      const totalNd = shape.length;
      let sliceSize = 1;
      for (let i = sliceRank; i < totalNd; ++i) {
        sliceSize *= shape[i];
      }
      const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
      const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
      const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
      const outputSize = sizeFromShape(shape);
      return { sliceRank, numUpdates, sliceSize, strides, outputSize };
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/slice_util.js
    var slice_util_exports = {};
    __export(slice_util_exports, {
      assertParamsValid: () => assertParamsValid,
      computeFlatOffset: () => computeFlatOffset,
      computeOutShape: () => computeOutShape,
      getNormalizedAxes: () => getNormalizedAxes,
      isSliceContinous: () => isSliceContinous,
      maskToAxes: () => maskToAxes,
      parseSliceParams: () => parseSliceParams,
      sliceInfo: () => sliceInfo,
      startForAxis: () => startForAxis,
      startIndicesWithElidedDims: () => startIndicesWithElidedDims,
      stopForAxis: () => stopForAxis,
      stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
      stridesForAxis: () => stridesForAxis,
      stridesWithElidedDims: () => stridesWithElidedDims
    });
    function assertParamsValid(input, begin, size) {
      const inputRank = input.shape.length;
      assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
      assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
      for (let i = 0; i < inputRank; ++i) {
        assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
      }
    }
    function maskToAxes(mask) {
      const axes = [];
      let axis = 0;
      while (mask > 0) {
        if (mask & 1) {
          axes.push(axis);
        }
        mask /= 2;
        axis++;
      }
      return axes;
    }
    function computeOutShape(begin, end, strides) {
      const size = [];
      for (let axis = 0; axis < begin.length; axis++) {
        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
      }
      return size;
    }
    function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
      const newStrides = [...strides];
      for (let i = newStrides.length; i < inputShape.length; i++) {
        newStrides.push(1);
      }
      for (let i = 0; i < numElidedAxes; i++) {
        if (i === 0) {
          newStrides[ellipsisInsertionIndex] = 1;
        } else {
          newStrides.splice(ellipsisInsertionIndex, 0, 1);
          newStrides.pop();
        }
      }
      return newStrides;
    }
    function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
      if (normalizedAxis <= ellipsisInsertionIndex) {
        return normalizedAxis;
      }
      return normalizedAxis - (numElidedAxes - 1);
    }
    function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
      const elidedAxes = [];
      for (let i = 0; i < numElidedAxes; i++) {
        elidedAxes.push(ellipsisInsertionIndex + i);
      }
      return elidedAxes;
    }
    function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
      const inputRank = inputShape.length;
      let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
      if (ellipsisAxes.length && numInterpolatedAxes > 0) {
        const fullIndex = ellipsisAxes[0];
        const numElidedAxes = numInterpolatedAxes + 1;
        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
        normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
      } else {
        for (let axis = 0; axis < inputRank; axis++) {
          normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
          normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
          normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
        }
      }
      return {
        begin: normalizedBegin,
        end: normalizedEnd,
        strides: normalizedStrides
      };
    }
    function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
      const newIndices = [...inputShape];
      const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
      for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
          newIndices[axis] = 0;
        } else {
          const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
          let originalValue = originalBegin[originalAxis];
          if (beginMask & 1 << originalAxis) {
            originalValue = 0;
          }
          newIndices[axis] = originalValue;
        }
      }
      return newIndices;
    }
    function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
      const newIndices = [...inputShape];
      const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
      for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
          newIndices[axis] = Number.MAX_SAFE_INTEGER;
        } else {
          const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
          let originalValue = originalEnd[originalAxis];
          if (endMask & 1 << originalAxis) {
            originalValue = Number.MAX_SAFE_INTEGER;
          }
          newIndices[axis] = originalValue;
        }
      }
      for (let i = 0; i < newIndices.length; i++) {
        const axisSize = inputShape[i];
        if (newIndices[i] < 0) {
          newIndices[i] += axisSize;
        }
        newIndices[i] = clamp(0, newIndices[i], inputShape[i]);
      }
      return newIndices;
    }
    function stridesForAxis(strides, axis, ellipsisMask) {
      let stride = strides[axis];
      if (ellipsisMask & 1 << axis || stride == null) {
        stride = 1;
      }
      return stride;
    }
    function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
      let start = startIndices[axis];
      const stride = strides[axis] || 1;
      if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
        if (stride > 0) {
          start = Number.MIN_SAFE_INTEGER;
        } else {
          start = Number.MAX_SAFE_INTEGER;
        }
      }
      const axisSize = inputShape[axis];
      if (start < 0) {
        start += axisSize;
      }
      start = clamp(0, start, axisSize - 1);
      return start;
    }
    function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
      let stop = stopIndices[axis];
      const stride = strides[axis] || 1;
      if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
        if (stride > 0) {
          stop = Number.MAX_SAFE_INTEGER;
        } else {
          stop = Number.MIN_SAFE_INTEGER;
        }
      }
      const axisSize = inputShape[axis];
      if (stop < 0) {
        stop += axisSize;
      }
      if (stride > 0) {
        stop = clamp(0, stop, axisSize);
      } else {
        stop = clamp(-1, stop, axisSize - 1);
      }
      return stop;
    }
    function isSliceContinous(shape, begin, size) {
      let firstNonOneAxis = size.length;
      for (let i = 0; i < size.length; i++) {
        if (size[i] > 1) {
          firstNonOneAxis = i;
          break;
        }
      }
      for (let i = firstNonOneAxis + 1; i < size.length; i++) {
        if (begin[i] > 0 || size[i] !== shape[i]) {
          return false;
        }
      }
      return true;
    }
    function computeFlatOffset(begin, strides) {
      let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
      for (let i = 0; i < begin.length - 1; i++) {
        flatOffset += begin[i] * strides[i];
      }
      return flatOffset;
    }
    function parseSliceParams(x, begin, size) {
      let begin_;
      const xRank = x.shape.length;
      if (typeof begin === "number") {
        begin_ = [begin, ...new Array(xRank - 1).fill(0)];
      } else if (begin.length < xRank) {
        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
      } else {
        begin_ = begin.slice();
      }
      begin_.forEach((d) => {
        assert(d !== -1, () => "slice() does not support negative begin indexing.");
      });
      let size_;
      if (size == null) {
        size_ = new Array(xRank).fill(-1);
      } else if (typeof size === "number") {
        size_ = [size, ...new Array(xRank - 1).fill(-1)];
      } else if (size.length < xRank) {
        size_ = size.concat(new Array(xRank - size.length).fill(-1));
      } else {
        size_ = size;
      }
      size_ = size_.map((d, i) => {
        if (d >= 0) {
          return d;
        } else {
          assert(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
          return x.shape[i] - begin_[i];
        }
      });
      return [begin_, size_];
    }
    function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
      let $begin = begin.slice();
      let $end = end.slice();
      let $strides = strides;
      if (strides == null) {
        $strides = new Array($begin.length);
      }
      const ellipsisAxes = maskToAxes(ellipsisMask);
      if (ellipsisAxes.length > 1) {
        throw new Error("Multiple ellipses in slice is not allowed.");
      }
      if (ellipsisMask !== 0 && newAxisMask !== 0) {
        throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
      }
      if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
        throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
      }
      const numInterpolatedAxes = xShape.length - $begin.length;
      const expandAxes = maskToAxes(newAxisMask);
      const newShape = xShape.slice();
      expandAxes.forEach((axis) => {
        $begin[axis] = 0;
        $end[axis] = 1;
        newShape.splice(axis, 0, 1);
      });
      const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);
      $begin = normalizedBegin;
      $end = normalizedEnd;
      $strides = normalizedStrides;
      const shrinkAxes = maskToAxes(shrinkAxisMask);
      shrinkAxes.forEach((axis) => {
        $end[axis] = $begin[axis] + 1;
        $strides[axis] = 1;
      });
      const size = computeOutShape($begin, $end, $strides);
      const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);
      const nonStrided = $strides.every((v) => v === 1);
      return { nonStrided, $begin, $end, $strides, size, newShape, outShape };
    }
  
    // ../../../tfjs/tfjs-core/dist/globals.js
    function deprecationWarn(msg) {
      if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
        console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
      }
    }
    setDeprecationWarningFn(deprecationWarn);
    function engine() {
      return ENGINE;
    }
    function tidy(nameOrFn, fn) {
      return ENGINE.tidy(nameOrFn, fn);
    }
    function registerBackend(name, factory, priority = 1) {
      return ENGINE.registerBackend(name, factory, priority);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/mul.js
    function mul_(a, b) {
      let $a = convertToTensor(a, "a", "mul");
      let $b = convertToTensor(b, "b", "mul");
      [$a, $b] = makeTypesMatch($a, $b);
      const inputs = { a: $a, b: $b };
      return ENGINE.runKernel(Multiply, inputs);
    }
    var mul = op({ mul_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/conv_util.js
    function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = "NHWC", dilations) {
      const inputChannels = inputShape[3];
      const $filterShape = [...filterShape, inputChannels];
      const $dataFormat = convertConv2DDataFormat(dataFormat);
      return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null, null, $dataFormat);
    }
    function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = "channelsLast") {
      const [filterHeight, filterWidth] = parseTupleParam(filterSize);
      let filterShape;
      if (dataFormat === "channelsLast") {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
      } else if (dataFormat === "channelsFirst") {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
    }
    function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = "NDHWC") {
      const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
      let filterShape;
      let $dataFormat;
      if (dataFormat === "NDHWC") {
        $dataFormat = "channelsLast";
        filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
      } else if (dataFormat === "NCDHW") {
        $dataFormat = "channelsFirst";
        filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);
    }
    function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = "channelsLast") {
      let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
      if (dataFormat === "channelsLast") {
        [batchSize, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterHeight, filterWidth, , filterChannels] = filterShape;
      const [strideHeight, strideWidth] = parseTupleParam(strides);
      const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
      const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
      const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape;
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inHeight,
        inWidth,
        inChannels,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideHeight,
        strideWidth,
        filterHeight,
        filterWidth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    }
    function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = "channelsLast", roundingMode) {
      let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
      if (dataFormat === "channelsLast") {
        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
      const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
      const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
      const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
      const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
      const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape;
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inDepth,
        inHeight,
        inWidth,
        inChannels,
        outDepth,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideDepth,
        strideHeight,
        strideWidth,
        filterDepth,
        filterHeight,
        filterWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationDepth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    }
    function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
      }
      const inputRows = inShape[0];
      const inputCols = inShape[1];
      const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      return [outputRows, outputCols];
    }
    function computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
      }
      const inputDepth = inShape[0];
      const inputRows = inShape[1];
      const inputCols = inShape[2];
      const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      return [outputDepths, outputRows, outputCols, outChannels];
    }
    function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
      const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
      return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
    }
    function parseTupleParam(param) {
      if (typeof param === "number") {
        return [param, param, param];
      }
      if (param.length === 2) {
        return [param[0], param[1], 1];
      }
      return param;
    }
    function parse3TupleParam(param) {
      return typeof param === "number" ? [param, param, param] : param;
    }
    function getEffectiveFilterSize(filterSize, dilation) {
      if (dilation <= 1) {
        return filterSize;
      }
      return filterSize + (filterSize - 1) * (dilation - 1);
    }
    function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
      let padInfo;
      let outHeight;
      let outWidth;
      if (typeof pad === "number") {
        const padType = pad === 0 ? "VALID" : "NUMBER";
        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
        const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
      } else if (pad === "same") {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, type: "SAME" };
      } else if (pad === "valid") {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
      } else if (typeof pad === "object") {
        const top = dataFormat === "channelsLast" ? pad[1][0] : pad[2][0];
        const bottom = dataFormat === "channelsLast" ? pad[1][1] : pad[2][1];
        const left = dataFormat === "channelsLast" ? pad[2][0] : pad[3][0];
        const right = dataFormat === "channelsLast" ? pad[2][1] : pad[3][1];
        const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
        padInfo = { top, bottom, left, right, type: padType };
        outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
        outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
      } else {
        throw Error(`Unknown padding parameter: ${pad}`);
      }
      return { padInfo, outHeight, outWidth };
    }
    function get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
      let padInfo;
      let outDepth;
      let outHeight;
      let outWidth;
      if (typeof pad === "number") {
        const padType = pad === 0 ? "VALID" : "NUMBER";
        padInfo = {
          top: pad,
          bottom: pad,
          left: pad,
          right: pad,
          front: pad,
          back: pad,
          type: padType
        };
        const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (pad === "same") {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, front, back, type: "SAME" };
      } else if (pad === "valid") {
        padInfo = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          front: 0,
          back: 0,
          type: "VALID"
        };
        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
      } else {
        throw Error(`Unknown padding parameter: ${pad}`);
      }
      return { padInfo, outDepth, outHeight, outWidth };
    }
    function round(value, roundingMode) {
      if (!roundingMode) {
        return Math.trunc(value);
      }
      switch (roundingMode) {
        case "round":
          return Math.round(value);
        case "ceil":
          return Math.ceil(value);
        case "floor":
          return Math.floor(value);
        default:
          throw new Error(`Unknown roundingMode ${roundingMode}`);
      }
    }
    function tupleValuesAreOne(param) {
      const [dimA, dimB, dimC] = parseTupleParam(param);
      return dimA === 1 && dimB === 1 && dimC === 1;
    }
    function eitherStridesOrDilationsAreOne(strides, dilations) {
      return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
    }
    function convertConv2DDataFormat(dataFormat) {
      if (dataFormat === "NHWC") {
        return "channelsLast";
      } else if (dataFormat === "NCHW") {
        return "channelsFirst";
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/reshape.js
    function reshape_(x, shape) {
      const $x = convertToTensor(x, "x", "reshape", "string_or_numeric");
      const inputs = { x: $x };
      const attrs = { shape };
      return ENGINE.runKernel(Reshape, inputs, attrs);
    }
    var reshape = op({ reshape_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/sigmoid.js
    function sigmoid_(x) {
      const $x = convertToTensor(x, "x", "sigmoid");
      const inputs = { x: $x };
      return ENGINE.runKernel(Sigmoid, inputs);
    }
    var sigmoid = op({ sigmoid_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/broadcast_util.js
    function getBroadcastDims(inShape, outShape) {
      const inRank = inShape.length;
      const dims = [];
      for (let i = 0; i < inRank; i++) {
        const dim = inRank - 1 - i;
        const a = inShape[dim] || 1;
        const b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
          dims.unshift(dim);
        }
      }
      return dims;
    }
    function getReductionAxes(inShape, outShape) {
      const result2 = [];
      for (let i = 0; i < outShape.length; i++) {
        const inDim = inShape[inShape.length - i - 1];
        const outAxis = outShape.length - i - 1;
        const outDim = outShape[outAxis];
        if (inDim == null || inDim === 1 && outDim > 1) {
          result2.unshift(outAxis);
        }
      }
      return result2;
    }
    function assertAndGetBroadcastShape(shapeA, shapeB) {
      const result2 = [];
      const l = Math.max(shapeA.length, shapeB.length);
      for (let i = 0; i < l; i++) {
        let a = shapeA[shapeA.length - i - 1];
        if (a == null) {
          a = 1;
        }
        let b = shapeB[shapeB.length - i - 1];
        if (b == null) {
          b = 1;
        }
        if (a === 1) {
          result2.unshift(b);
        } else if (b === 1) {
          result2.unshift(a);
        } else if (a !== b) {
          const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
          throw Error(errMsg);
        } else {
          result2.unshift(a);
        }
      }
      return result2;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/elu.js
    function elu_(x) {
      const $x = convertToTensor(x, "x", "elu");
      const inputs = { x: $x };
      return ENGINE.runKernel(Elu, inputs);
    }
    var elu = op({ elu_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/leaky_relu.js
    function leakyRelu_(x, alpha = 0.2) {
      const $x = convertToTensor(x, "x", "leakyRelu");
      const inputs = { x: $x };
      const attrs = { alpha };
      return ENGINE.runKernel(LeakyRelu, inputs, attrs);
    }
    var leakyRelu = op({ leakyRelu_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/sum.js
    function sum_(x, axis = null, keepDims = false) {
      let $x = convertToTensor(x, "x", "sum");
      if ($x.dtype === "bool") {
        $x = cast($x, "int32");
      }
      const inputs = { x: $x };
      const attrs = { axis, keepDims };
      return ENGINE.runKernel(Sum, inputs, attrs);
    }
    var sum2 = op({ sum_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/axis_util.js
    function axesAreInnerMostDims(axes, rank) {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    }
    function combineLocations(outputLoc, reduceLoc, axes) {
      const rank = outputLoc.length + reduceLoc.length;
      const loc = [];
      let outIdx = 0;
      let reduceIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          loc.push(outputLoc[outIdx++]);
        } else {
          loc.push(reduceLoc[reduceIdx++]);
        }
      }
      return loc;
    }
    function computeOutAndReduceShapes(aShape, axes) {
      const outShape = [];
      const rank = aShape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outShape.push(aShape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => aShape[dim]);
      return [outShape, reduceShape];
    }
    function expandShapeToKeepDim(shape, axes) {
      const reduceSubShape = axes.map((x) => 1);
      return combineLocations(shape, reduceSubShape, axes);
    }
    function assertAxesAreInnerMostDims(msg, axes, rank) {
      assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
    }
    function getAxesPermutation(axes, rank) {
      if (axesAreInnerMostDims(axes, rank)) {
        return null;
      }
      const result2 = [];
      for (let i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
          result2.push(i);
        }
      }
      axes.forEach((axis) => result2.push(axis));
      return result2;
    }
    function getUndoAxesPermutation(axes) {
      return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
    }
    function getInnerMostAxes(numAxes, rank) {
      const res = [];
      for (let i = rank - numAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/zeros.js
    function zeros(shape, dtype = "float32") {
      if (dtype === "complex64") {
        const real3 = zeros(shape, "float32");
        const imag2 = zeros(shape, "float32");
        return complex(real3, imag2);
      }
      const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
      return ENGINE.makeTensor(values, shape, dtype);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/prelu.js
    function prelu_(x, alpha) {
      const $x = convertToTensor(x, "x", "prelu");
      const $alpha = convertToTensor(alpha, "alpha", "prelu");
      const inputs = { x: $x, alpha: $alpha };
      return ENGINE.runKernel(Prelu, inputs);
    }
    var prelu = op({ prelu_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/relu.js
    function relu_(x) {
      const $x = convertToTensor(x, "x", "relu");
      const inputs = { x: $x };
      return ENGINE.runKernel(Relu, inputs);
    }
    var relu = op({ relu_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/relu6.js
    function relu6_(x) {
      const $x = convertToTensor(x, "x", "relu6");
      const inputs = { x: $x };
      return ENGINE.runKernel(Relu6, inputs);
    }
    var relu6 = op({ relu6_ });
  
    // ../../../tfjs/tfjs-core/dist/ops/scalar.js
    function scalar(value, dtype) {
      if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
        throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
      }
      if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
        throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
      }
      const shape = [];
      const inferredShape = [];
      return makeTensor(value, shape, inferredShape, dtype);
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/step.js
    function step_(x, alpha = 0) {
      const $x = convertToTensor(x, "x", "step");
      const inputs = { x: $x };
      const attrs = { alpha };
      return ENGINE.runKernel(Step, inputs, attrs);
    }
    var step = op({ step_ });
  
    // ../../../tfjs/tfjs-core/dist/backends/where_impl.js
    function whereImpl(condShape, condVals) {
      const indices = [];
      for (let i = 0; i < condVals.length; i++) {
        if (condVals[i]) {
          indices.push(i);
        }
      }
      const inBuffer = buffer(condShape, "int32");
      const out = buffer([indices.length, condShape.length], "int32");
      for (let i = 0; i < indices.length; i++) {
        const loc = inBuffer.indexToLoc(indices[i]);
        const offset = i * condShape.length;
        out.values.set(loc, offset);
      }
      return out.toTensor();
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/fused_util.js
    function getFusedDyActivation(dy, y, activation) {
      if (activation == null || activation === "linear") {
        return dy;
      }
      if (activation === "relu") {
        return mul(dy, step(y));
      }
      throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
    }
    function getFusedBiasGradient(bias, dyActivation) {
      let res = dyActivation;
      const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
      if (reduceAxes.length > 0) {
        res = sum2(res, reduceAxes);
      }
      return reshape(res, bias.shape);
    }
    function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
      if (activation === "linear") {
        return x;
      } else if (activation === "relu") {
        return relu(x);
      } else if (activation === "elu") {
        return elu(x);
      } else if (activation === "relu6") {
        return relu6(x);
      } else if (activation === "prelu") {
        return prelu(x, preluActivationWeights);
      } else if (activation === "leakyrelu") {
        return leakyRelu(x, leakyreluAlpha);
      } else if (activation === "sigmoid") {
        return sigmoid(x);
      }
      throw new Error(`Unknown fused activation ${activation}.`);
    }
    var shouldFuse = (gradientDepth, activation) => {
      const gradientMode = gradientDepth > 0;
      return !gradientMode || activation === "linear";
    };
  
    // ../../../tfjs/tfjs-core/dist/backends/non_max_suppression_util.js
    function binaryInsert(arr, element, comparator) {
      const index2 = binarySearch(arr, element, comparator);
      const insertionPoint = index2 < 0 ? -(index2 + 1) : index2;
      arr.splice(insertionPoint, 0, element);
    }
    function binarySearch(arr, target, comparator) {
      return binarySearch_(arr, target, comparator || defaultComparator);
    }
    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function binarySearch_(arr, target, comparator) {
      let left = 0;
      let right = arr.length;
      let middle = 0;
      let found = false;
      while (left < right) {
        middle = left + (right - left >>> 1);
        const compareResult = comparator(target, arr[middle]);
        if (compareResult > 0) {
          left = middle + 1;
        } else {
          right = middle;
          found = !compareResult;
        }
      }
      return found ? left : -left - 1;
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/non_max_suppression_impl.js
    function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);
    }
    function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
    }
    function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
    }
    function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
      const candidates = [];
      for (let i = 0; i < scores.length; i++) {
        if (scores[i] > scoreThreshold) {
          candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
        }
      }
      candidates.sort(ascendingComparator);
      const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
      const selectedIndices = [];
      const selectedScores = [];
      while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
        const candidate = candidates.pop();
        const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
        if (originalScore < scoreThreshold) {
          break;
        }
        let ignoreCandidate = false;
        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {
          const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
          if (iou >= iouThreshold) {
            ignoreCandidate = true;
            break;
          }
          candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);
          if (candidate.score <= scoreThreshold) {
            break;
          }
        }
        candidate.suppressBeginIndex = selectedIndices.length;
        if (!ignoreCandidate) {
          if (candidate.score === originalScore) {
            selectedIndices.push(boxIndex);
            selectedScores.push(candidate.score);
          } else if (candidate.score > scoreThreshold) {
            binaryInsert(candidates, candidate, ascendingComparator);
          }
        }
      }
      const validOutputs = selectedIndices.length;
      const elemsToPad = maxOutputSize - validOutputs;
      if (padToMaxOutputSize && elemsToPad > 0) {
        selectedIndices.push(...new Array(elemsToPad).fill(0));
        selectedScores.push(...new Array(elemsToPad).fill(0));
      }
      const result2 = { selectedIndices };
      if (returnScoresTensor) {
        result2["selectedScores"] = selectedScores;
      }
      if (returnValidOutputs) {
        result2["validOutputs"] = validOutputs;
      }
      return result2;
    }
    function intersectionOverUnion(boxes, i, j) {
      const iCoord = boxes.subarray(i * 4, i * 4 + 4);
      const jCoord = boxes.subarray(j * 4, j * 4 + 4);
      const yminI = Math.min(iCoord[0], iCoord[2]);
      const xminI = Math.min(iCoord[1], iCoord[3]);
      const ymaxI = Math.max(iCoord[0], iCoord[2]);
      const xmaxI = Math.max(iCoord[1], iCoord[3]);
      const yminJ = Math.min(jCoord[0], jCoord[2]);
      const xminJ = Math.min(jCoord[1], jCoord[3]);
      const ymaxJ = Math.max(jCoord[0], jCoord[2]);
      const xmaxJ = Math.max(jCoord[1], jCoord[3]);
      const areaI = (ymaxI - yminI) * (xmaxI - xminI);
      const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
      if (areaI <= 0 || areaJ <= 0) {
        return 0;
      }
      const intersectionYmin = Math.max(yminI, yminJ);
      const intersectionXmin = Math.max(xminI, xminJ);
      const intersectionYmax = Math.min(ymaxI, ymaxJ);
      const intersectionXmax = Math.min(xmaxI, xmaxJ);
      const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
      return intersectionArea / (areaI + areaJ - intersectionArea);
    }
    function suppressWeight(iouThreshold, scale, iou) {
      const weight = Math.exp(scale * iou * iou);
      return iou <= iouThreshold ? weight : 0;
    }
    function ascendingComparator(c1, c2) {
      return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/backend_util.js
    var backend_util_exports = {};
    __export(backend_util_exports, {
      ERF_A1: () => ERF_A1,
      ERF_A2: () => ERF_A2,
      ERF_A3: () => ERF_A3,
      ERF_A4: () => ERF_A4,
      ERF_A5: () => ERF_A5,
      ERF_P: () => ERF_P,
      PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
      SELU_SCALE: () => SELU_SCALE,
      SELU_SCALEALPHA: () => SELU_SCALEALPHA,
      applyActivation: () => applyActivation,
      assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
      assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
      assertParamsConsistent: () => assertParamsConsistent,
      assignToTypedArray: () => assignToTypedArray,
      axesAreInnerMostDims: () => axesAreInnerMostDims,
      calculateShapes: () => calculateShapes,
      checkEinsumDimSizes: () => checkEinsumDimSizes,
      combineLocations: () => combineLocations,
      complexWithEvenIndex: () => complexWithEvenIndex,
      complexWithOddIndex: () => complexWithOddIndex,
      computeConv2DInfo: () => computeConv2DInfo,
      computeConv3DInfo: () => computeConv3DInfo,
      computeDefaultPad: () => computeDefaultPad,
      computeDilation2DInfo: () => computeDilation2DInfo,
      computeOptimalWindowSize: () => computeOptimalWindowSize,
      computeOutAndReduceShapes: () => computeOutAndReduceShapes,
      computeOutShape: () => computeOutShape2,
      computePool2DInfo: () => computePool2DInfo,
      computePool3DInfo: () => computePool3DInfo,
      convertConv2DDataFormat: () => convertConv2DDataFormat,
      decodeEinsumEquation: () => decodeEinsumEquation,
      eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
      expandShapeToKeepDim: () => expandShapeToKeepDim,
      exponent: () => exponent,
      exponents: () => exponents,
      fromStringArrayToUint8: () => fromStringArrayToUint8,
      fromUint8ToStringArray: () => fromUint8ToStringArray,
      getAxesPermutation: () => getAxesPermutation,
      getBroadcastDims: () => getBroadcastDims,
      getComplexWithIndex: () => getComplexWithIndex,
      getEinsumComputePath: () => getEinsumComputePath,
      getEinsumPermutation: () => getEinsumPermutation,
      getFusedBiasGradient: () => getFusedBiasGradient,
      getFusedDyActivation: () => getFusedDyActivation,
      getImageCenter: () => getImageCenter,
      getInnerMostAxes: () => getInnerMostAxes,
      getPermuted: () => getPermuted,
      getReductionAxes: () => getReductionAxes,
      getReshaped: () => getReshaped,
      getReshapedPermuted: () => getReshapedPermuted,
      getSliceBeginCoords: () => getSliceBeginCoords,
      getSliceSize: () => getSliceSize,
      getUndoAxesPermutation: () => getUndoAxesPermutation,
      isIdentityPermutation: () => isIdentityPermutation,
      log: () => log,
      mergeRealAndImagArrays: () => mergeRealAndImagArrays,
      prepareAndValidate: () => prepareAndValidate,
      prepareSplitSize: () => prepareSplitSize,
      segment_util: () => segment_util_exports,
      shouldFuse: () => shouldFuse,
      slice_util: () => slice_util_exports,
      splitRealAndImagArrays: () => splitRealAndImagArrays,
      tupleValuesAreOne: () => tupleValuesAreOne,
      upcastType: () => upcastType,
      validateInput: () => validateInput,
      validateUpdateShape: () => validateUpdateShape,
      warn: () => warn
    });
  
    // ../../../tfjs/tfjs-core/dist/ops/concat_util.js
    function assertParamsConsistent(shapes, axis) {
      const rank = shapes[0].length;
      shapes.forEach((shape, i) => {
        assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
      });
      assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
      const firstShape = shapes[0];
      shapes.forEach((shape, i) => {
        for (let r = 0; r < rank; r++) {
          assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
        }
      });
    }
    function computeOutShape2(shapes, axis) {
      const outputShape = shapes[0].slice();
      for (let i = 1; i < shapes.length; i++) {
        outputShape[axis] += shapes[i][axis];
      }
      return outputShape;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/reduce_util.js
    var PARALLELIZE_THRESHOLD = 30;
    function computeOptimalWindowSize(inSize) {
      if (inSize <= PARALLELIZE_THRESHOLD) {
        return inSize;
      }
      return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/rotate_util.js
    function getImageCenter(center, imageHeight, imageWidth) {
      const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
      const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
      return [centerX, centerY];
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/array_ops_util.js
    function getReshaped(inputShape, blockShape, prod2, batchToSpace = true) {
      let reshaped = [];
      if (batchToSpace) {
        reshaped = reshaped.concat(blockShape.slice(0));
        reshaped.push(inputShape[0] / prod2);
        reshaped = reshaped.concat(inputShape.slice(1));
      } else {
        reshaped = reshaped.concat(inputShape[0]);
        const spatialLength = blockShape.length;
        for (let i = 0; i < spatialLength; ++i) {
          reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
        }
        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
      }
      return reshaped;
    }
    function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
      const permuted = [];
      if (batchToSpace) {
        permuted.push(blockShapeRank);
        for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
          if (i <= 2 * blockShapeRank) {
            permuted.push(i);
            permuted.push(i - (blockShapeRank + 1));
          } else {
            permuted.push(i);
          }
        }
      } else {
        const permutedBeforeBatch = [];
        const permutedAfterBatch = [];
        for (let i = 1; i < reshapedRank; ++i) {
          if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
            permutedAfterBatch.push(i);
          } else {
            permutedBeforeBatch.push(i);
          }
        }
        permuted.push(...permutedBeforeBatch);
        permuted.push(0);
        permuted.push(...permutedAfterBatch);
      }
      return permuted;
    }
    function getReshapedPermuted(inputShape, blockShape, prod2, batchToSpace = true) {
      const reshapedPermuted = [];
      if (batchToSpace) {
        reshapedPermuted.push(inputShape[0] / prod2);
      } else {
        reshapedPermuted.push(inputShape[0] * prod2);
      }
      for (let i = 1; i < inputShape.length; ++i) {
        if (i <= blockShape.length) {
          if (batchToSpace) {
            reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
          } else {
            reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
          }
        } else {
          reshapedPermuted.push(inputShape[i]);
        }
      }
      return reshapedPermuted;
    }
    function getSliceBeginCoords(crops, blockShape) {
      const sliceBeginCoords = [0];
      for (let i = 0; i < blockShape; ++i) {
        sliceBeginCoords.push(crops[i][0]);
      }
      return sliceBeginCoords;
    }
    function getSliceSize(uncroppedShape, crops, blockShape) {
      const sliceSize = uncroppedShape.slice(0, 1);
      for (let i = 0; i < blockShape; ++i) {
        sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
      }
      return sliceSize;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/selu_util.js
    var SELU_SCALEALPHA = 1.7580993408473768;
    var SELU_SCALE = 1.0507009873554805;
  
    // ../../../tfjs/tfjs-core/dist/ops/erf_util.js
    var ERF_P = 0.3275911;
    var ERF_A1 = 0.254829592;
    var ERF_A2 = -0.284496736;
    var ERF_A3 = 1.421413741;
    var ERF_A4 = -1.453152027;
    var ERF_A5 = 1.061405429;
  
    // ../../../tfjs/tfjs-core/dist/log.js
    function warn(...msg) {
      if (!env().getBool("IS_TEST")) {
        console.warn(...msg);
      }
    }
    function log(...msg) {
      if (!env().getBool("IS_TEST")) {
        console.log(...msg);
      }
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/complex_util.js
    function mergeRealAndImagArrays(real3, imag2) {
      if (real3.length !== imag2.length) {
        throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real3.length}, imag: ${imag2.length}.`);
      }
      const result2 = new Float32Array(real3.length * 2);
      for (let i = 0; i < result2.length; i += 2) {
        result2[i] = real3[i / 2];
        result2[i + 1] = imag2[i / 2];
      }
      return result2;
    }
    function splitRealAndImagArrays(complex4) {
      const real3 = new Float32Array(complex4.length / 2);
      const imag2 = new Float32Array(complex4.length / 2);
      for (let i = 0; i < complex4.length; i += 2) {
        real3[i / 2] = complex4[i];
        imag2[i / 2] = complex4[i + 1];
      }
      return { real: real3, imag: imag2 };
    }
    function complexWithEvenIndex(complex4) {
      const len = Math.ceil(complex4.length / 4);
      const real3 = new Float32Array(len);
      const imag2 = new Float32Array(len);
      for (let i = 0; i < complex4.length; i += 4) {
        real3[Math.floor(i / 4)] = complex4[i];
        imag2[Math.floor(i / 4)] = complex4[i + 1];
      }
      return { real: real3, imag: imag2 };
    }
    function complexWithOddIndex(complex4) {
      const len = Math.floor(complex4.length / 4);
      const real3 = new Float32Array(len);
      const imag2 = new Float32Array(len);
      for (let i = 2; i < complex4.length; i += 4) {
        real3[Math.floor(i / 4)] = complex4[i];
        imag2[Math.floor(i / 4)] = complex4[i + 1];
      }
      return { real: real3, imag: imag2 };
    }
    function getComplexWithIndex(complex4, index2) {
      const real3 = complex4[index2 * 2];
      const imag2 = complex4[index2 * 2 + 1];
      return { real: real3, imag: imag2 };
    }
    function assignToTypedArray(data, real3, imag2, index2) {
      data[index2 * 2] = real3;
      data[index2 * 2 + 1] = imag2;
    }
    function exponents(n, inverse) {
      const real3 = new Float32Array(n / 2);
      const imag2 = new Float32Array(n / 2);
      for (let i = 0; i < Math.ceil(n / 2); i++) {
        const x = (inverse ? 2 : -2) * Math.PI * (i / n);
        real3[i] = Math.cos(x);
        imag2[i] = Math.sin(x);
      }
      return { real: real3, imag: imag2 };
    }
    function exponent(k, n, inverse) {
      const x = (inverse ? 2 : -2) * Math.PI * (k / n);
      const real3 = Math.cos(x);
      const imag2 = Math.sin(x);
      return { real: real3, imag: imag2 };
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/einsum_util.js
    var ARROW = "->";
    var ARROW_REGEX = /->/g;
    var COMMA = ",";
    var ELLIPSIS = "...";
    function decodeEinsumEquation(equation, numTensors) {
      equation = equation.replace(/\s/g, "");
      const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
      if (numArrows < 1) {
        throw new Error("Equations without an arrow are not supported.");
      } else if (numArrows > 1) {
        throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
      }
      const [inputString, outputString] = equation.split(ARROW);
      assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
      const inputTerms = inputString.split(COMMA);
      const numInputs = inputTerms.length;
      if (numTensors !== numInputs) {
        throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
      }
      if (numInputs > 2) {
        throw new Error("Support for more than 2 input tensors is not implemented yet.");
      }
      const allDims = [];
      for (let i = 0; i < outputString.length; ++i) {
        const dimName = outputString[i];
        if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
          throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
        }
        if (allDims.indexOf(dimName) === -1) {
          allDims.push(dimName);
        }
      }
      for (let i = 0; i < inputString.length; ++i) {
        const dimName = inputString[i];
        if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
          allDims.push(dimName);
        }
      }
      const idDims = new Array(inputTerms.length);
      for (let i = 0; i < numInputs; ++i) {
        if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
          throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. Support for duplicate axes in input is not implemented yet.`);
        }
        idDims[i] = [];
        for (let j = 0; j < inputTerms[i].length; ++j) {
          idDims[i].push(allDims.indexOf(inputTerms[i][j]));
        }
      }
      const numDims = allDims.length;
      const numOutDims = outputString.length;
      const summedDims = [];
      for (let i = numOutDims; i < numDims; ++i) {
        summedDims.push(i);
      }
      return { allDims, summedDims, idDims };
    }
    function getEinsumPermutation(nDims, idDims) {
      let permutationIndices = new Array(nDims);
      permutationIndices.fill(-1);
      for (let i = 0; i < idDims.length; ++i) {
        permutationIndices[idDims[i]] = i;
      }
      const expandDims3 = [];
      for (let i = 0; i < nDims; ++i) {
        if (permutationIndices[i] === -1) {
          expandDims3.push(i);
        }
      }
      permutationIndices = permutationIndices.filter((d) => d !== -1);
      return { permutationIndices, expandDims: expandDims3 };
    }
    function checkEinsumDimSizes(nDims, idDims, tensors) {
      const dimSizes = new Array(nDims);
      for (let i = 0; i < tensors.length; ++i) {
        const shape = tensors[i].shape;
        for (let j = 0; j < idDims[i].length; ++j) {
          if (dimSizes[idDims[i][j]] === void 0) {
            dimSizes[idDims[i][j]] = shape[j];
          } else {
            assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j]}`);
          }
        }
      }
    }
    function getEinsumComputePath(summedDims, idDims) {
      const path = summedDims;
      const steps = [];
      let nSteps = 0;
      if (summedDims.length === 0) {
        path.push(-1);
      }
      nSteps = summedDims.length + 1;
      for (let i = 0; i < nSteps; ++i) {
        steps.push([]);
      }
      const computedTermIndices = [];
      for (let i = 0; i < path.length; ++i) {
        const summedDim = path[i];
        const termIndices = findTermsWithDim(idDims, summedDim);
        for (const termIndex of termIndices) {
          if (computedTermIndices.indexOf(termIndex) === -1) {
            steps[i].push(termIndex);
            computedTermIndices.push(termIndex);
          }
        }
      }
      return { path, steps };
    }
    function isIdentityPermutation(perm) {
      return perm.every((dim, index2) => dim === index2);
    }
    function findTermsWithDim(idDims, dim) {
      const termIndices = [];
      for (let i = 0; i < idDims.length; ++i) {
        if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
          termIndices.push(i);
        }
      }
      return termIndices;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/split_util.js
    function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
      let splitSizes = [];
      if (typeof numOrSizeSplits === "number") {
        assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
        splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
      } else {
        const numOfNegs = numOrSizeSplits.reduce((count, value) => {
          if (value === -1) {
            count += 1;
          }
          return count;
        }, 0);
        assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
        const negIndex = numOrSizeSplits.indexOf(-1);
        if (negIndex !== -1) {
          const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
          numOrSizeSplits[negIndex] = x.shape[axis] - total;
        }
        assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
        splitSizes = numOrSizeSplits;
      }
      return splitSizes;
    }
  
    // ../../../tfjs/tfjs-core/dist/ops/segment_util.js
    var segment_util_exports = {};
    __export(segment_util_exports, {
      collectGatherOpShapeInfo: () => collectGatherOpShapeInfo,
      computeOutShape: () => computeOutShape3,
      segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize
    });
    function segOpComputeOptimalWindowSize(inSize, numSegments) {
      let done = false;
      let res;
      if (inSize <= PARALLELIZE_THRESHOLD) {
        res = inSize;
        done = true;
      } else {
        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
      }
      while (!done) {
        if (res > numSegments || res === inSize) {
          done = true;
        } else {
          res = nearestDivisor(inSize, res + 1);
        }
      }
      return res;
    }
    function computeOutShape3(aShape, axis, numSegments) {
      const outShape = [];
      const rank = aShape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (dim !== axis) {
          outShape.push(aShape[dim]);
        } else {
          outShape.push(numSegments);
        }
      }
      return outShape;
    }
    function collectGatherOpShapeInfo(x, indices, axis, batchDims) {
      const indicesRank = indices.shape.length;
      const xRank = x.shape.length;
      if (batchDims !== 0) {
        if (batchDims < -indicesRank || batchDims > indicesRank) {
          throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
        }
      }
      if (batchDims < 0) {
        batchDims += indicesRank;
      }
      if (batchDims > xRank) {
        throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
      ${xRank}).`);
      }
      if (axis < batchDims) {
        throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
      }
      for (let i = 0; i < batchDims; ++i) {
        if (x.shape[i] !== indices.shape[i]) {
          throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
        }
      }
      const dimSize = x.shape[axis];
      const outputShape = [];
      let batchSize = 1;
      let outerSize = 1;
      let sliceSize = 1;
      for (let i = 0; i < batchDims; ++i) {
        outputShape.push(x.shape[i]);
        batchSize *= x.shape[i];
      }
      for (let i = batchDims; i < axis; i++) {
        outputShape.push(x.shape[i]);
        outerSize *= x.shape[i];
      }
      for (let i = batchDims; i < indicesRank; i++) {
        outputShape.push(indices.shape[i]);
      }
      for (let i = axis + 1; i < xRank; i++) {
        outputShape.push(x.shape[i]);
        sliceSize *= x.shape[i];
      }
      return { batchSize, sliceSize, outerSize, dimSize, outputShape };
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/backend_util.js
    function fromUint8ToStringArray(vals) {
      try {
        return vals.map((val) => decodeString(val));
      } catch (err) {
        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
      }
    }
    function fromStringArrayToUint8(strings) {
      return strings.map((s) => encodeString(s));
    }
  
    // ../../../tfjs/tfjs-core/dist/backends/kernel_impls.js
    var kernel_impls_exports = {};
    __export(kernel_impls_exports, {
      nonMaxSuppressionV3Impl: () => nonMaxSuppressionV3Impl,
      nonMaxSuppressionV4Impl: () => nonMaxSuppressionV4Impl,
      nonMaxSuppressionV5Impl: () => nonMaxSuppressionV5Impl,
      whereImpl: () => whereImpl
    });
  
    // ../../../tfjs/tfjs-backend-webgl/dist/canvas_util.js
    var contexts = {};
    var WEBGL_ATTRIBUTES = {
      alpha: false,
      antialias: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      depth: false,
      stencil: false,
      failIfMajorPerformanceCaveat: true
    };
    function setWebGLContext(webGLVersion, gl) {
      contexts[webGLVersion] = gl;
    }
    function getWebGLContext(webGLVersion) {
      if (!(webGLVersion in contexts)) {
        const newCtx = getWebGLRenderingContext(webGLVersion);
        if (newCtx !== null) {
          contexts[webGLVersion] = newCtx;
        } else {
          console.log("Could not get context for WebGL version", webGLVersion);
          return null;
        }
      }
      const gl = contexts[webGLVersion];
      if (gl.isContextLost()) {
        delete contexts[webGLVersion];
        return getWebGLContext(webGLVersion);
      }
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.disable(gl.BLEND);
      gl.disable(gl.DITHER);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.disable(gl.SAMPLE_COVERAGE);
      gl.enable(gl.SCISSOR_TEST);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      return contexts[webGLVersion];
    }
    function createCanvas(webGLVersion) {
      if (typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
        return new OffscreenCanvas(300, 150);
      } else if (typeof document !== "undefined") {
        return document.createElement("canvas");
      } else {
        throw new Error("Cannot create a canvas in this context");
      }
    }
    function getWebGLRenderingContext(webGLVersion) {
      if (webGLVersion !== 1 && webGLVersion !== 2) {
        throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
      }
      const canvas = createCanvas(webGLVersion);
      canvas.addEventListener("webglcontextlost", (ev) => {
        ev.preventDefault();
        delete contexts[webGLVersion];
      }, false);
      if (webGLVersion === 1) {
        return canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
      }
      return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/tex_util.js
    var PackingScheme;
    (function(PackingScheme2) {
      PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
      PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
    })(PackingScheme || (PackingScheme = {}));
    var TextureUsage;
    (function(TextureUsage2) {
      TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
      TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
      TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
      TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
    })(TextureUsage || (TextureUsage = {}));
    var PhysicalTextureType;
    (function(PhysicalTextureType2) {
      PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
      PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
    })(PhysicalTextureType || (PhysicalTextureType = {}));
    function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
      return [columns, rows];
    }
    function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
      return matrixSize * channelsPerTexture;
    }
    function getDenseTexShape(shape) {
      const size = util_exports.sizeFromShape(shape);
      const texelsNeeded = Math.ceil(size / 4);
      return util_exports.sizeToSquarishShape(texelsNeeded);
    }
    function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
      return [
        Math.max(1, Math.ceil(columns / 2)),
        Math.max(1, Math.ceil(rows / 2))
      ];
    }
    function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
      const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return w * h * 4;
    }
    function getTextureConfig(gl, textureHalfFloatExtension) {
      const glany = gl;
      let internalFormatFloat;
      let internalFormatHalfFloat;
      let internalFormatPackedHalfFloat;
      let internalFormatPackedFloat;
      let textureFormatFloat;
      let downloadTextureFormat;
      let downloadUnpackNumChannels;
      let defaultNumChannels;
      let textureTypeHalfFloat;
      let textureTypeFloat;
      if (env().getNumber("WEBGL_VERSION") === 2) {
        internalFormatFloat = glany.R32F;
        internalFormatHalfFloat = glany.R16F;
        internalFormatPackedHalfFloat = glany.RGBA16F;
        internalFormatPackedFloat = glany.RGBA32F;
        textureFormatFloat = glany.RED;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 1;
        textureTypeHalfFloat = glany.HALF_FLOAT;
        textureTypeFloat = glany.FLOAT;
      } else {
        internalFormatFloat = gl.RGBA;
        internalFormatHalfFloat = gl.RGBA;
        internalFormatPackedHalfFloat = gl.RGBA;
        internalFormatPackedFloat = glany.RGBA;
        textureFormatFloat = gl.RGBA;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 4;
        textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
        textureTypeFloat = gl.FLOAT;
      }
      downloadTextureFormat = gl.RGBA;
      return {
        internalFormatFloat,
        internalFormatHalfFloat,
        internalFormatPackedHalfFloat,
        internalFormatPackedFloat,
        textureFormatFloat,
        downloadTextureFormat,
        downloadUnpackNumChannels,
        defaultNumChannels,
        textureTypeHalfFloat,
        textureTypeFloat
      };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/webgl_util.js
    function callAndCheck(gl, func) {
      const returnValue = func();
      if (env().getBool("DEBUG")) {
        checkWebGLError(gl);
      }
      return returnValue;
    }
    function checkWebGLError(gl) {
      const error = gl.getError();
      if (error !== gl.NO_ERROR) {
        throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
      }
    }
    var MIN_FLOAT16 = 596e-10;
    var MAX_FLOAT16 = 65504;
    function canBeRepresented(num) {
      if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
        return true;
      }
      return false;
    }
    function getWebGLErrorMessage(gl, status) {
      switch (status) {
        case gl.NO_ERROR:
          return "NO_ERROR";
        case gl.INVALID_ENUM:
          return "INVALID_ENUM";
        case gl.INVALID_VALUE:
          return "INVALID_VALUE";
        case gl.INVALID_OPERATION:
          return "INVALID_OPERATION";
        case gl.INVALID_FRAMEBUFFER_OPERATION:
          return "INVALID_FRAMEBUFFER_OPERATION";
        case gl.OUT_OF_MEMORY:
          return "OUT_OF_MEMORY";
        case gl.CONTEXT_LOST_WEBGL:
          return "CONTEXT_LOST_WEBGL";
        default:
          return `Unknown error code ${status}`;
      }
    }
    function getExtensionOrThrow(gl, extensionName) {
      return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
    }
    function createVertexShader(gl, vertexShaderSource) {
      const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
      callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
      callAndCheck(gl, () => gl.compileShader(vertexShader));
      if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error("Failed to compile vertex shader.");
      }
      return vertexShader;
    }
    function createFragmentShader(gl, fragmentShaderSource) {
      const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
      callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
      callAndCheck(gl, () => gl.compileShader(fragmentShader));
      if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error("Failed to compile fragment shader.");
      }
      return fragmentShader;
    }
    var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
    function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
      const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
      if (lineNumberRegexResult == null) {
        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
        console.log(shaderSource);
        return;
      }
      const lineNumber = +lineNumberRegexResult[1];
      const shaderLines = shaderSource.split("\n");
      const pad = shaderLines.length.toString().length + 2;
      const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => util_exports.rightPad((lineNumber2 + 1).toString(), pad) + line);
      let maxLineLength = 0;
      for (let i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
      }
      const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
      const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
      const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
      console.log(beforeErrorLines.join("\n"));
      console.log(shaderInfoLog.split("\n")[0]);
      console.log(`%c ${util_exports.rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
      console.log(afterErrorLines.join("\n"));
    }
    function createProgram(gl) {
      return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
    }
    function linkProgram(gl, program) {
      callAndCheck(gl, () => gl.linkProgram(program));
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error("Failed to link vertex and fragment shaders.");
      }
    }
    function validateProgram(gl, program) {
      callAndCheck(gl, () => gl.validateProgram(program));
      if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error("Shader program validation failed.");
      }
    }
    function createStaticVertexBuffer(gl, data) {
      const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
      callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
      return buffer2;
    }
    function createStaticIndexBuffer(gl, data) {
      const buffer2 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
      callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer2));
      callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
      return buffer2;
    }
    function createTexture(gl) {
      return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
    }
    function validateTextureSize(width, height) {
      const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (width <= 0 || height <= 0) {
        const requested = `[${width}x${height}]`;
        throw new Error("Requested texture size " + requested + " is invalid.");
      }
      if (width > maxTextureSize || height > maxTextureSize) {
        const requested = `[${width}x${height}]`;
        const max2 = `[${maxTextureSize}x${maxTextureSize}]`;
        throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max2 + ".");
      }
    }
    function createFramebuffer(gl) {
      return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
    }
    function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer2, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
      const loc = gl.getAttribLocation(program, attribute);
      if (loc === -1) {
        return false;
      }
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer2));
      callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
      callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
      return true;
    }
    function bindTextureUnit(gl, texture, textureUnit) {
      validateTextureUnit(gl, textureUnit);
      callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    }
    function getProgramUniformLocationOrThrow(gl, program, uniformName) {
      return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
    }
    function getProgramUniformLocation(gl, program, uniformName) {
      return gl.getUniformLocation(program, uniformName);
    }
    function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
      callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
      callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
    }
    function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
      callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
    }
    function unbindColorTextureFromFramebuffer(gl, framebuffer) {
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
      callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
    }
    function validateFramebuffer(gl) {
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status));
      }
    }
    function getFramebufferErrorMessage(gl, status) {
      switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        case gl.FRAMEBUFFER_UNSUPPORTED:
          return "FRAMEBUFFER_UNSUPPORTED";
        default:
          return `unknown error ${status}`;
      }
    }
    function throwIfNull(gl, returnTOrNull, failureMessage) {
      const tOrNull = callAndCheck(gl, () => returnTOrNull());
      if (tOrNull == null) {
        throw new Error(failureMessage);
      }
      return tOrNull;
    }
    function validateTextureUnit(gl, textureUnit) {
      const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
      const glTextureUnit = textureUnit + gl.TEXTURE0;
      if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
        throw new Error(`textureUnit must be in ${textureUnitRange}.`);
      }
    }
    function getBatchDim(shape, dimsToSkip = 2) {
      return util_exports.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
    }
    function getRowsCols(shape) {
      if (shape.length === 0) {
        throw Error("Cannot get rows and columns of an empty shape array.");
      }
      return [
        shape.length > 1 ? shape[shape.length - 2] : 1,
        shape[shape.length - 1]
      ];
    }
    function getShapeAs3D(shape) {
      let shapeAs3D = [1, 1, 1];
      const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
      if (!isScalar) {
        shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
      }
      return shapeAs3D;
    }
    function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
      let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (isPacked) {
        maxTexSize = maxTexSize * 2;
        logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util_exports.nearestLargerEven(logShape[i]) : logShape[i]);
        if (logShape.length === 1) {
          logShape = [2, logShape[0]];
        }
      }
      if (logShape.length !== 2) {
        const squeezeResult = util_exports.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
      }
      let size = util_exports.sizeFromShape(logShape);
      if (logShape.length <= 1 && size <= maxTexSize) {
        return [1, size];
      } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
        return logShape;
      } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
        return [logShape[0] * logShape[1], logShape[2]];
      } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
      } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
      } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
      } else {
        if (isPacked) {
          const batchDim = getBatchDim(logShape);
          let rows = 2, cols = 2;
          if (logShape.length) {
            [rows, cols] = getRowsCols(logShape);
          }
          size = batchDim * (rows / 2) * (cols / 2);
          return util_exports.sizeToSquarishShape(size).map((d) => d * 2);
        }
        return util_exports.sizeToSquarishShape(size);
      }
    }
    function isEven(n) {
      return n % 2 === 0;
    }
    function isReshapeFree(shape1, shape2) {
      shape1 = shape1.slice(-2);
      shape2 = shape2.slice(-2);
      if (util_exports.arraysEqual(shape1, shape2)) {
        return true;
      }
      if (!shape1.length || !shape2.length) {
        return true;
      }
      if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
        return true;
      }
      if (shape1.length !== shape2.length) {
        const shape1Cols = shape1.slice(-1)[0];
        const shape2Cols = shape2.slice(-1)[0];
        if (shape1Cols === shape2Cols) {
          return true;
        }
        if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
          return true;
        }
      }
      return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
    }
    var MAX_TEXTURE_SIZE;
    var MAX_TEXTURES_IN_SHADER;
    function getWebGLMaxTextureSize(webGLVersion) {
      if (MAX_TEXTURE_SIZE == null) {
        const gl = getWebGLContext(webGLVersion);
        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      }
      return MAX_TEXTURE_SIZE;
    }
    function getMaxTexturesInShader(webGLVersion) {
      if (MAX_TEXTURES_IN_SHADER == null) {
        const gl = getWebGLContext(webGLVersion);
        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      }
      return Math.min(16, MAX_TEXTURES_IN_SHADER);
    }
    function getWebGLDisjointQueryTimerVersion(webGLVersion) {
      if (webGLVersion === 0) {
        return 0;
      }
      let queryTimerVersion;
      const gl = getWebGLContext(webGLVersion);
      if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
        queryTimerVersion = 2;
      } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
        queryTimerVersion = 1;
      } else {
        queryTimerVersion = 0;
      }
      return queryTimerVersion;
    }
    function hasExtension(gl, extensionName) {
      const ext = gl.getExtension(extensionName);
      return ext != null;
    }
    function isWebGLVersionEnabled(webGLVersion) {
      try {
        const gl = getWebGLContext(webGLVersion);
        if (gl != null) {
          return true;
        }
      } catch (e) {
        console.log("Error when getting WebGL context: ", e);
        return false;
      }
      return false;
    }
    function isCapableOfRenderingToFloatTexture(webGLVersion) {
      if (webGLVersion === 0) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      if (webGLVersion === 1) {
        if (!hasExtension(gl, "OES_texture_float")) {
          return false;
        }
      } else {
        if (!hasExtension(gl, "EXT_color_buffer_float")) {
          return false;
        }
      }
      const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
      return isFrameBufferComplete;
    }
    function isDownloadFloatTextureEnabled(webGLVersion) {
      if (webGLVersion === 0) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      if (webGLVersion === 1) {
        if (!hasExtension(gl, "OES_texture_float")) {
          return false;
        }
        if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
          return false;
        }
      } else {
        if (hasExtension(gl, "EXT_color_buffer_float")) {
          return createFloatTextureAndBindToFramebuffer(gl);
        }
        const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
          const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
          return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
        }
        return false;
      }
      const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
      return isFrameBufferComplete;
    }
    function createFloatTextureAndBindToFramebuffer(gl) {
      const texConfig = getTextureConfig(gl);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const width = 1;
      const height = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
      const frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteTexture(texture);
      gl.deleteFramebuffer(frameBuffer);
      return isFrameBufferComplete;
    }
    function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
      const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const width = 1;
      const height = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
      const frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteTexture(texture);
      gl.deleteFramebuffer(frameBuffer);
      return isFrameBufferComplete;
    }
    function isWebGLFenceEnabled(webGLVersion) {
      if (webGLVersion !== 2) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      const isEnabled = gl.fenceSync != null;
      return isEnabled;
    }
    function assertNotComplex(tensor, opName) {
      if (!Array.isArray(tensor)) {
        tensor = [tensor];
      }
      tensor.forEach((t) => {
        if (t != null) {
          util_exports.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
        }
      });
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/flags_webgl.js
    var ENV3 = env();
    ENV3.registerFlag("HAS_WEBGL", () => ENV3.getNumber("WEBGL_VERSION") > 0);
    ENV3.registerFlag("WEBGL_VERSION", () => {
      if (isWebGLVersionEnabled(2)) {
        return 2;
      } else if (isWebGLVersionEnabled(1)) {
        return 1;
      }
      return 0;
    });
    ENV3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
    ENV3.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV3.get("WEBGL_VERSION") === 2);
    ENV3.registerFlag("WEBGL_CPU_FORWARD", () => true);
    ENV3.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
    ENV3.registerFlag("WEBGL_PACK", () => ENV3.getBool("HAS_WEBGL"));
    ENV3.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_CLIP", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_PACK_REDUCE", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_CONV_IM2COL", () => ENV3.getBool("WEBGL_PACK"));
    ENV3.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV3.getNumber("WEBGL_VERSION")));
    ENV3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV3.getNumber("WEBGL_VERSION")));
    ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
      const webGLVersion = ENV3.getNumber("WEBGL_VERSION");
      if (webGLVersion === 0) {
        return 0;
      }
      return getWebGLDisjointQueryTimerVersion(webGLVersion);
    });
    ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !device_util_exports.isMobile());
    ENV3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV3.getNumber("WEBGL_VERSION")));
    ENV3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
      return ENV3.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
    });
    ENV3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV3.getNumber("WEBGL_VERSION")));
    ENV3.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV3.getNumber("WEBGL_VERSION")));
    ENV3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
      const useUniforms = ENV3.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
      return useUniforms ? 4 : 0;
    });
    ENV3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
      return -1;
    }, (threshold) => {
      if (threshold < 0 && threshold !== -1) {
        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold}.`);
      }
    });
    ENV3.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
      return device_util_exports.isMobile() && ENV3.getBool("IS_CHROME") ? 1 : -1;
    }, (threshold) => {
      if (threshold < 0 && threshold !== -1) {
        throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${threshold}.`);
      }
    });
    ENV3.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  
    // ../../../tfjs/tfjs-backend-webgl/dist/glsl_version.js
    function getGlslDifferences() {
      let version;
      let attribute;
      let varyingVs;
      let varyingFs;
      let texture2D;
      let output;
      let defineOutput;
      let defineSpecialNaN;
      let defineSpecialInf;
      let defineRound;
      if (env().getNumber("WEBGL_VERSION") === 2) {
        version = "#version 300 es";
        attribute = "in";
        varyingVs = "out";
        varyingFs = "in";
        texture2D = "texture";
        output = "outputColor";
        defineOutput = "out vec4 outputColor;";
        defineSpecialNaN = `
        bool isnan_custom(float val) {
          return (val > 0.0 || val < 0.0) ? false : val != 0.0;
        }
  
        bvec4 isnan_custom(vec4 val) {
          return bvec4(isnan_custom(val.x),
            isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
        }
  
        #define isnan(value) isnan_custom(value)
      `;
        defineSpecialInf = ``;
        defineRound = `
        #define round(value) newRound(value)
        int newRound(float value) {
          return int(floor(value + 0.5));
        }
  
        ivec4 newRound(vec4 value) {
          return ivec4(floor(value + vec4(0.5)));
        }
      `;
      } else {
        version = "";
        attribute = "attribute";
        varyingVs = "varying";
        varyingFs = "varying";
        texture2D = "texture2D";
        output = "gl_FragColor";
        defineOutput = "";
        defineSpecialNaN = `
        #define isnan(value) isnan_custom(value)
        bool isnan_custom(float val) {
          return (val > 0. || val < 1. || val == 0.) ? false : true;
        }
        bvec4 isnan_custom(vec4 val) {
          return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
        }
      `;
        defineSpecialInf = `
        uniform float INFINITY;
  
        bool isinf(float val) {
          return abs(val) == INFINITY;
        }
        bvec4 isinf(vec4 val) {
          return equal(abs(val), vec4(INFINITY));
        }
      `;
        defineRound = `
        int round(float value) {
          return int(floor(value + 0.5));
        }
  
        ivec4 round(vec4 value) {
          return ivec4(floor(value + vec4(0.5)));
        }
      `;
      }
      return {
        version,
        attribute,
        varyingVs,
        varyingFs,
        texture2D,
        output,
        defineOutput,
        defineSpecialNaN,
        defineSpecialInf,
        defineRound
      };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/shader_compiler_util.js
    function getLogicalCoordinatesFromFlatIndex(coords2, shape, index2 = "index") {
      const strides = util_exports.computeStrides(shape);
      return strides.map((stride, i) => {
        const line1 = `int ${coords2[i]} = ${index2} / ${stride}`;
        const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index2} - ${coords2[i]} * ${stride}` : `index -= ${coords2[i]} * ${stride}`;
        return `${line1}; ${line2};`;
      }).join("");
    }
    function getFlatIndexFrom3D(shape) {
      const strides = util_exports.computeStrides(shape).map((d) => d.toString());
      return `
    int getFlatIndex(ivec3 coords) {
      return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
    }
  `;
    }
    var ENCODE_FLOAT_SNIPPET = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;
  
    lowp vec4 encode_float(highp float v) {
      if (isnan(v)) {
        return vec4(255, 255, 255, 255);
      }
  
      highp float av = abs(v);
  
      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }
  
      highp vec4 c = vec4(0,0,0,0);
  
      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;
  
      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);
  
      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;
  
      c[3] += 128.0 * step(0.0, -v);
  
      return c / 255.0;
    }
  `;
  
    // ../../../tfjs/tfjs-backend-webgl/dist/decode_matrix_gpu.js
    var DecodeMatrixProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outPackingScheme = PackingScheme.DENSE;
        const texShape = getDenseTexShape(outputShape);
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
        ivec3 outCoordsFromFlatIndex(int index) {
          ${getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
          return ivec3(r, c, d);
        }
  
        void main() {
          ivec2 resTexRC = ivec2(resultUV.yx *
            vec2(${texShape[0]}, ${texShape[1]}));
          int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);
  
          vec4 result = vec4(0.);
  
          for (int i=0; i<4; i++) {
            int flatIndex = index + i;
            ivec3 rc = outCoordsFromFlatIndex(flatIndex);
            result[i] = getA(rc.x, rc.y, rc.z);
          }
  
          ${glsl.output} = result;
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js
    var DecodeMatrixPackedProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outPackingScheme = PackingScheme.DENSE;
        const texShape = getDenseTexShape(outputShape);
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
        ivec3 outCoordsFromFlatIndex(int index) {
          ${getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
          return ivec3(r, c, d);
        }
  
        void main() {
          ivec2 resTexRC = ivec2(resultUV.yx *
            vec2(${texShape[0]}, ${texShape[1]}));
          int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);
  
          vec4 result = vec4(0.);
  
          for (int i=0; i<4; i++) {
            int flatIndex = index + i;
            ivec3 rc = outCoordsFromFlatIndex(flatIndex);
            result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
          }
  
          ${glsl.output} = result;
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/encode_float_gpu.js
    var EncodeFloatProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.outTexUsage = TextureUsage.DOWNLOAD;
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
        ${ENCODE_FLOAT_SNIPPET}
  
        void main() {
          float x = getAAtOutCoords();
          ${glsl.output} = encode_float(x);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/encode_float_packed_gpu.js
    var EncodeFloatPackedProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outTexUsage = TextureUsage.DOWNLOAD;
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
        ${ENCODE_FLOAT_SNIPPET}
  
        void main() {
          ivec3 coords = getOutputCoords();
          float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
          ${glsl.output} = encode_float(x);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/encode_matrix_gpu.js
    var EncodeMatrixProgram = class {
      constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ["A"];
        const glsl = getGlslDifferences();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let output = `result`;
        if (inputIsUnsignedByte) {
          output = `floor(result * 255. + 0.5)`;
        }
        this.userCode = `
        ${getFlatIndexFrom3D(outputShape)}
  
        void main() {
          ivec3 coords = getOutputCoords();
  
          int flatIndex = getFlatIndex(coords);
          int offset = imod(flatIndex, 4);
  
          flatIndex = idiv(flatIndex, 4, 1.);
  
          int r = flatIndex / ${width};
          int c = imod(flatIndex, ${width});
          vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
          vec4 values = ${glsl.texture2D}(A, uv);
  
          float result;
  
          if(offset == 0) {
            result = values[0];
          } else if(offset == 1) {
            result = values[1];
          } else if(offset == 2) {
            result = values[2];
          } else {
            result = values[3];
          }
  
          ${glsl.output} = vec4(${output}, 0., 0., 0.);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js
    var EncodeMatrixPackedProgram = class {
      constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = getGlslDifferences();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let mainLoop = "";
        let output = "result";
        if (inputIsUnsignedByte) {
          output = "floor(result * 255. + 0.5)";
        }
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            const channel = row * 2 + col;
            mainLoop += `
            localCoords = coords;
            if(localCoords[2] + ${col} < ${outputShape[2]}) {
              localCoords[2] += ${col};
              if(localCoords[1] + ${row} < ${outputShape[1]}) {
                localCoords[1] += ${row};
  
                flatIndex = getFlatIndex(localCoords);
                offset = imod(flatIndex, 4);
  
                flatIndex = idiv(flatIndex, 4, 1.);
  
                r = flatIndex / ${width};
                c = imod(flatIndex, ${width});
                uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
                values = ${glsl.texture2D}(A, uv);
  
                if(offset == 0) {
                  result[${channel}] = values[0];
                } else if(offset == 1) {
                  result[${channel}] = values[1];
                } else if(offset == 2) {
                  result[${channel}] = values[2];
                } else {
                  result[${channel}] = values[3];
                }
              }
            }
          `;
          }
        }
        this.userCode = `
        ${getFlatIndexFrom3D(outputShape)}
  
        void main() {
          ivec3 coords = getOutputCoords();
  
          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;
  
          ${mainLoop}
  
          ${glsl.output} = ${output};
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/gpgpu_util.js
    function createVertexShader2(gl) {
      const glsl = getGlslDifferences();
      const vertexShaderSource = `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 clipSpacePos;
      ${glsl.attribute} vec2 uv;
      ${glsl.varyingVs} vec2 resultUV;
  
      void main() {
        gl_Position = vec4(clipSpacePos, 1);
        resultUV = uv;
      }`;
      return createVertexShader(gl, vertexShaderSource);
    }
    function createVertexBuffer(gl) {
      const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
      return createStaticVertexBuffer(gl, vertexArray);
    }
    function createIndexBuffer(gl) {
      const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
      return createStaticIndexBuffer(gl, triangleVertexIndices);
    }
    function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
      validateTextureSize(width, height);
      const texture = createTexture(gl);
      const tex2d = gl.TEXTURE_2D;
      callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
      callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
      return texture;
    }
    function getInternalFormatForFloat32MatrixTexture(textureConfig) {
      return textureConfig.internalFormatFloat;
    }
    function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
    }
    function getInternalFormatForFloat16MatrixTexture(textureConfig) {
      return textureConfig.internalFormatHalfFloat;
    }
    function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
    }
    function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
      return textureConfig.downloadTextureFormat;
    }
    function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
    }
    function getInternalFormatForPackedMatrixTexture(textureConfig) {
      return textureConfig.internalFormatPackedFloat;
    }
    function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
    }
    function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
      return textureConfig.internalFormatPackedHalfFloat;
    }
    function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
    }
    function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
      const posOffset = 0;
      const uvOffset = 3 * 4;
      const stride = 3 * 4 + 2 * 4;
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
      const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
      return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
    }
    function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
      let dataForUpload, texelDataType, internalFormat;
      if (data instanceof Uint8Array) {
        dataForUpload = new Uint8Array(width * height * 4);
        texelDataType = gl.UNSIGNED_BYTE;
        internalFormat = gl.RGBA;
      } else {
        dataForUpload = new Float32Array(width * height * 4);
        texelDataType = gl.FLOAT;
        internalFormat = textureConfig.internalFormatPackedFloat;
      }
      dataForUpload.set(data);
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    }
    function uploadPixelDataToTexture(gl, texture, pixels) {
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
      if (pixels.data instanceof Uint8Array) {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
      } else {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
      }
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    }
    function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
      const buffer2 = gl2.createBuffer();
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2));
      const bytesPerFloat = 4;
      const valuesPerTexel = 4;
      const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
      callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
      callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
      return buffer2;
    }
    function downloadFloat32MatrixFromBuffer(gl, buffer2, size) {
      const gl2 = gl;
      const downloadTarget = new Float32Array(size);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
      gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
      return downloadTarget;
    }
    function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
      const [w, h] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      const numChannels = 4;
      const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
      callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
      return new Float32Array(downloadTarget.buffer);
    }
    function downloadPackedMatrixFromBuffer(gl, buffer2, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
      const gl2 = gl;
      const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer2);
      gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
      return downloadTarget;
    }
    function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
      const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
      callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
      return packedRGBA;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/gpgpu_context.js
    var GPGPUContext = class {
      constructor(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        const glVersion = env().getNumber("WEBGL_VERSION");
        if (gl != null) {
          this.gl = gl;
          setWebGLContext(glVersion, gl);
        } else {
          this.gl = getWebGLContext(glVersion);
        }
        let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
        const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
        if (env().getNumber("WEBGL_VERSION") === 1) {
          const TEXTURE_FLOAT = "OES_texture_float";
          const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
          this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
          if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
            this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
          } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
            throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          }
          this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
          if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
            this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
          } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
            throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          }
        } else {
          COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
          if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
          } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
            this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
          } else {
            throw new Error("GL context does not support color renderable floats");
          }
        }
        this.vertexBuffer = createVertexBuffer(this.gl);
        this.indexBuffer = createIndexBuffer(this.gl);
        this.framebuffer = createFramebuffer(this.gl);
        this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
      }
      get debug() {
        return env().getBool("DEBUG");
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        if (this.program != null) {
          console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
        }
        if (this.outputTexture != null) {
          console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
        }
        const gl = this.gl;
        callAndCheck(gl, () => gl.finish());
        callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
        callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
        callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
        callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
        callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
        this.disposed = true;
      }
      createFloat32MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createFloat16MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createUnsignedBytesMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      uploadPixelDataToTexture(texture, pixels) {
        this.throwIfDisposed();
        uploadPixelDataToTexture(this.gl, texture, pixels);
      }
      uploadDenseMatrixToTexture(texture, width, height, data) {
        this.throwIfDisposed();
        uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
      }
      createFloat16PackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createPackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      deleteMatrixTexture(texture) {
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
          unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
          this.outputTexture = null;
        }
        callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
      }
      downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
        return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
      }
      downloadPackedMatrixFromBuffer(buffer2, batch, rows, columns, physicalRows, physicalCols) {
        return downloadPackedMatrixFromBuffer(this.gl, buffer2, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
      }
      downloadFloat32MatrixFromBuffer(buffer2, size) {
        return downloadFloat32MatrixFromBuffer(this.gl, buffer2, size);
      }
      createBufferFromTexture(texture, rows, columns) {
        this.bindTextureToFrameBuffer(texture);
        const result2 = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return result2;
      }
      createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
      }
      createFence(gl) {
        let query;
        let isFencePassed;
        if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
          const gl2 = gl;
          const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          isFencePassed = () => {
            const status = gl2.clientWaitSync(sync, 0, 0);
            return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
          };
          query = sync;
        } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
          query = this.beginQuery();
          this.endQuery();
          isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        } else {
          isFencePassed = () => true;
        }
        return { query, isFencePassed };
      }
      downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
        return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
      }
      createProgram(fragmentShaderSource) {
        this.throwIfDisposed();
        const gl = this.gl;
        const fragmentShader = createFragmentShader(gl, fragmentShaderSource);
        if (this.vertexShader == null) {
          this.vertexShader = createVertexShader2(gl);
        }
        const program = createProgram(gl);
        callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));
        callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
        linkProgram(gl, program);
        if (this.debug) {
          validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
          this.setProgram(program);
          this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
      }
      deleteProgram(program) {
        this.throwIfDisposed();
        if (program === this.program) {
          this.program = null;
        }
        if (program != null) {
          callAndCheck(this.gl, () => this.gl.deleteProgram(program));
        }
      }
      setProgram(program) {
        this.throwIfDisposed();
        this.program = program;
        if (this.program != null && this.debug) {
          validateProgram(this.gl, this.program);
        }
        callAndCheck(this.gl, () => this.gl.useProgram(program));
      }
      getUniformLocation(program, uniformName, shouldThrow = true) {
        this.throwIfDisposed();
        if (shouldThrow) {
          return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        } else {
          return getProgramUniformLocation(this.gl, program, uniformName);
        }
      }
      getAttributeLocation(program, attribute) {
        this.throwIfDisposed();
        return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
      }
      getUniformLocationNoThrow(program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
      }
      setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
      }
      setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
      }
      setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
      }
      setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
      }
      setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
      }
      debugValidate() {
        if (this.program != null) {
          validateProgram(this.gl, this.program);
        }
        validateFramebuffer(this.gl);
      }
      executeProgram() {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        const gl = this.gl;
        if (this.debug) {
          this.debugValidate();
        }
        callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
      }
      blockUntilAllProgramsCompleted() {
        this.throwIfDisposed();
        callAndCheck(this.gl, () => this.gl.finish());
      }
      getQueryTimerExtension() {
        if (this.disjointQueryTimerExtension == null) {
          this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
        }
        return this.disjointQueryTimerExtension;
      }
      getQueryTimerExtensionWebGL2() {
        return this.getQueryTimerExtension();
      }
      getQueryTimerExtensionWebGL1() {
        return this.getQueryTimerExtension();
      }
      beginQuery() {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
          const gl2 = this.gl;
          const ext2 = this.getQueryTimerExtensionWebGL2();
          const query2 = gl2.createQuery();
          gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
          return query2;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        const query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
      }
      endQuery() {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
          const gl2 = this.gl;
          const ext2 = this.getQueryTimerExtensionWebGL2();
          gl2.endQuery(ext2.TIME_ELAPSED_EXT);
          return;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
      }
      waitForQueryAndGetTime(query) {
        return __async(this, null, function* () {
          yield util_exports.repeatedTry(() => this.disposed || this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
          return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        });
      }
      getQueryTime(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
          return null;
        }
        if (queryTimerVersion === 2) {
          const gl2 = this.gl;
          const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
          return timeElapsedNanos / 1e6;
        } else {
          const ext = this.getQueryTimerExtensionWebGL1();
          const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
          return timeElapsedNanos / 1e6;
        }
      }
      isQueryAvailable(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
          return true;
        }
        if (queryTimerVersion === 2) {
          const gl2 = this.gl;
          const ext = this.getQueryTimerExtensionWebGL2();
          const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
          if (this.disjoint == null) {
            this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
          }
          return available && !this.disjoint;
        } else {
          const ext = this.getQueryTimerExtensionWebGL1();
          const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
          if (this.disjoint == null) {
            this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
          }
          return available && !this.disjoint;
        }
      }
      pollFence(fenceContext) {
        return new Promise((resolve) => {
          this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
        });
      }
      pollItems() {
        const index2 = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
        for (let i = 0; i <= index2; ++i) {
          const { resolveFn } = this.itemsToPoll[i];
          resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index2 + 1);
      }
      addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({ isDoneFn, resolveFn });
        if (this.itemsToPoll.length > 1) {
          return;
        }
        util_exports.repeatedTry(() => {
          this.pollItems();
          return this.itemsToPoll.length === 0;
        });
      }
      bindTextureToFrameBuffer(texture) {
        this.throwIfDisposed();
        bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(this.gl);
        }
      }
      unbindTextureToFrameBuffer() {
        if (this.outputTexture != null) {
          bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
          if (this.debug) {
            validateFramebuffer(this.gl);
          }
        } else {
          unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
      }
      downloadMatrixDriver(texture, downloadAndDecode) {
        this.bindTextureToFrameBuffer(texture);
        const result2 = downloadAndDecode();
        this.unbindTextureToFrameBuffer();
        return result2;
      }
      setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        const gl = this.gl;
        bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        callAndCheck(gl, () => gl.viewport(0, 0, width, height));
        callAndCheck(gl, () => gl.scissor(0, 0, width, height));
      }
      setOutputMatrixWriteRegionDriver(x, y, width, height) {
        this.throwIfDisposed();
        callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
      }
      throwIfDisposed() {
        if (this.disposed) {
          throw new Error("Attempted to use disposed GPGPUContext.");
        }
      }
      throwIfNoProgram() {
        if (this.program == null) {
          throw new Error("No GPU program is currently set.");
        }
      }
    };
    function linearSearchLastTrue(arr) {
      let i = 0;
      for (; i < arr.length; ++i) {
        const isDone = arr[i]();
        if (!isDone) {
          break;
        }
      }
      return i - 1;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/shader_compiler.js
    var { getBroadcastDims: getBroadcastDims2 } = backend_util_exports;
    function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {
      const prefixSnippets = [];
      inputsInfo.forEach((x) => {
        const size = util_exports.sizeFromShape(x.shapeInfo.logicalShape);
        if (x.shapeInfo.isUniform) {
          prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ""};`);
        } else {
          prefixSnippets.push(`uniform sampler2D ${x.name};`);
          prefixSnippets.push(`uniform int offset${x.name};`);
        }
      });
      const inputPrefixSnippet = prefixSnippets.join("\n");
      const inputSamplingSnippet = inputsInfo.map((x) => getInputSamplingSnippet(x, outputShape, usesPackedTextures)).join("\n");
      const outTexShape = outputShape.texShape;
      const glsl = getGlslDifferences();
      const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
      let outputSamplingSnippet;
      let floatTextureSetOutputSnippet;
      let shaderPrefix = getShaderPrefix(glsl);
      if (outputShape.isPacked) {
        outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
      } else {
        outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
      }
      if (usesPackedTextures) {
        shaderPrefix += SHADER_PACKED_PREFIX;
      }
      const source = [
        shaderPrefix,
        floatTextureSampleSnippet,
        floatTextureSetOutputSnippet,
        inputPrefixSnippet,
        outputSamplingSnippet,
        inputSamplingSnippet,
        userCode
      ].join("\n");
      return source;
    }
    function getSamplerFromInInfo(inInfo) {
      const shape = inInfo.shapeInfo.logicalShape;
      switch (shape.length) {
        case 0:
          return getSamplerScalar(inInfo);
        case 1:
          return getSampler1D(inInfo);
        case 2:
          return getSampler2D(inInfo);
        case 3:
          return getSampler3D(inInfo);
        case 4:
          return getSampler4D(inInfo);
        case 5:
          return getSampler5D(inInfo);
        case 6:
          return getSampler6D(inInfo);
        default:
          throw new Error(`${shape.length}-D input sampling is not yet supported`);
      }
    }
    function getPackedSamplerFromInInfo(inInfo) {
      const shape = inInfo.shapeInfo.logicalShape;
      switch (shape.length) {
        case 0:
          return getPackedSamplerScalar(inInfo);
        case 1:
          return getPackedSampler1D(inInfo);
        case 2:
          return getPackedSampler2D(inInfo);
        case 3:
          return getPackedSampler3D(inInfo);
        default:
          return getPackedSamplerND(inInfo);
      }
    }
    function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {
      let res = "";
      if (usesPackedTextures) {
        res += getPackedSamplerFromInInfo(inInfo);
      } else {
        res += getSamplerFromInInfo(inInfo);
      }
      const inShape = inInfo.shapeInfo.logicalShape;
      const outShape = outShapeInfo.logicalShape;
      if (inShape.length <= outShape.length) {
        if (usesPackedTextures) {
          res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
        } else {
          res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
        }
      }
      return res;
    }
    function getPackedOutputSamplingSnippet(outShape, outTexShape) {
      switch (outShape.length) {
        case 0:
          return getOutputScalarCoords();
        case 1:
          return getOutputPacked1DCoords(outShape, outTexShape);
        case 2:
          return getOutputPacked2DCoords(outShape, outTexShape);
        case 3:
          return getOutputPacked3DCoords(outShape, outTexShape);
        default:
          return getOutputPackedNDCoords(outShape, outTexShape);
      }
    }
    function getOutputSamplingSnippet(outShape, outTexShape) {
      switch (outShape.length) {
        case 0:
          return getOutputScalarCoords();
        case 1:
          return getOutput1DCoords(outShape, outTexShape);
        case 2:
          return getOutput2DCoords(outShape, outTexShape);
        case 3:
          return getOutput3DCoords(outShape, outTexShape);
        case 4:
          return getOutput4DCoords(outShape, outTexShape);
        case 5:
          return getOutput5DCoords(outShape, outTexShape);
        case 6:
          return getOutput6DCoords(outShape, outTexShape);
        default:
          throw new Error(`${outShape.length}-D output sampling is not yet supported`);
      }
    }
    function getFloatTextureSampleSnippet(glsl) {
      return `
      float sampleTexture(sampler2D textureSampler, vec2 uv) {
        return ${glsl.texture2D}(textureSampler, uv).r;
      }
    `;
    }
    function getFloatTextureSetRSnippet(glsl) {
      return `
      void setOutput(float val) {
        ${glsl.output} = vec4(val, 0, 0, 0);
      }
    `;
    }
    function getFloatTextureSetRGBASnippet(glsl) {
      return `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
    }
    function getShaderPrefix(glsl) {
      const SHADER_PREFIX = `${glsl.version}
      precision highp float;
      precision highp int;
      precision highp sampler2D;
      ${glsl.varyingFs} vec2 resultUV;
      ${glsl.defineOutput}
      const vec2 halfCR = vec2(0.5, 0.5);
  
      struct ivec5
      {
        int x;
        int y;
        int z;
        int w;
        int u;
      };
  
      struct ivec6
      {
        int x;
        int y;
        int z;
        int w;
        int u;
        int v;
      };
  
      uniform float NAN;
      ${glsl.defineSpecialNaN}
      ${glsl.defineSpecialInf}
      ${glsl.defineRound}
  
      int imod(int x, int y) {
        return x - y * (x / y);
      }
  
      int idiv(int a, int b, float sign) {
        int res = a / b;
        int mod = imod(a, b);
        if (sign < 0. && mod != 0) {
          res -= 1;
        }
        return res;
      }
  
      //Based on the work of Dave Hoskins
      //https://www.shadertoy.com/view/4djSRW
      #define HASHSCALE1 443.8975
      float random(float seed){
        vec2 p = resultUV * seed;
        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
        p3 += dot(p3, p3.yzx + 19.19);
        return fract((p3.x + p3.y) * p3.z);
      }
  
      ${SAMPLE_1D_SNIPPET}
      ${SAMPLE_2D_SNIPPET}
      ${SAMPLE_3D_SNIPPET}
    `;
      return SHADER_PREFIX;
    }
    var SAMPLE_1D_SNIPPET = `
  vec2 uvFromFlat(int texNumR, int texNumC, int index) {
    int texR = index / texNumC;
    int texC = index - texR * texNumC;
    return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
  }
  vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
    int texelIndex = index / 2;
    int texR = texelIndex / texNumC;
    int texC = texelIndex - texR * texNumC;
    return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
  }
  `;
    var SAMPLE_2D_SNIPPET = `
  vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
    int texNumC, int row, int col) {
    int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
    int texR = texelIndex / texNumC;
    int texC = texelIndex - texR * texNumC;
    return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
  }
  `;
    var SAMPLE_3D_SNIPPET = `
  vec2 packedUVfrom3D(int texNumR, int texNumC,
      int texelsInBatch, int texelsInLogicalRow, int b,
      int row, int col) {
    int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
    int texR = index / texNumC;
    int texC = index - texR * texNumC;
    return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
  }
  `;
    var SHADER_PACKED_PREFIX = `
    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
    float getChannel(vec4 frag, int dim) {
      float modCoord = mod(float(dim), 2.);
      return modCoord == 0. ? frag.r : frag.g;
    }
  `;
    function getOutputScalarCoords() {
      return `
      int getOutputCoords() {
        return 0;
      }
    `;
    }
    function getOutputPacked1DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (packedTexShape[0] === 1) {
        return `
        int getOutputCoords() {
          return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
        }
      `;
      }
      if (packedTexShape[1] === 1) {
        return `
        int getOutputCoords() {
          return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
        }
      `;
      }
      return `
      int getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
      }
    `;
    }
    function getOutput1DCoords(shape, texShape) {
      if (texShape[0] === 1) {
        return `
        int getOutputCoords() {
          return int(resultUV.x * ${texShape[1]}.0);
        }
      `;
      }
      if (texShape[1] === 1) {
        return `
        int getOutputCoords() {
          return int(resultUV.y * ${texShape[0]}.0);
        }
      `;
      }
      return `
      int getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        return resTexRC.x * ${texShape[1]} + resTexRC.y;
      }
    `;
    }
    function getOutputPacked3DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texelsInLogicalRow = Math.ceil(shape[2] / 2);
      const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
      return `
      ivec3 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
  
        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};
  
        int r = 2 * (index / ${texelsInLogicalRow});
        int c = imod(index, ${texelsInLogicalRow}) * 2;
  
        return ivec3(b, r, c);
      }
    `;
    }
    function getOutput3DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
      return `
      ivec3 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        ${coordsFromIndexSnippet}
        return ivec3(r, c, d);
      }
    `;
    }
    function getOutputPackedNDCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
      const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
      let texelsInBatchN = texelsInBatch;
      let batches = ``;
      let coords2 = "b, r, c";
      for (let b = 2; b < shape.length - 1; b++) {
        texelsInBatchN *= shape[shape.length - b - 1];
        batches = `
        int b${b} = index / ${texelsInBatchN};
        index -= b${b} * ${texelsInBatchN};
      ` + batches;
        coords2 = `b${b}, ` + coords2;
      }
      return `
      ivec${shape.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
  
        ${batches}
  
        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};
  
        int r = 2 * (index / ${texelsInLogicalRow});
        int c = imod(index, ${texelsInLogicalRow}) * 2;
  
        return ivec${shape.length}(${coords2});
      }
    `;
    }
    function getOutput4DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
      return `
      ivec4 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        ${coordsFromIndexSnippet}
        return ivec4(r, c, d, d2);
      }
    `;
    }
    function getOutput5DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
      return `
      ivec5 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                               ${texShape[1]}));
  
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
  
        ${coordsFromIndexSnippet}
  
        ivec5 outShape = ivec5(r, c, d, d2, d3);
        return outShape;
      }
    `;
    }
    function getOutput6DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
      return `
      ivec6 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
  
        ${coordsFromIndexSnippet}
  
        ivec6 result = ivec6(r, c, d, d2, d3, d4);
        return result;
      }
    `;
    }
    function getOutputPacked2DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (util_exports.arraysEqual(shape, texShape)) {
        return `
        ivec2 getOutputCoords() {
          return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        }
      `;
      }
      const texelsInLogicalRow = Math.ceil(shape[1] / 2);
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
  
        int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
        int r = 2 * (index / ${texelsInLogicalRow});
        int c = imod(index, ${texelsInLogicalRow}) * 2;
  
        return ivec2(r, c);
      }
    `;
    }
    function getOutput2DCoords(shape, texShape) {
      if (util_exports.arraysEqual(shape, texShape)) {
        return `
        ivec2 getOutputCoords() {
          return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
      }
      if (shape[1] === 1) {
        return `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(resultUV.yx *
                                 vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
          return ivec2(index, 0);
        }
      `;
      }
      if (shape[0] === 1) {
        return `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(resultUV.yx *
                                 vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
          return ivec2(0, index);
        }
      `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        int r = index / ${shape[1]};
        int c = index - r * ${shape[1]};
        return ivec2(r, c);
      }
    `;
    }
    function getFlatOffsetUniformName(texName) {
      return `offset${texName}`;
    }
    function getPackedSamplerScalar(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const glsl = getGlslDifferences();
      return `
      vec4 ${funcName}() {
        return ${glsl.texture2D}(${texName}, halfCR);
      }
    `;
    }
    function getSamplerScalar(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      if (inputInfo.shapeInfo.isUniform) {
        return `float ${funcName}() {return ${texName};}`;
      }
      const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
      if (texNumR === 1 && texNumC === 1) {
        return `
        float ${funcName}() {
          return sampleTexture(${texName}, halfCR);
        }
      `;
      }
      const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
      const offset = getFlatOffsetUniformName(texName);
      return `
      float ${funcName}() {
        vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    function getPackedSampler1D(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const glsl = getGlslDifferences();
      return `
      vec4 ${funcName}(int index) {
        vec2 uv = packedUVfrom1D(
          ${packedTexShape[0]}, ${packedTexShape[1]}, index);
        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    function getSampler1D(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int index) {
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const texShape = inputInfo.shapeInfo.texShape;
      const tNumR = texShape[0];
      const tNumC = texShape[1];
      if (tNumC === 1 && tNumR === 1) {
        return `
        float ${funcName}(int index) {
          return sampleTexture(${texName}, halfCR);
        }
      `;
      }
      const offset = getFlatOffsetUniformName(texName);
      if (tNumC === 1) {
        return `
        float ${funcName}(int index) {
          vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      if (tNumR === 1) {
        return `
        float ${funcName}(int index) {
          vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    function getPackedSampler2D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const glsl = getGlslDifferences();
      if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
        return `
        vec4 ${funcName}(int row, int col) {
          vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
  
          return ${glsl.texture2D}(${texName}, uv);
        }
      `;
      }
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const valuesPerRow = Math.ceil(shape[1] / 2);
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    function getSampler2D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      if (texShape != null && util_exports.arraysEqual(shape, texShape)) {
        const texNumR2 = texShape[0];
        const texNumC2 = texShape[1];
        return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const { newShape, keptDims } = util_exports.squeezeShape(shape);
      const squeezedShape = newShape;
      if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["row", "col"];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int row, int col) {
          int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const offset = getFlatOffsetUniformName(texName);
      if (texNumC === 1) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      if (texNumR === 1) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
        vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${shape[1]} + col + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getPackedSampler3D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (shape[0] === 1) {
        const squeezedShape = shape.slice(1);
        const keptDims = [1, 2];
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["b", "row", "col"];
        return `
          ${getPackedSamplerFromInInfo(newInputInfo)}
          vec4 ${funcName}(int b, int row, int col) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
      }
      const texNumR = packedTexShape[0];
      const texNumC = packedTexShape[1];
      const valuesPerRow = Math.ceil(shape[2] / 2);
      const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
      const glsl = getGlslDifferences();
      return `
      vec4 ${funcName}(int b, int row, int col) {
        vec2 uv = packedUVfrom3D(
          ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    function getSampler3D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride0 = shape[1] * shape[2];
      const stride1 = shape[2];
      const { newShape, keptDims } = util_exports.squeezeShape(shape);
      const squeezedShape = newShape;
      if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["row", "col", "depth"];
        return `
          ${getSamplerFromInInfo(newInputInfo)}
          float ${funcName}(int row, int col, int depth) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int row, int col, int depth) {
          int index = round(dot(vec3(row, col, depth),
                            vec3(${stride0}, ${stride1}, 1)));
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      if (texNumC === stride0 && flatOffset == null) {
        return `
          float ${funcName}(int row, int col, int depth) {
            float texR = float(row);
            float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${texNumC}.0, ${texNumR}.0);
            return sampleTexture(${texName}, uv);
          }
        `;
      }
      if (texNumC === stride1 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
        float ${funcName}(int row, int col, int depth) {
          // Explicitly use integer operations as dot() only works on floats.
          int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${texName}, uv);
        }
    `;
    }
    function getPackedSamplerND(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const rank = shape.length;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texNumR = packedTexShape[0];
      const texNumC = packedTexShape[1];
      const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
      let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
      let params = `int b, int row, int col`;
      let index2 = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
      for (let b = 2; b < rank - 1; b++) {
        params = `int b${b}, ` + params;
        texelsInBatch *= shape[rank - b - 1];
        index2 = `b${b} * ${texelsInBatch} + ` + index2;
      }
      const glsl = getGlslDifferences();
      return `
      vec4 ${funcName}(${params}) {
        int index = ${index2};
        int texR = index / ${texNumC};
        int texC = index - texR * ${texNumC};
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    function getSampler4D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride2 = shape[3];
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      const { newShape, keptDims } = util_exports.squeezeShape(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2"];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth, int depth2) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = round(dot(vec4(row, col, depth, depth2),
                            vec4(${stride0}, ${stride1}, ${stride2}, 1)));
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2) {
          float texR = float(row);
          float texC =
              dot(vec3(col, depth, depth2),
                  vec3(${stride1}, ${stride2}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      if (texNumC === stride2 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2) {
          float texR = dot(vec3(row, col, depth),
                           vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
          float texC = float(depth2);
          vec2 uv = (vec2(texC, texR) + halfCR) /
                    vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} +
            depth * ${stride2} + depth2;
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    function getSampler5D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride3 = shape[4];
      const stride2 = shape[3] * stride3;
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      const { newShape, keptDims } = util_exports.squeezeShape(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2", "depth3"];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          float index = dot(
            vec4(row, col, depth, depth2),
            vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
            depth3;
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int texR = row;
          float texC = dot(vec4(col, depth, depth2, depth3),
                           vec4(${stride1}, ${stride2}, ${stride3}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      if (texNumC === stride3 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          float texR = dot(
            vec4(row, col, depth, depth2),
            vec4(${shape[1] * shape[2] * shape[3]},
                 ${shape[2] * shape[3]}, ${shape[3]}, 1));
          int texC = depth3;
          vec2 uv = (vec2(texC, texR) + halfCR) /
                    vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    function getSampler6D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const { newShape, keptDims } = util_exports.squeezeShape(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth,
                      int depth2, int depth3, int depth4) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      const stride4 = shape[5];
      const stride3 = shape[4] * stride4;
      const stride2 = shape[3] * stride3;
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      if (inputInfo.shapeInfo.isUniform) {
        return `
        float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
          int index = round(dot(
            vec4(row, col, depth, depth2),
            vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
            dot(
              vec2(depth3, depth4),
              vec2(${stride4}, 1)));
          ${getUniformSampler(inputInfo)}
        }
      `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth,
                      int depth2, int depth3, int depth4) {
          int texR = row;
          float texC = dot(vec4(col, depth, depth2, depth3),
            vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
                 float(depth4);
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      if (texNumC === stride4 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth,
                      int depth2, int depth3, int depth4) {
          float texR = dot(vec4(row, col, depth, depth2),
            vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
                 ${shape[2] * shape[3] * shape[4]},
                 ${shape[3] * shape[4]},
                 ${shape[4]})) + float(depth3);
          int texC = depth4;
          vec2 uv = (vec2(texC, texR) + halfCR) /
                    vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    function getUniformSampler(inputInfo) {
      const texName = inputInfo.name;
      const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
      if (inSize < 2) {
        return `return ${texName};`;
      }
      return `
      for (int i = 0; i < ${inSize}; i++) {
        if (i == index) {
          return ${texName}[i];
        }
      }
    `;
    }
    function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
      const texName = inputInfo.name;
      const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
      const funcName = "get" + texFuncSnippet + "AtOutCoords";
      const inRank = inputInfo.shapeInfo.logicalShape.length;
      const outRank = outShapeInfo.logicalShape.length;
      const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
      const type = getCoordsDataType(outRank);
      const rankDiff = outRank - inRank;
      let coordsSnippet;
      const fields = ["x", "y", "z", "w", "u", "v"];
      if (inRank === 0) {
        coordsSnippet = "";
      } else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = "coords = 0;";
      } else {
        coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
      }
      let unpackedCoordsSnippet = "";
      if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = "coords";
      } else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
      }
      let output = `return outputValue;`;
      const inSize = util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
      const isInputScalar = inSize === 1;
      const outSize = util_exports.sizeFromShape(outShapeInfo.logicalShape);
      const isOutputScalar = outSize === 1;
      if (inRank === 1 && !isInputScalar && !isOutputScalar) {
        output = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
      } else if (isInputScalar && !isOutputScalar) {
        if (outRank === 1) {
          output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
        } else {
          output = `
          return vec4(outputValue.x);
        `;
        }
      } else if (broadcastDims.length) {
        const rows = inRank - 2;
        const cols = inRank - 1;
        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
          output = `return vec4(outputValue.x);`;
        } else if (broadcastDims.indexOf(rows) > -1) {
          output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
        } else if (broadcastDims.indexOf(cols) > -1) {
          output = `return vec4(outputValue.xx, outputValue.zz);`;
        }
      }
      return `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${coordsSnippet}
        vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
    }
    function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
      const texName = inputInfo.name;
      const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
      const funcName = "get" + texFuncSnippet + "AtOutCoords";
      const outTexShape = outShapeInfo.texShape;
      const inTexShape = inputInfo.shapeInfo.texShape;
      const inRank = inputInfo.shapeInfo.logicalShape.length;
      const outRank = outShapeInfo.logicalShape.length;
      if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && util_exports.arraysEqual(inTexShape, outTexShape)) {
        return `
        float ${funcName}() {
          return sampleTexture(${texName}, resultUV);
        }
      `;
      }
      const type = getCoordsDataType(outRank);
      const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
      const rankDiff = outRank - inRank;
      let coordsSnippet;
      const fields = ["x", "y", "z", "w", "u", "v"];
      if (inRank === 0) {
        coordsSnippet = "";
      } else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = "coords = 0;";
      } else {
        coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
      }
      let unpackedCoordsSnippet = "";
      if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = "coords";
      } else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
      }
      return `
      float ${funcName}() {
        ${type} coords = getOutputCoords();
        ${coordsSnippet}
        return get${texFuncSnippet}(${unpackedCoordsSnippet});
      }
    `;
    }
    function getCoordsDataType(rank) {
      if (rank <= 1) {
        return "int";
      } else if (rank === 2) {
        return "ivec2";
      } else if (rank === 3) {
        return "ivec3";
      } else if (rank === 4) {
        return "ivec4";
      } else if (rank === 5) {
        return "ivec5";
      } else if (rank === 6) {
        return "ivec6";
      } else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
      }
    }
    function squeezeInputInfo(inInfo, squeezedShape) {
      const newInputInfo = JSON.parse(JSON.stringify(inInfo));
      newInputInfo.shapeInfo.logicalShape = squeezedShape;
      return newInputInfo;
    }
    function getSqueezedParams(params, keptDims) {
      return keptDims.map((d) => params[d]).join(", ");
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/gpgpu_math.js
    function compileProgram(gpgpu, program, inputs, output) {
      const userCode = program.userCode;
      const inputInfos = inputs.map((input, i) => {
        const shapeInfo = {
          logicalShape: input.shape,
          texShape: input.isUniform ? null : input.texData.texShape,
          isUniform: input.isUniform,
          isPacked: input.isUniform ? false : input.texData.isPacked,
          flatOffset: null
        };
        if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) {
          shapeInfo.flatOffset = input.texData.slice.flatOffset;
        }
        return { name: program.variableNames[i], shapeInfo };
      });
      const inShapeInfos = inputInfos.map((x) => x.shapeInfo);
      const outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.isPacked,
        flatOffset: null
      };
      const source = makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);
      const webGLProgram = gpgpu.createProgram(source);
      let infLoc = null;
      const nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
      if (env().getNumber("WEBGL_VERSION") === 1) {
        infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
      }
      const uniformLocations = {};
      for (let i = 0; i < program.variableNames.length; i++) {
        const varName = program.variableNames[i];
        const shouldThrow = false;
        uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
        uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
      }
      return {
        program,
        source,
        webGLProgram,
        uniformLocations,
        inShapeInfos,
        outShapeInfo,
        infLoc,
        nanLoc
      };
    }
    function validateBinaryAndProgram(shapeInfos, inputs) {
      if (shapeInfos.length !== inputs.length) {
        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
      }
      shapeInfos.forEach((s, i) => {
        const shapeA = s.logicalShape;
        const input = inputs[i];
        const shapeB = input.shape;
        if (!util_exports.arraysEqual(shapeA, shapeB)) {
          throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
        }
        if (s.isUniform && input.isUniform) {
          return;
        }
        const texShapeA = s.texShape;
        const texShapeB = input.isUniform ? null : input.texData.texShape;
        if (!util_exports.arraysEqual(texShapeA, texShapeB)) {
          throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
        }
      });
    }
    function runProgram(gpgpu, binary, inputs, output, customSetup) {
      validateBinaryAndProgram(binary.inShapeInfos, inputs);
      validateBinaryAndProgram([binary.outShapeInfo], [output]);
      const outTex = output.texData.texture;
      const outTexShape = output.texData.texShape;
      if (output.texData.isPacked) {
        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
      } else {
        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
      }
      gpgpu.setProgram(binary.webGLProgram);
      if (env().getNumber("WEBGL_VERSION") === 1) {
        if (binary.infLoc !== null) {
          gpgpu.gl.uniform1f(binary.infLoc, Infinity);
        }
      }
      if (binary.nanLoc !== null) {
        gpgpu.gl.uniform1f(binary.nanLoc, NaN);
      }
      inputs.forEach((input, i) => {
        const varName = binary.program.variableNames[i];
        const varLoc = binary.uniformLocations[varName];
        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
        if (varLoc == null) {
          return;
        }
        if (input.isUniform) {
          if (util_exports.sizeFromShape(input.shape) < 2) {
            gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);
          } else {
            let vals = input.uniformValues;
            if (!(vals instanceof Float32Array)) {
              vals = new Float32Array(vals);
            }
            gpgpu.gl.uniform1fv(varLoc, vals);
          }
          return;
        }
        if (input.texData.slice != null && varOffsetLoc != null) {
          gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);
        }
        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);
      });
      if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
      }
      gpgpu.executeProgram();
    }
    function makeShaderKey(program, inputs, output) {
      let keyInputs = "";
      inputs.concat(output).forEach((x) => {
        const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
        const texShape = x.isUniform ? "uniform" : x.texData.texShape;
        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
      });
      const keyUserCode = program.userCode;
      let key = program.constructor.name;
      key += "_" + keyInputs + "_" + keyUserCode;
      return key;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/shared.js
    var shared_exports = {};
    __export(shared_exports, {
      addImpl: () => addImpl,
      bincountImpl: () => bincountImpl,
      bincountReduceImpl: () => bincountReduceImpl,
      ceilImpl: () => ceilImpl,
      concatImpl: () => concatImpl,
      equalImpl: () => equalImpl,
      expImpl: () => expImpl,
      expm1Impl: () => expm1Impl,
      floorImpl: () => floorImpl,
      gatherNdImpl: () => gatherNdImpl,
      gatherV2Impl: () => gatherV2Impl,
      greaterEqualImpl: () => greaterEqualImpl,
      greaterImpl: () => greaterImpl,
      lessEqualImpl: () => lessEqualImpl,
      lessImpl: () => lessImpl,
      linSpaceImpl: () => linSpaceImpl,
      logImpl: () => logImpl,
      maxImpl: () => maxImpl,
      maximumImpl: () => maximumImpl,
      minimumImpl: () => minimumImpl,
      multiplyImpl: () => multiplyImpl,
      negImpl: () => negImpl,
      notEqualImpl: () => notEqualImpl,
      prodImpl: () => prodImpl,
      rangeImpl: () => rangeImpl,
      rsqrtImpl: () => rsqrtImpl,
      simpleAbsImpl: () => simpleAbsImpl,
      sliceImpl: () => sliceImpl,
      sparseFillEmptyRowsImpl: () => sparseFillEmptyRowsImpl,
      sparseReshapeImpl: () => sparseReshapeImpl,
      sparseSegmentReductionImpl: () => sparseSegmentReductionImpl,
      squaredDifferenceImpl: () => squaredDifferenceImpl,
      stridedSliceImpl: () => stridedSliceImpl,
      stringNGramsImpl: () => stringNGramsImpl,
      stringSplitImpl: () => stringSplitImpl,
      stringToHashBucketFastImpl: () => stringToHashBucketFastImpl,
      subImpl: () => subImpl,
      tileImpl: () => tileImpl,
      topKImpl: () => topKImpl,
      transposeImpl: () => transposeImpl,
      uniqueImpl: () => uniqueImpl
    });
  
    // ../../../tfjs/tfjs-backend-cpu/dist/cpu_util.js
    function assertNotComplex2(tensor, opName) {
      if (!Array.isArray(tensor)) {
        tensor = [tensor];
      }
      tensor.forEach((t) => {
        if (t != null) {
          util_exports.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
        }
      });
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Abs.js
    function simpleAbsImpl(vals) {
      const resultValues = new Float32Array(vals.length);
      for (let i = 0; i < vals.length; ++i) {
        resultValues[i] = Math.abs(vals[i]);
      }
      return resultValues;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/utils/binary_impl.js
    function createSimpleBinaryKernelImpl(op2) {
      return (aShape, bShape, aVals, bVals, dtype) => {
        const newShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
        const resultRank = newShape.length;
        const resultStrides = util_exports.computeStrides(newShape);
        const resultSize = util_exports.sizeFromShape(newShape);
        const result2 = util_exports.getTypedArrayFromDType(dtype, resultSize);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const aStrides = util_exports.computeStrides(aShape);
        const bStrides = util_exports.computeStrides(bShape);
        const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, newShape);
        const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, newShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
          for (let i = 0; i < result2.length; ++i) {
            result2[i] = op2(aVals[i % aVals.length], bVals[i % bVals.length]);
          }
        } else {
          for (let i = 0; i < result2.length; ++i) {
            const loc = util_exports.indexToLoc(i, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d) => aLoc[d] = 0);
            const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d) => bLoc[d] = 0);
            const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
            result2[i] = op2(aVals[aIndex], bVals[bIndex]);
          }
        }
        return [result2, newShape];
      };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Complex.js
    function complex2(args) {
      const { inputs, backend } = args;
      const { real: real3, imag: imag2 } = inputs;
      const realVals = backend.data.get(real3.dataId).values;
      const imagVals = backend.data.get(imag2.dataId).values;
      const complexInfo = backend.makeTensorInfo(real3.shape, "complex64");
      const complex4 = backend.data.get(complexInfo.dataId);
      complex4.complexTensorInfos = {
        real: backend.makeTensorInfo(real3.shape, "float32", realVals),
        imag: backend.makeTensorInfo(imag2.shape, "float32", imagVals)
      };
      return complexInfo;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/utils/zeros_impl.js
    function zeros2(backend, shape, dtype = "float32") {
      if (dtype === "complex64") {
        const real3 = zeros2(backend, shape, "float32");
        const imag2 = zeros2(backend, shape, "float32");
        return complex2({ inputs: { real: real3, imag: imag2 }, backend });
      }
      const values = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(shape), dtype);
      return backend.makeTensorInfo(shape, dtype, values);
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Identity.js
    function identity(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      backend.incRef(x.dataId);
      return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Real.js
    function real(args) {
      const { inputs, backend } = args;
      const { input } = inputs;
      const real3 = backend.data.get(input.dataId).complexTensorInfos.real;
      const realVal = backend.data.get(real3.dataId).values;
      return backend.makeTensorInfo(real3.shape, real3.dtype, realVal);
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Cast.js
    function cast2(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { dtype } = attrs;
      if (dtype === "complex64") {
        if (x.dtype === "complex64") {
          return identity({ inputs: { x }, backend });
        }
        const zerosTensorInfo = zeros2(backend, x.shape, x.dtype);
        const floatX = cast2({ inputs: { x }, backend, attrs: { dtype: "float32" } });
        const result2 = complex2({ inputs: { real: floatX, imag: zerosTensorInfo }, backend });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        backend.disposeIntermediateTensorInfo(floatX);
        return result2;
      }
      if (x.dtype === "complex64") {
        const realPart = real({ inputs: { input: x }, backend });
        const result2 = cast2({ inputs: { x: realPart }, backend, attrs: { dtype } });
        backend.disposeIntermediateTensorInfo(realPart);
        return result2;
      }
      if (!util_exports.hasEncodingLoss(x.dtype, dtype)) {
        const result2 = identity({ inputs: { x }, backend });
        return { dataId: result2.dataId, shape: result2.shape, dtype };
      }
      if (dtype === "int32") {
        const values = backend.data.get(x.dataId).values;
        const resultValues = Int32Array.from(values);
        return backend.makeTensorInfo(x.shape, "int32", resultValues);
      }
      if (dtype === "bool") {
        const xVals = backend.data.get(x.dataId).values;
        const zero = util_exports.toTypedArray([0], x.dtype);
        const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(x.shape, [], xVals, zero, "bool");
        return backend.makeTensorInfo(resultShape, "bool", resultData);
      }
      throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/utils/binary_utils.js
    function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
      if (complexImpl == null) {
        return ({ inputs, backend }) => {
          const { a, b } = inputs;
          const cpuBackend = backend;
          assertNotComplex2([a, b], name);
          const aVals = cpuBackend.data.get(a.dataId).values;
          const bVals = cpuBackend.data.get(b.dataId).values;
          const decodedAVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
          const decodedBVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
          const $dtype = dtype || a.dtype;
          const [resultData, resultShape] = simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
          return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        };
      }
      return ({ inputs, backend }) => {
        const { a, b } = inputs;
        const cpuBackend = backend;
        if (a.dtype === "complex64" || b.dtype === "complex64") {
          const $aComplex = cast2({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: "complex64" } });
          const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
          const aReal = $aComplexVals.complexTensorInfos.real;
          const aImag = $aComplexVals.complexTensorInfos.imag;
          const aRealVals = cpuBackend.data.get(aReal.dataId).values;
          const aImagVals = cpuBackend.data.get(aImag.dataId).values;
          const $bComplex = cast2({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: "complex64" } });
          const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
          const bReal = $bComplexVals.complexTensorInfos.real;
          const bImag = $bComplexVals.complexTensorInfos.imag;
          const bRealVals = cpuBackend.data.get(bReal.dataId).values;
          const bImagVals = cpuBackend.data.get(bImag.dataId).values;
          const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
          const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
          const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
          const result2 = complex2({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
          cpuBackend.disposeIntermediateTensorInfo($aComplex);
          cpuBackend.disposeIntermediateTensorInfo($bComplex);
          cpuBackend.disposeIntermediateTensorInfo(resultReal);
          cpuBackend.disposeIntermediateTensorInfo(resultImag);
          return result2;
        } else {
          const aVals = cpuBackend.data.get(a.dataId).values;
          const bVals = cpuBackend.data.get(b.dataId).values;
          const $dtype = dtype || a.dtype;
          const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
          return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        }
      };
    }
    function createComplexBinaryKernelImpl(op2) {
      return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
        const resultShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
        const resultSize = util_exports.sizeFromShape(resultShape);
        const resultRank = resultShape.length;
        const resultStrides = util_exports.computeStrides(resultShape);
        const resultRealVals = util_exports.getTypedArrayFromDType("float32", resultSize);
        const resultImagVals = util_exports.getTypedArrayFromDType("float32", resultSize);
        const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, resultShape);
        const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, resultShape);
        const aVals = backend_util_exports.mergeRealAndImagArrays(aRealVals, aImagVals);
        const bVals = backend_util_exports.mergeRealAndImagArrays(bRealVals, bImagVals);
        const aRank = aShape.length;
        const aStrides = util_exports.computeStrides(aShape);
        const bRank = bShape.length;
        const bStrides = util_exports.computeStrides(bShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
          for (let i = 0; i < resultRealVals.length; i++) {
            const aIdx = i % aVals.length;
            const bIdx = i % bVals.length;
            const result2 = op2(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
            resultRealVals[i] = result2.real;
            resultImagVals[i] = result2.imag;
          }
        } else {
          for (let i = 0; i < resultRealVals.length; i++) {
            const loc = util_exports.indexToLoc(i, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d) => aLoc[d] = 0);
            const aIndex = util_exports.locToIndex(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d) => bLoc[d] = 0);
            const bIndex = util_exports.locToIndex(bLoc, bRank, bStrides);
            const opResult = op2(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
            resultRealVals[i] = opResult.real;
            resultImagVals[i] = opResult.imag;
          }
        }
        return [resultRealVals, resultImagVals, resultShape];
      };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Add.js
    var addImpl = createSimpleBinaryKernelImpl((a, b) => a + b);
    var addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return { real: aReal + bReal, imag: aImag + bImag };
    });
    var add2 = binaryKernelFunc(Add, addImpl, addComplexImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Bincount_impl.js
    function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {
      const weightsSize = util_exports.sizeFromShape(weightsShape);
      const outVals = util_exports.makeZerosTypedArray(size, weightsDtype);
      for (let i = 0; i < xVals.length; i++) {
        const value = xVals[i];
        if (value < 0) {
          throw new Error("Input x must be non-negative!");
        }
        if (value >= size) {
          continue;
        }
        if (weightsSize > 0) {
          outVals[value] += weightsVals[i];
        } else {
          outVals[value] += 1;
        }
      }
      return outVals;
    }
    function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {
      const numRows = xBuf.shape[0];
      const numCols = xBuf.shape[1];
      const outBuf = buffer([numRows, size], weightsBuf.dtype);
      for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numCols; j++) {
          const value = xBuf.get(i, j);
          if (value < 0) {
            throw new Error("Input x must be non-negative!");
          }
          if (value >= size) {
            continue;
          }
          if (binaryOutput) {
            outBuf.set(1, i, value);
          } else {
            if (weightsBuf.size > 0) {
              outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);
            } else {
              outBuf.set(outBuf.get(i, value) + 1, i, value);
            }
          }
        }
      }
      return outBuf;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/utils/unary_impl.js
    function createSimpleUnaryImpl(op2) {
      return (values, dtype, attrs) => {
        const newValues = util_exports.getTypedArrayFromDType(dtype, values.length);
        for (let i = 0; i < values.length; ++i) {
          newValues[i] = op2(values[i], attrs);
        }
        return newValues;
      };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/utils/unary_utils.js
    function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
      return ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        assertNotComplex2(x, name);
        if (x.dtype === "string" || dtype === "string") {
          throw new Error("unaryKernelFunc does not support string input/output");
        }
        const cpuBackend = backend;
        const values = cpuBackend.data.get(x.dataId).values;
        const $dtype = dtype || x.dtype;
        const newValues = unaryImpl(values, $dtype, attrs);
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
      };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Ceil.js
    var ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
    var ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Concat_impl.js
    function concatImpl(inputs, outShape, dtype, simplyConcat) {
      const outVals = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
      if (simplyConcat && dtype !== "string") {
        let offset = 0;
        inputs.forEach((input) => {
          const size = util_exports.sizeFromShape(input.shape);
          outVals.set(input.vals, offset);
          offset += size;
        });
      } else {
        let colOffset = 0;
        inputs.forEach((input) => {
          const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(input.vals) : input.vals;
          let tIdx = 0;
          for (let row = 0; row < input.shape[0]; ++row) {
            const resIdx = row * outShape[1] + colOffset;
            for (let col = 0; col < input.shape[1]; ++col) {
              outVals[resIdx + col] = decodedData[tIdx++];
            }
          }
          colOffset += input.shape[1];
        });
      }
      return outVals;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Equal.js
    var equalImpl = createSimpleBinaryKernelImpl((a, b) => a === b ? 1 : 0);
    var equal = binaryKernelFunc(Equal, equalImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Exp.js
    var expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
    var exp = unaryKernelFuncFromImpl(Exp, expImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Expm1.js
    var expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
    var expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Floor.js
    var floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
    var floor = unaryKernelFuncFromImpl(Floor, floorImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js
    function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
      const outBuf = buffer([numSlices, sliceSize], dtype);
      for (let i = 0; i < numSlices; i++) {
        const index2 = [];
        let flattenIndex = 0;
        for (let j = 0; j < sliceRank; j++) {
          const dim = indicesData[i * sliceRank + j];
          flattenIndex += dim * strides[j];
          index2.push(dim);
        }
        if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
          throw new Error(`Invalid indices: ${index2} does not index into ${paramsShape}`);
        }
        for (let k = 0; k < sliceSize; k++) {
          outBuf.values[i * sliceSize + k] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));
        }
      }
      return outBuf;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js
    function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
      const outBuf = buffer(flattenOutputShape, xBuf.dtype);
      for (let i = 0; i < outBuf.size; ++i) {
        const newLoc = outBuf.indexToLoc(i);
        const originalLoc = newLoc.slice();
        const batchIdx = originalLoc[0];
        const indicesIdx = originalLoc[2];
        const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
        originalLoc[2] = indicesBuf.values[indicesIndex];
        const originalIndex = xBuf.locToIndex(originalLoc);
        outBuf.values[i] = xBuf.values[originalIndex];
      }
      return outBuf;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Greater.js
    var greaterImpl = createSimpleBinaryKernelImpl((a, b) => a > b ? 1 : 0);
    var greater = binaryKernelFunc(Greater, greaterImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/GreaterEqual.js
    var greaterEqualImpl = createSimpleBinaryKernelImpl((a, b) => a >= b ? 1 : 0);
    var greaterEqual = binaryKernelFunc(GreaterEqual, greaterEqualImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Less.js
    var lessImpl = createSimpleBinaryKernelImpl((a, b) => a < b ? 1 : 0);
    var less = binaryKernelFunc(Less, lessImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/LessEqual.js
    var lessEqualImpl = createSimpleBinaryKernelImpl((a, b) => a <= b ? 1 : 0);
    var lessEqual = binaryKernelFunc(LessEqual, lessEqualImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js
    function linSpaceImpl(start, stop, num) {
      const step3 = (stop - start) / (num - 1);
      const values = util_exports.makeZerosTypedArray(num, "float32");
      values[0] = start;
      for (let i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step3;
      }
      return values;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Log.js
    var logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
    var log2 = unaryKernelFuncFromImpl(Log, logImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Max_impl.js
    function maxImpl(aVals, reduceSize, outShape, dtype) {
      const vals = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(outShape));
      for (let i = 0; i < vals.length; ++i) {
        const offset = i * reduceSize;
        let max2 = aVals[offset];
        for (let j = 0; j < reduceSize; ++j) {
          const value = aVals[offset + j];
          if (Number.isNaN(value) || value > max2) {
            max2 = value;
          }
        }
        vals[i] = max2;
      }
      return vals;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Maximum.js
    var maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
    var maximum = binaryKernelFunc(Maximum, maximumImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Minimum.js
    var minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
    var minimum = binaryKernelFunc(Minimum, minimumImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Multiply.js
    var multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
    var multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return {
        real: aReal * bReal - aImag * bImag,
        imag: aReal * bImag + aImag * bReal
      };
    });
    var multiply = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Neg.js
    function negImpl(xVals, xShape, xDtype) {
      const minusOne = util_exports.createScalarValue(-1, xDtype);
      return multiplyImpl([], xShape, minusOne, xVals, xDtype);
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/NotEqual.js
    var notEqualImpl = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0);
    var notEqual = binaryKernelFunc(NotEqual, notEqualImpl, null, "bool");
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Transpose_impl.js
    function transposeImpl(xVals, xShape, dtype, perm, newShape) {
      const xRank = xShape.length;
      const xSize = util_exports.sizeFromShape(xShape);
      const xStrides = util_exports.computeStrides(xShape);
      const newStrides = util_exports.computeStrides(newShape);
      const result2 = util_exports.getTypedArrayFromDType(dtype, util_exports.sizeFromShape(newShape));
      for (let i = 0; i < xSize; ++i) {
        const loc = util_exports.indexToLoc(i, xRank, xStrides);
        const newLoc = new Array(loc.length);
        for (let i2 = 0; i2 < newLoc.length; i2++) {
          newLoc[i2] = loc[perm[i2]];
        }
        const newIndex = util_exports.locToIndex(newLoc, xRank, newStrides);
        result2[newIndex] = xVals[i];
      }
      return result2;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Prod.js
    function prodImpl(xShape, xDtype, xVals, reductionAxes) {
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, reductionAxes);
      const outDtype = upcastType(xDtype, "int32");
      const outVals = util_exports.makeZerosTypedArray(util_exports.sizeFromShape(outShape), outDtype);
      const reduceSize = util_exports.sizeFromShape(reduceShape);
      for (let i = 0; i < outVals.length; ++i) {
        const offset = i * reduceSize;
        let prod2 = 1;
        for (let j = 0; j < reduceSize; ++j) {
          prod2 *= xVals[offset + j];
        }
        outVals[i] = prod2;
      }
      return { outVals, outShape, outDtype };
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Range_impl.js
    function rangeImpl(start, stop, step3, dtype) {
      const sameStartStop = start === stop;
      const increasingRangeNegativeStep = start < stop && step3 < 0;
      const decreasingRangePositiveStep = stop < start && step3 > 1;
      if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
        return util_exports.makeZerosTypedArray(0, dtype);
      }
      const numElements = Math.abs(Math.ceil((stop - start) / step3));
      const values = util_exports.makeZerosTypedArray(numElements, dtype);
      if (stop < start && step3 === 1) {
        step3 = -1;
      }
      values[0] = start;
      for (let i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step3;
      }
      return values;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Rsqrt.js
    var rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
    var rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Slice.js
    function sliceImpl(vals, begin, size, shape, dtype) {
      const isContinous = slice_util_exports.isSliceContinous(shape, begin, size);
      const length = util_exports.sizeFromShape(size);
      const xStrides = util_exports.computeStrides(shape);
      if (isContinous) {
        const flatOffset = slice_util_exports.computeFlatOffset(begin, xStrides);
        if (dtype === "string") {
          return vals.slice(flatOffset, flatOffset + length);
        }
        return vals.subarray(flatOffset, flatOffset + length);
      }
      const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(vals) : vals;
      const inBuf = buffer(shape, dtype, decodedData);
      const outBuf = buffer(size, dtype);
      for (let i = 0; i < outBuf.size; ++i) {
        const outLoc = outBuf.indexToLoc(i);
        const inLoc = outLoc.map((idx, j) => idx + begin[j]);
        outBuf.set(inBuf.get(...inLoc), ...outLoc);
      }
      if (dtype === "string") {
        return backend_util_exports.fromStringArrayToUint8(outBuf.values);
      }
      return outBuf.values;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js
    function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
      const indicesCount = indicesShape[0];
      const denseRows = denseShape[0];
      const emptyRowIndicator = new Array(denseRows);
      const reverseIndexMap = new Array(indicesCount);
      const rank = indicesShape[1];
      if (denseRows === 0) {
        if (indicesCount !== 0) {
          throw new Error(`Received SparseTensor with denseShape[0] = 0 but
           indices.shape[0] = ${indicesCount}`);
        }
        const outputIndices = util_exports.getArrayFromDType(indicesDType, 0);
        const outputValues = util_exports.getArrayFromDType(valuesDType, 0);
        return [
          outputIndices,
          [0, rank],
          outputValues,
          emptyRowIndicator,
          reverseIndexMap
        ];
      }
      let rowsAreOrdered = true;
      let lastIndicesRow = 0;
      const csrOffset = new Array(denseRows).fill(0);
      for (let i = 0; i < indicesCount; ++i) {
        const row = indices[i * rank];
        if (row < 0) {
          throw new Error(`indices(${i}, 0) is invalid: ${row} < 0`);
        }
        if (row >= denseRows) {
          throw new Error(`indices(${i}, 0) is invalid: ${row} >= ${denseRows}`);
        }
        ++csrOffset[row];
        rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
        lastIndicesRow = row;
      }
      let allRowsFull = true;
      for (let row = 0; row < denseRows; ++row) {
        const rowEmpty = csrOffset[row] === 0;
        emptyRowIndicator[row] = rowEmpty;
        allRowsFull = allRowsFull && !rowEmpty;
        csrOffset[row] = Math.max(csrOffset[row], 1);
        if (row > 0) {
          csrOffset[row] += csrOffset[row - 1];
        }
      }
      if (allRowsFull && rowsAreOrdered) {
        const outputIndices = indices;
        const outputValues = values;
        for (let i = 0; i < indicesCount; ++i) {
          reverseIndexMap[i] = i;
        }
        return [
          outputIndices,
          [indicesCount, rank],
          outputValues,
          emptyRowIndicator,
          reverseIndexMap
        ];
      } else {
        const fullIndicesCount = csrOffset[denseRows - 1];
        const outputIndices = util_exports.getArrayFromDType(indicesDType, fullIndicesCount * rank);
        const outputValues = util_exports.getArrayFromDType(valuesDType, fullIndicesCount);
        const filledCount = new Array(denseRows).fill(0);
        for (let i = 0; i < indicesCount; ++i) {
          const row = indices[i * rank];
          const offset = filledCount[row];
          const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
          filledCount[row]++;
          for (let j = 0; j < rank; ++j) {
            outputIndices[outputI * rank + j] = indices[i * rank + j];
          }
          outputValues[outputI] = values[i];
          reverseIndexMap[i] = outputI;
        }
        for (let row = 0; row < denseRows; ++row) {
          const rowCount = filledCount[row];
          if (rowCount === 0) {
            const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
            outputIndices[startingIndex * rank + 0] = row;
            for (let col = 1; col < rank; ++col) {
              outputIndices[startingIndex * rank + col] = 0;
            }
            outputValues[startingIndex] = defaultValue;
          }
        }
        return [
          outputIndices,
          [fullIndicesCount, rank],
          outputValues,
          emptyRowIndicator,
          reverseIndexMap
        ];
      }
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js
    function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
      const denseSize = util_exports.sizeFromShape(inputShape);
      const nnz = inputIndicesShape[0];
      const outputRank = targetShape.length;
      const outputShape = [];
      let product = 1;
      let unknownIndex = -1;
      for (let d = 0; d < outputRank; ++d) {
        const size = targetShape[d];
        if (size === -1) {
          if (unknownIndex !== -1) {
            throw new Error(`only one output dimension may be -1, not both ${unknownIndex} and ${d}`);
          }
          unknownIndex = d;
          outputShape.push(1);
        } else {
          if (size < 0) {
            throw new Error(`size ${d} must be non-negative, not ${size}`);
          }
          product *= size;
          outputShape.push(size);
        }
      }
      if (unknownIndex !== -1) {
        if (product <= 0) {
          throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
        }
        const missing = Math.trunc(denseSize / product);
        if (product * missing !== denseSize) {
          throw new Error(`Input to reshape is a SparseTensor with ${denseSize}
            dense values, but the requested shape requires a multiple of ${product}. inputShape=${inputShape} outputShape= ${outputShape}`);
        }
        outputShape[unknownIndex] = missing;
      }
      const outputSize = util_exports.sizeFromShape(outputShape);
      if (outputSize !== denseSize) {
        throw new Error(`Input to reshape is a tensor with ${denseSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);
      }
      const inputRank = inputShape.length;
      const inputStrides = [];
      if (inputRank > 0) {
        inputStrides[inputRank - 1] = 1;
        for (let d = inputRank - 2; d >= 0; --d) {
          inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];
        }
      }
      const outputStrides = [];
      if (outputRank > 0) {
        outputStrides[outputRank - 1] = 1;
        for (let d = outputRank - 2; d >= 0; --d) {
          outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];
        }
      }
      const newIndices = util_exports.getArrayFromDType(inputDType, nnz * outputRank);
      for (let i = 0; i < nnz; ++i) {
        let id = 0;
        for (let j = 0; j < inputRank; ++j) {
          id += inputIndices[i * inputRank + j] * inputStrides[j];
        }
        for (let j = 0; j < outputRank; ++j) {
          newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);
          id %= outputStrides[j];
        }
      }
      return [newIndices, [nnz, outputRank], outputShape];
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js
    function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
      const numIndices = indices.length;
      if (numIndices !== segmentIds.length) {
        throw new Error(`segmentIds and indices should have same size.`);
      }
      const inputFlat = [inputShape[0], input.length / inputShape[0]];
      const numCol = inputFlat[1];
      const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
      const outputRows = lastSegmentIdPlusOne;
      if (outputRows < 0) {
        throw new Error(`segment ids must be >= 0`);
      }
      const outputShape = inputShape.slice();
      outputShape[0] = outputRows;
      const outputLength = outputShape.reduce((product, value) => product * value, 1);
      const output = util_exports.getArrayFromDType(inputDType, outputLength);
      if (numIndices === 0) {
        if (outputRows > 0) {
          output.fill(defaultValue);
        }
        return [output, outputShape];
      }
      if (outputRows <= 0) {
        throw new Error(`segment ids must be >= 0`);
      }
      let start = 0, end = 1;
      let uninitializedIndex = 0;
      let outIndex = segmentIds[start];
      while (true) {
        let nextIndex = 0;
        if (end < numIndices) {
          nextIndex = segmentIds[end];
          if (outIndex === nextIndex) {
            ++end;
            continue;
          }
          if (outIndex >= nextIndex) {
            throw new Error(`segment ids are not increasing`);
          }
        }
        if (outIndex < 0 || outIndex >= outputRows) {
          throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);
        }
        if (outIndex > uninitializedIndex) {
          output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
        }
        for (let i = start; i < end; ++i) {
          const index2 = indices[i];
          if (index2 < 0 || index2 >= inputFlat[0]) {
            throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${inputFlat[0]})`);
          }
          for (let j = 0; j < numCol; j++) {
            output[outIndex * numCol + j] += input[index2 * numCol + j];
          }
        }
        if (isMean) {
          for (let j = 0; j < numCol; j++) {
            output[outIndex * numCol + j] /= end - start;
          }
        }
        start = end;
        ++end;
        uninitializedIndex = outIndex + 1;
        outIndex = nextIndex;
        if (end > numIndices) {
          break;
        }
      }
      if (uninitializedIndex < outputRows) {
        output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
      }
      return [output, outputShape];
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/SquaredDifference.js
    var squaredDifferenceImpl = createSimpleBinaryKernelImpl((a, b) => {
      const diff = a - b;
      return diff * diff;
    });
    var squaredDifference = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js
    function stridedSliceImpl(outShape, xBuf, strides, begin) {
      const outBuf = buffer(outShape, xBuf.dtype);
      for (let i = 0; i < outBuf.size; i++) {
        const loc = outBuf.indexToLoc(i);
        const newLoc = new Array(loc.length);
        for (let j = 0; j < newLoc.length; j++) {
          newLoc[j] = loc[j] * strides[j] + begin[j];
        }
        outBuf.set(xBuf.get(...newLoc), ...loc);
      }
      return outBuf;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js
    var StringNGramsOp = class {
      constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
        this.separator = util_exports.encodeString(separator);
        this.nGramWidths = nGramWidths;
        this.leftPad = util_exports.encodeString(leftPad);
        this.rightPad = util_exports.encodeString(rightPad2);
        this.padWidth = padWidth;
        this.preserveShort = preserveShortSequences;
      }
      getPadWidth(nGramWidth) {
        return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
      }
      getNumNGrams(length, nGramWidth) {
        const padWidth = this.getPadWidth(nGramWidth);
        return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
      }
      createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
        for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {
          const padWidth = this.getPadWidth(nGramWidth);
          const leftPadding = Math.max(0, padWidth - nGramIndex);
          const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
          const numTokens = nGramWidth - (leftPadding + rightPadding);
          const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
          let nGramSize = 0;
          nGramSize += leftPadding * this.leftPad.length;
          for (let n = 0; n < numTokens; ++n) {
            nGramSize += data[dataStartIndex + n].length;
          }
          nGramSize += rightPadding * this.rightPad.length;
          const numSeparators = leftPadding + rightPadding + numTokens - 1;
          nGramSize += numSeparators * this.separator.length;
          output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
          const nGram = output[outputStartIndex + nGramIndex];
          let nextNGramIndex = 0;
          const appendToNGram = (str) => str.forEach((value) => nGram[nextNGramIndex++] = value);
          for (let n = 0; n < leftPadding; ++n) {
            appendToNGram(this.leftPad);
            appendToNGram(this.separator);
          }
          for (let n = 0; n < numTokens - 1; ++n) {
            appendToNGram(data[dataStartIndex + n]);
            appendToNGram(this.separator);
          }
          if (numTokens > 0) {
            appendToNGram(data[dataStartIndex + numTokens - 1]);
            for (let n = 0; n < rightPadding; ++n) {
              appendToNGram(this.separator);
              appendToNGram(this.rightPad);
            }
          } else {
            for (let n = 0; n < rightPadding - 1; ++n) {
              appendToNGram(this.rightPad);
              appendToNGram(this.separator);
            }
            appendToNGram(this.rightPad);
          }
        }
      }
      compute(data, splits) {
        const inputDataSize = data.length;
        const splitsSize = splits.length;
        if (splitsSize > 0) {
          let prevSplit = splits[0];
          if (prevSplit !== 0) {
            throw new Error(`First split value must be 0, got ${prevSplit}`);
          }
          for (let i = 1; i < splitsSize; ++i) {
            let validSplits = splits[i] >= prevSplit;
            validSplits = validSplits && splits[i] <= inputDataSize;
            if (!validSplits) {
              throw new Error(`Invalid split value ${splits[i]}, must be in [${prevSplit}, ${inputDataSize}]`);
            }
            prevSplit = splits[i];
          }
          if (prevSplit !== inputDataSize) {
            throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
          }
        }
        const numBatchItems = splitsSize - 1;
        const nGramsSplits = util_exports.getArrayFromDType("int32", splitsSize);
        if (inputDataSize === 0 || splitsSize === 0) {
          const empty = new Array(inputDataSize);
          for (let i = 0; i <= numBatchItems; ++i) {
            nGramsSplits[i] = 0;
          }
          return [empty, nGramsSplits];
        }
        nGramsSplits[0] = 0;
        for (let i = 1; i <= numBatchItems; ++i) {
          const length = splits[i] - splits[i - 1];
          let numNGrams = 0;
          this.nGramWidths.forEach((nGramWidth) => {
            numNGrams += this.getNumNGrams(length, nGramWidth);
          });
          if (this.preserveShort && length > 0 && numNGrams === 0) {
            numNGrams = 1;
          }
          nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;
        }
        const nGrams = new Array(nGramsSplits[numBatchItems]);
        for (let i = 0; i < numBatchItems; ++i) {
          const splitIndex = splits[i];
          let outputStartIdx = nGramsSplits[i];
          this.nGramWidths.forEach((nGramWidth) => {
            const length = splits[i + 1] - splits[i];
            const numNGrams = this.getNumNGrams(length, nGramWidth);
            this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
            outputStartIdx += numNGrams;
          });
          if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {
            const dataLength = splits[i + 1] - splits[i];
            if (dataLength === 0) {
              continue;
            }
            const nGramWidth = dataLength + 2 * this.padWidth;
            const numNGrams = 1;
            this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
          }
        }
        return [nGrams, nGramsSplits];
      }
    };
    function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
      return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js
    function split(str, delimiters, skipEmpty) {
      if (!str.length) {
        return [];
      }
      if (delimiters.length === 0) {
        const result3 = new Array(str.length);
        for (let i = 0; i < str.length; ++i) {
          result3[i] = str.subarray(i, i + 1);
        }
        return result3;
      }
      if (delimiters.length === 1) {
        const delimiter = delimiters[0];
        const result3 = [];
        let f = str.indexOf(delimiter);
        while (f !== -1) {
          const token = str.subarray(0, f);
          if (!skipEmpty || token.length !== 0) {
            result3.push(token);
          }
          str = str.subarray(f + 1);
          f = str.indexOf(delimiter);
        }
        if (!skipEmpty || str.length !== 0) {
          result3.push(str);
        }
        return result3;
      }
      const result2 = [];
      let tokenStart = 0;
      for (let i = 0; i < str.length + 1; i++) {
        if (i === str.length || delimiters.indexOf(str[i]) !== -1) {
          const token = str.subarray(tokenStart, i);
          if (!skipEmpty || token.length !== 0) {
            result2.push(token);
          }
          tokenStart = i + 1;
        }
      }
      return result2;
    }
    function stringSplitImpl(input, delimiter, skipEmpty) {
      const batchSize = input.length;
      const tokens = [];
      let outputSize = 0;
      let maxNumEntries = 0;
      const numIndices = new Array(batchSize);
      for (let i = 0; i < batchSize; ++i) {
        const parts = split(input[i], delimiter, skipEmpty);
        const nEntries = parts.length;
        numIndices[i] = nEntries;
        outputSize += nEntries;
        maxNumEntries = Math.max(maxNumEntries, nEntries);
        tokens.push(...parts);
      }
      const indices = util_exports.getArrayFromDType("int32", outputSize * 2);
      const values = new Array(outputSize);
      const shape = [batchSize, maxNumEntries];
      let c = 0;
      for (let i = 0; i < batchSize; ++i) {
        for (let j = 0; j < numIndices[i]; ++j) {
          indices[c * 2] = i;
          indices[c * 2 + 1] = j;
          values[c] = tokens[c];
          ++c;
        }
      }
      return [indices, values, shape];
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js
    function stringToHashBucketFastImpl(input, numBuckets) {
      const output = util_exports.getArrayFromDType("int32", input.length);
      for (let i = 0; i < input.length; ++i) {
        output[i] = util_exports.fingerPrint64(input[i]).modulo(numBuckets).getLowBitsUnsigned();
      }
      return output;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Sub.js
    var subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
    var subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return { real: aReal - bReal, imag: aImag - bImag };
    });
    var sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Tile_impl.js
    function tileImpl(xBuf, reps) {
      const newShape = new Array(xBuf.rank);
      for (let i = 0; i < newShape.length; i++) {
        newShape[i] = xBuf.shape[i] * reps[i];
      }
      const result2 = buffer(newShape, xBuf.dtype);
      for (let i = 0; i < result2.values.length; ++i) {
        const newLoc = result2.indexToLoc(i);
        const originalLoc = new Array(xBuf.rank);
        for (let j = 0; j < originalLoc.length; j++) {
          originalLoc[j] = newLoc[j] % xBuf.shape[j];
        }
        const originalIndex = xBuf.locToIndex(originalLoc);
        result2.values[i] = xBuf.values[originalIndex];
      }
      return result2;
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/TopK_impl.js
    function topKImpl(x, xShape, xDtype, k, sorted) {
      const lastDim = xShape[xShape.length - 1];
      const [batch, size] = [x.length / lastDim, lastDim];
      const allTopKVals = util_exports.getTypedArrayFromDType(xDtype, batch * k);
      const allTopKIndices = util_exports.getTypedArrayFromDType("int32", batch * k);
      for (let b = 0; b < batch; b++) {
        const offset = b * size;
        const vals = x.subarray(offset, offset + size);
        const valAndInd = [];
        for (let i = 0; i < vals.length; i++) {
          valAndInd.push({ value: vals[i], index: i });
        }
        valAndInd.sort((a, b2) => b2.value - a.value);
        const outOffset = b * k;
        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
        for (let i = 0; i < k; i++) {
          topKVals[i] = valAndInd[i].value;
          topKIndices[i] = valAndInd[i].index;
        }
      }
      const outputShape = xShape.slice();
      outputShape[outputShape.length - 1] = k;
      return [
        buffer(outputShape, xDtype, allTopKVals),
        buffer(outputShape, "int32", allTopKIndices)
      ];
    }
  
    // ../../../tfjs/tfjs-backend-cpu/dist/kernels/Unique_impl.js
    function uniqueImpl(values, axis, shape, dtype) {
      const $axis = util_exports.parseAxisParam(axis, shape)[0];
      const newShape = [1, shape[0], 1];
      for (let i = 0; i < $axis; i++) {
        newShape[0] *= shape[i];
      }
      newShape[1] = shape[$axis];
      for (let i = $axis + 1; i < shape.length; i++) {
        newShape[2] *= shape[i];
      }
      const uniqueElements = {};
      const indices = new Int32Array(shape[$axis]);
      const inputBuffer = new TensorBuffer(newShape, dtype, values);
      const uniqueIndices = [];
      const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
      for (let i = 0; i < shape[$axis]; i++) {
        let element;
        if (is1DTensor) {
          element = values[i].toString();
        } else {
          const axisValues = [];
          for (let m = 0; m < newShape[0]; m++) {
            for (let n = 0; n < newShape[2]; n++) {
              axisValues.push(inputBuffer.get(m, i, n));
            }
          }
          element = axisValues.join(",");
        }
        if (uniqueElements[element] !== void 0) {
          indices[i] = uniqueElements[element];
        } else {
          const uniqueIndex = Object.keys(uniqueElements).length;
          uniqueElements[element] = uniqueIndex;
          indices[i] = uniqueIndex;
          uniqueIndices.push(i);
        }
      }
      const outputTmpShape = newShape.slice();
      outputTmpShape[1] = Object.keys(uniqueElements).length;
      const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
      uniqueIndices.forEach((uniqueElementIndex, i) => {
        for (let m = 0; m < newShape[0]; m++) {
          for (let n = 0; n < newShape[2]; n++) {
            outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
          }
        }
      });
      const outputShape = shape.slice();
      outputShape[$axis] = outputTmpShape[1];
      return {
        outputValues: outputBuffer.values,
        outputShape,
        indices
      };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/shared.js
    var { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = shared_exports;
  
    // ../../../tfjs/tfjs-backend-webgl/dist/packing_util.js
    function getVecChannels(name, rank) {
      return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d) => `${name}.${d}`);
    }
    function getChannels(name, rank) {
      if (rank === 1) {
        return [name];
      }
      return getVecChannels(name, rank);
    }
    function getSourceCoords(rank, dims) {
      if (rank === 1) {
        return "rc";
      }
      let coords2 = "";
      for (let i = 0; i < rank; i++) {
        coords2 += dims[i];
        if (i < rank - 1) {
          coords2 += ",";
        }
      }
      return coords2;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/pack_gpu.js
    var PackProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const rank = outputShape.length;
        if (rank === 0) {
          this.userCode = `
          void main() {
            setOutput(vec4(getA(), 0., 0., 0.));
          }
        `;
        } else {
          const channels = getChannels("rc", rank);
          const dtype = getCoordsDataType(rank);
          const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);
          const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);
          const output = getOutput(outputShape, channels);
          this.userCode = `
          void main() {
            ${dtype} rc = getOutputCoords();
  
            if(${outOfBoundsCondition}) {
              setOutput(vec4(0));
            } else {
              ${setup}
  
              setOutput(vec4(${output}));
            }
          }
        `;
        }
      }
    };
    function getSourceCoordsArr(rank, dims) {
      const coords2 = [];
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
          for (let d = 2; d < rank; d++) {
            coord = `${dims[dims.length - 1 - d]},` + coord;
          }
          coords2.push(coord);
        }
      }
      return coords2;
    }
    function getOutOfBoundsCondition(rank, shape, dims) {
      if (rank === 1) {
        return `rc > ${shape[0]}`;
      }
      let cond = "";
      for (let i = rank - 2; i < rank; i++) {
        cond += `${dims[i]} >= ${shape[i]}`;
        if (i < rank - 1) {
          cond += "||";
        }
      }
      return cond;
    }
    function getSetup(rank, cols, rows, dims) {
      if (rank === 1) {
        return "";
      }
      const innerDims = dims.slice(-2);
      return `
      int r = ${innerDims[0]};
      int c = ${innerDims[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;
  
      bool cEdge = cp1 >= ${cols};
      bool rEdge = rp1 >= ${rows};
    `;
    }
    function getOutput(shape, dims) {
      const rank = shape.length;
      const sourceCoords = getSourceCoordsArr(rank, dims);
      if (rank === 1) {
        return `getA(rc),
              rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
              0, 0`;
      }
      return `getA(${sourceCoords[0]}),
            cEdge ? 0. : getA(${sourceCoords[1]}),
            rEdge ? 0. : getA(${sourceCoords[2]}),
            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/reshape_packed_gpu.js
    var ReshapePackedProgram = class {
      constructor(outputShape, inputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        let mainLoop = ``;
        for (let i = 0; i < 4; i++) {
          let thisRC = `thisRC = rc;`;
          if (i % 2 === 1) {
            thisRC += `thisRC.z += 1;`;
          }
          if (i > 1) {
            thisRC += `thisRC.y += 1;`;
          }
          mainLoop += `
          ${thisRC}
          ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
            int flatIndex = getFlatIndex(thisRC);
  
            ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
            vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));
  
            result[${i}] =
              getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
          ${i > 0 ? "}" : ""}
        `;
        }
        this.userCode = `
        ${getReshapedInputCoords(inputShape)}
        ${getFlatIndexFrom3D(outputShape)}
  
        void main() {
          ivec3 rc = getOutputCoords();
  
          vec4 result = vec4(0.);
  
          ivec3 thisRC;
          int rows = ${outputShape[1]};
          int cols = ${outputShape[2]};
  
          ${mainLoop}
  
          setOutput(result);
        }
      `;
      }
    };
    function getReshapedInputCoords(shape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
      return `
      ivec3 inputCoordsFromReshapedOutCoords(int index) {
        ${coordsFromIndexSnippet}
        return ivec3(r, c, d);
      }
    `;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/texture_manager.js
    var TextureManager = class {
      constructor(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
      }
      acquireTexture(shapeRC, usage, isPacked) {
        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
          this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
          this.usedTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        if (this.freeTextures[shapeKey].length > 0) {
          this.numFreeTextures--;
          this.numUsedTextures++;
          this._numBytesFree -= texBytes;
          this.log();
          const newTexture2 = this.freeTextures[shapeKey].shift();
          this.usedTextures[shapeKey].push(newTexture2);
          return newTexture2;
        }
        let newTexture;
        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
          newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
          newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
          newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
          newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
          newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        this.usedTextures[shapeKey].push(newTexture);
        this.numUsedTextures++;
        this._numBytesAllocated += texBytes;
        this.log();
        return newTexture;
      }
      releaseTexture(texture, shape, logicalTexType, isPacked) {
        if (this.freeTextures == null) {
          return;
        }
        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
          this.freeTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        const deleteTexThreshold = env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
        if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
          this.gpgpu.deleteMatrixTexture(texture);
          this._numBytesAllocated -= texBytes;
        } else {
          this.freeTextures[shapeKey].push(texture);
          this.numFreeTextures++;
          this._numBytesFree += texBytes;
        }
        this.numUsedTextures--;
        const texList = this.usedTextures[shapeKey];
        const texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
          throw new Error("Cannot release a texture that was never provided by this texture manager");
        }
        texList.splice(texIndex, 1);
        this.log();
      }
      log() {
        if (!this.logEnabled) {
          return;
        }
        const total = this.numFreeTextures + this.numUsedTextures;
        console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
        const freeRatio = this._numBytesFree / this._numBytesAllocated;
        console.log(`Bytes allocated: ${this._numBytesAllocated}`);
        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
      }
      get numBytesAllocated() {
        return this._numBytesAllocated;
      }
      get numBytesFree() {
        return this._numBytesFree;
      }
      getNumUsedTextures() {
        return this.numUsedTextures;
      }
      getNumFreeTextures() {
        return this.numFreeTextures;
      }
      dispose() {
        if (this.freeTextures == null) {
          return;
        }
        for (const texShape in this.freeTextures) {
          this.freeTextures[texShape].forEach((tex) => {
            this.gpgpu.deleteMatrixTexture(tex);
          });
        }
        for (const texShape in this.usedTextures) {
          this.usedTextures[texShape].forEach((tex) => {
            this.gpgpu.deleteMatrixTexture(tex);
          });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
      }
    };
    function numBytesForInternalFormat(gl, internalFormat) {
      const glany = gl;
      if (internalFormat === glany.R32F) {
        return 4;
      } else if (internalFormat === glany.R16F) {
        return 2;
      } else if (internalFormat === glany.RGBA32F) {
        return 16;
      } else if (internalFormat === gl.RGBA) {
        return 16;
      } else if (internalFormat === glany.RGBA16F) {
        return 8;
      }
      throw new Error(`Unknown internal format ${internalFormat}`);
    }
    function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
      const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
      let numElements;
      if (isPacked) {
        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
        numElements = packedWidth * packedHeight;
      } else {
        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
        numElements = width * height;
      }
      const bytesPerElement2 = numBytesForInternalFormat(gl, internalFormat);
      return numElements * bytesPerElement2;
    }
    function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
      switch (physicalTexType) {
        case PhysicalTextureType.PACKED_2X2_FLOAT32:
          return getInternalFormatForPackedMatrixTexture(textureConfig);
        case PhysicalTextureType.PACKED_2X2_FLOAT16:
          return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
        case PhysicalTextureType.UNPACKED_FLOAT32:
          return getInternalFormatForFloat32MatrixTexture(textureConfig);
        case PhysicalTextureType.UNPACKED_FLOAT16:
          return getInternalFormatForFloat16MatrixTexture(textureConfig);
        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
          return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
        default:
          throw new Error(`Unknown physical texture type ${physicalTexType}`);
      }
    }
    function getPhysicalTextureForRendering(isPacked) {
      if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
        if (isPacked) {
          return PhysicalTextureType.PACKED_2X2_FLOAT32;
        }
        return PhysicalTextureType.UNPACKED_FLOAT32;
      }
      if (isPacked) {
        return PhysicalTextureType.PACKED_2X2_FLOAT16;
      }
      return PhysicalTextureType.UNPACKED_FLOAT16;
    }
    function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
      if (logicalTexType === TextureUsage.UPLOAD) {
        return PhysicalTextureType.PACKED_2X2_FLOAT32;
      } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
        return getPhysicalTextureForRendering(isPacked);
      } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
      }
      throw new Error(`Unknown logical texture type ${logicalTexType}`);
    }
    function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
      return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/unaryop_gpu.js
    var UnaryOpProgram = class {
      constructor(aShape, opSnippet) {
        this.variableNames = ["A"];
        this.outputShape = aShape;
        this.userCode = `
        float unaryOperation(float x) {
          ${opSnippet}
        }
  
        void main() {
          float x = getAAtOutCoords();
          float y = unaryOperation(x);
  
          setOutput(y);
        }
      `;
      }
    };
    var CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;
    var LINEAR = `return x;`;
    var ABS = `return abs(x);`;
    var ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
    var RELU = CHECK_NAN_SNIPPET + `
    return (x < 0.0) ? 0.0 : x;
  `;
    var RELU6 = CHECK_NAN_SNIPPET + `
    return (x < 0.0) ? 0.0 : min(6.0, x);
  `;
    var CLONE = "return x;";
    var SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  
    // ../../../tfjs/tfjs-backend-webgl/dist/unaryop_packed_gpu.js
    var LINEAR2 = `return x;`;
    var ELU2 = `
    vec4 result;
  
    result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
    result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
    result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
    result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);
  
    return result;
  `;
    var RELU2 = `
    vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
    bvec4 isNaN = isnan(x);
  
    result.r = isNaN.r ? x.r : result.r;
    result.g = isNaN.g ? x.g : result.g;
    result.b = isNaN.b ? x.b : result.b;
    result.a = isNaN.a ? x.a : result.a;
  
    return result;
  `;
    var RELU62 = `
    vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
    bvec4 isNaN = isnan(x);
  
    result.r = isNaN.r ? x.r : result.r;
    result.g = isNaN.g ? x.g : result.g;
    result.b = isNaN.b ? x.b : result.b;
    result.a = isNaN.a ? x.a : result.a;
  
    return result;
  `;
    var SIGMOID2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
    var UnaryOpPackedProgram = class {
      constructor(aShape, opSnippet) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
        vec4 unaryOperation(vec4 x) {
          ${opSnippet}
        }
  
        void main() {
          vec4 x = getAAtOutCoords();
          vec4 y = unaryOperation(x);
  
          setOutput(y);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/unpack_gpu.js
    var UnpackProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outputShape = outputShape;
        const rank = outputShape.length;
        const channels = getChannels("rc", rank);
        const dtype = getCoordsDataType(rank);
        const sourceCoords = getSourceCoords(rank, channels);
        const innerDims = channels.slice(-2);
        const coords2 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
        this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();
          vec4 packedInput = getA(${sourceCoords});
  
          setOutput(getChannel(packedInput, ${coords2}));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/backend_webgl.js
    var whereImpl2 = kernel_impls_exports.whereImpl;
    var EPSILON_FLOAT322 = 1e-7;
    var EPSILON_FLOAT162 = 1e-4;
    var binaryCaches = {};
    function getBinaryCache(webGLVersion) {
      if (webGLVersion in binaryCaches) {
        return binaryCaches[webGLVersion];
      }
      binaryCaches[webGLVersion] = {};
      return binaryCaches[webGLVersion];
    }
    var CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
    var BEFORE_PAGING_CONSTANT = 600;
    function numMBBeforeWarning() {
      if (env().global.screen == null) {
        return 1024;
      }
      return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
    }
    var MathBackendWebGL = class extends KernelBackend {
      constructor(gpgpu) {
        super();
        this.pendingRead = new WeakMap();
        this.pendingDisposal = new WeakSet();
        this.dataRefCount = new WeakMap();
        this.numBytesInGPU = 0;
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.lastGlFlushTime = 0;
        this.warnedAboutMemory = false;
        this.pendingDeletes = 0;
        this.disposed = false;
        if (!env().getBool("HAS_WEBGL")) {
          throw new Error("WebGL is not supported on this device");
        }
        if (gpgpu == null) {
          const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"));
          this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
          this.gpgpu = new GPGPUContext(gl);
          this.canvas = gl.canvas;
          this.gpgpuCreatedLocally = true;
        } else {
          this.gpgpu = gpgpu;
          this.binaryCache = {};
          this.gpgpuCreatedLocally = false;
          this.canvas = gpgpu.gl.canvas;
        }
        this.textureManager = new TextureManager(this.gpgpu);
        this.numMBBeforeWarning = numMBBeforeWarning();
        this.texData = new DataStorage(this, engine());
      }
      nextDataId() {
        return MathBackendWebGL.nextDataId++;
      }
      numDataIds() {
        return this.texData.numDataIds() - this.pendingDeletes;
      }
      write(values, shape, dtype) {
        if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
          this.checkNumericalProblems(values);
        }
        if (dtype === "complex64" && values != null) {
          throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
        }
        const dataId = { id: this.nextDataId() };
        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
        return dataId;
      }
      refCount(dataId) {
        if (this.texData.has(dataId)) {
          const tensorData = this.texData.get(dataId);
          return tensorData.refCount;
        }
        return 0;
      }
      incRef(dataId) {
        const texData = this.texData.get(dataId);
        texData.refCount++;
      }
      decRef(dataId) {
        if (this.texData.has(dataId)) {
          const texData = this.texData.get(dataId);
          texData.refCount--;
        }
      }
      move(dataId, values, shape, dtype, refCount) {
        if (env().getBool("DEBUG")) {
          this.checkNumericalProblems(values);
        }
        if (dtype === "complex64") {
          throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
        }
        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
      }
      disposeIntermediateTensorInfo(tensorInfo) {
        this.disposeData(tensorInfo.dataId);
      }
      readSync(dataId) {
        const texData = this.texData.get(dataId);
        const { values, dtype, complexTensorInfos, slice: slice2, shape, isPacked } = texData;
        if (slice2 != null) {
          let program;
          if (isPacked) {
            program = new UnaryOpPackedProgram(shape, CLONE);
          } else {
            program = new UnaryOpProgram(shape, CLONE);
          }
          const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
          const data = this.readSync(res.dataId);
          this.disposeIntermediateTensorInfo(res);
          return data;
        }
        if (values != null) {
          return this.convertAndCacheOnCPU(dataId);
        }
        if (dtype === "string") {
          return values;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
          start = util_exports.now();
        }
        let result2;
        if (dtype === "complex64") {
          const realValues = this.readSync(complexTensorInfos.real.dataId);
          const imagValues = this.readSync(complexTensorInfos.imag.dataId);
          result2 = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
        } else {
          result2 = this.getValuesFromTexture(dataId);
        }
        if (shouldTimeProgram) {
          this.downloadWaitMs += util_exports.now() - start;
        }
        return this.convertAndCacheOnCPU(dataId, result2);
      }
      read(dataId) {
        return __async(this, null, function* () {
          if (this.pendingRead.has(dataId)) {
            const subscribers2 = this.pendingRead.get(dataId);
            return new Promise((resolve) => subscribers2.push(resolve));
          }
          const texData = this.texData.get(dataId);
          const { values, shape, slice: slice2, dtype, complexTensorInfos, isPacked } = texData;
          if (slice2 != null) {
            let program;
            if (isPacked) {
              program = new UnaryOpPackedProgram(shape, CLONE);
            } else {
              program = new UnaryOpProgram(shape, CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const data = this.read(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
          }
          if (values != null) {
            return this.convertAndCacheOnCPU(dataId);
          }
          if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
            throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
          }
          let buffer2 = null;
          let tmpDownloadTarget;
          if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
            tmpDownloadTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpDownloadTarget.dataId);
            buffer2 = this.gpgpu.createBufferFromTexture(tmpData.texture, ...getDenseTexShape(shape));
          }
          this.pendingRead.set(dataId, []);
          if (dtype !== "complex64") {
            yield this.gpgpu.createAndWaitForFence();
          }
          let vals;
          if (dtype === "complex64") {
            const ps = yield Promise.all([
              this.read(complexTensorInfos.real.dataId),
              this.read(complexTensorInfos.imag.dataId)
            ]);
            const realValues = ps[0];
            const imagValues = ps[1];
            vals = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
          } else if (buffer2 == null) {
            vals = this.getValuesFromTexture(dataId);
          } else {
            const size = util_exports.sizeFromShape(shape);
            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer2, size);
          }
          if (tmpDownloadTarget != null) {
            this.disposeIntermediateTensorInfo(tmpDownloadTarget);
          }
          if (buffer2 != null) {
            const gl = this.gpgpu.gl;
            callAndCheck(gl, () => gl.deleteBuffer(buffer2));
          }
          const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
          const subscribers = this.pendingRead.get(dataId);
          this.pendingRead.delete(dataId);
          subscribers.forEach((resolve) => resolve(dTypeVals));
          if (this.pendingDisposal.has(dataId)) {
            this.pendingDisposal.delete(dataId);
            if (this.disposeData(dataId)) {
              engine().removeDataId(dataId, this);
            }
            this.pendingDeletes--;
          }
          return dTypeVals;
        });
      }
      bufferSync(t) {
        const data = this.readSync(t.dataId);
        let decodedData = data;
        if (t.dtype === "string") {
          try {
            decodedData = data.map((d) => util_exports.decodeString(d));
          } catch (_a) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
        }
        return buffer(t.shape, t.dtype, decodedData);
      }
      checkNumericalProblems(values) {
        if (values == null) {
          return;
        }
        for (let i = 0; i < values.length; i++) {
          const num = values[i];
          if (!canBeRepresented(num)) {
            if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
              throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
            }
            throw Error(`The value ${num} cannot be represented on this device.`);
          }
        }
      }
      getValuesFromTexture(dataId) {
        const { shape, dtype, isPacked } = this.texData.get(dataId);
        const size = util_exports.sizeFromShape(shape);
        if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          const tmpTarget = this.decode(dataId);
          const tmpData2 = this.texData.get(tmpTarget.dataId);
          const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture, ...getDenseTexShape(shape)).subarray(0, size);
          this.disposeIntermediateTensorInfo(tmpTarget);
          return vals2;
        }
        const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
        const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
        const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
        const tmpData = this.texData.get(output.dataId);
        const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
        this.disposeIntermediateTensorInfo(output);
        return vals;
      }
      timerAvailable() {
        return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
      }
      time(f) {
        return __async(this, null, function* () {
          const oldActiveTimers = this.activeTimers;
          const newActiveTimers = [];
          let outerMostTime = false;
          if (this.programTimersStack == null) {
            this.programTimersStack = newActiveTimers;
            outerMostTime = true;
          } else {
            this.activeTimers.push(newActiveTimers);
          }
          this.activeTimers = newActiveTimers;
          f();
          const flattenedActiveTimerQueries = util_exports.flatten(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
          const flattenedActiveTimerNames = util_exports.flatten(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
          this.activeTimers = oldActiveTimers;
          if (outerMostTime) {
            this.programTimersStack = null;
          }
          const res = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null
          };
          if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
            const kernelMs = yield Promise.all(flattenedActiveTimerQueries);
            res["kernelMs"] = util_exports.sum(kernelMs);
            res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d })).map((d) => `${d.name}: ${d.ms}`).join(", ");
          } else {
            res["kernelMs"] = {
              error: "WebGL query timers are not supported in this environment."
            };
          }
          this.uploadWaitMs = 0;
          this.downloadWaitMs = 0;
          return res;
        });
      }
      memory() {
        return {
          unreliable: false,
          numBytesInGPU: this.numBytesInGPU,
          numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
          numBytesInGPUFree: this.textureManager.numBytesFree
        };
      }
      startTimer() {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          return this.gpgpu.beginQuery();
        }
        return { startMs: util_exports.now(), endMs: null };
      }
      endTimer(query) {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          this.gpgpu.endQuery();
          return query;
        }
        query.endMs = util_exports.now();
        return query;
      }
      getQueryTime(query) {
        return __async(this, null, function* () {
          if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
            return this.gpgpu.waitForQueryAndGetTime(query);
          }
          const timerQuery = query;
          return timerQuery.endMs - timerQuery.startMs;
        });
      }
      disposeData(dataId, force = false) {
        if (this.pendingDisposal.has(dataId)) {
          return false;
        }
        if (!this.texData.has(dataId)) {
          return true;
        }
        if (force) {
          this.texData.get(dataId).refCount = 0;
        } else {
          this.texData.get(dataId).refCount--;
        }
        if (!force && this.texData.get(dataId).refCount > 0) {
          return false;
        }
        if (this.pendingRead.has(dataId)) {
          this.pendingDisposal.add(dataId);
          this.pendingDeletes++;
          return false;
        }
        this.releaseGPUData(dataId);
        const { complexTensorInfos } = this.texData.get(dataId);
        if (complexTensorInfos != null) {
          this.disposeData(complexTensorInfos.real.dataId, force);
          this.disposeData(complexTensorInfos.imag.dataId, force);
        }
        this.texData.delete(dataId);
        return true;
      }
      releaseGPUData(dataId) {
        const { texture, dtype, texShape, usage, isPacked, slice: slice2 } = this.texData.get(dataId);
        const key = slice2 && slice2.origDataId || dataId;
        const refCount = this.dataRefCount.get(key);
        if (refCount > 1) {
          this.dataRefCount.set(key, refCount - 1);
        } else {
          this.dataRefCount.delete(key);
          if (texture != null) {
            this.numBytesInGPU -= this.computeBytes(texShape, dtype);
            this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
          }
        }
        const texData = this.texData.get(dataId);
        texData.texture = null;
        texData.texShape = null;
        texData.isPacked = false;
        texData.slice = null;
      }
      getTexture(dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
      }
      getDataInfo(dataId) {
        return this.texData.get(dataId);
      }
      shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
        return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input) => this.texData.get(input.dataId).texture == null && util_exports.sizeFromShape(input.shape) < sizeThreshold);
      }
      getGPGPUContext() {
        return this.gpgpu;
      }
      where(condition) {
        backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        const condVals = condition.dataSync();
        return whereImpl2(condition.shape, condVals);
      }
      packedUnaryOp(x, op2, dtype) {
        const program = new UnaryOpPackedProgram(x.shape, op2);
        const outInfo = this.compileAndRun(program, [x], dtype);
        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
      }
      abs(x) {
        if (this.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
          const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, ABS, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, ABS);
        const outInfo = this.compileAndRun(program, [x]);
        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
      }
      makeTensorInfo(shape, dtype, values) {
        let dataId;
        if (dtype === "string" && values != null && values.length > 0 && util_exports.isString(values[0])) {
          const encodedValues = values.map((d) => util_exports.encodeString(d));
          dataId = this.write(encodedValues, shape, dtype);
        } else {
          dataId = this.write(values, shape, dtype);
        }
        this.texData.get(dataId).usage = null;
        return { dataId, shape, dtype };
      }
      makeOutput(shape, dtype, values) {
        const { dataId } = this.makeTensorInfo(shape, dtype, values);
        return engine().makeTensorFromDataId(dataId, shape, dtype, this);
      }
      unpackTensor(input) {
        const program = new UnpackProgram(input.shape);
        return this.runWebGLProgram(program, [input], input.dtype);
      }
      packTensor(input) {
        const program = new PackProgram(input.shape);
        const preventEagerUnpackingOutput = true;
        return this.runWebGLProgram(program, [input], input.dtype, null, preventEagerUnpackingOutput);
      }
      packedReshape(input, afterShape) {
        const input3DShape = [
          getBatchDim(input.shape),
          ...getRowsCols(input.shape)
        ];
        const input3D = {
          dtype: input.dtype,
          shape: input3DShape,
          dataId: input.dataId
        };
        const afterShapeAs3D = [
          getBatchDim(afterShape),
          ...getRowsCols(afterShape)
        ];
        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
        const preventEagerUnpackingOfOutput = true;
        const output = this.runWebGLProgram(program, [input3D], input.dtype, null, preventEagerUnpackingOfOutput);
        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
      }
      decode(dataId) {
        const texData = this.texData.get(dataId);
        const { isPacked, shape, dtype } = texData;
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        if (isPacked) {
          program = new DecodeMatrixPackedProgram(shapeAs3D);
        } else {
          program = new DecodeMatrixProgram(shapeAs3D);
        }
        const preventEagerUnpackingOfOutput = true;
        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, null, preventEagerUnpackingOfOutput);
        return { dtype, shape, dataId: out.dataId };
      }
      runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        const output = this.makeTensorInfo(program.outputShape, outputDtype);
        const outData = this.texData.get(output.dataId);
        if (program.packedOutput) {
          outData.isPacked = true;
        }
        if (program.outPackingScheme === PackingScheme.DENSE) {
          const texelShape = getDenseTexShape(program.outputShape);
          outData.texShape = texelShape.map((d) => d * 2);
        }
        if (program.outTexUsage != null) {
          outData.usage = program.outTexUsage;
        }
        if (util_exports.sizeFromShape(output.shape) === 0) {
          outData.values = util_exports.getTypedArrayFromDType(output.dtype, 0);
          return output;
        }
        const dataToDispose = [];
        const inputsData = inputs.map((input) => {
          if (input.dtype === "complex64") {
            throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
          }
          let texData = this.texData.get(input.dataId);
          if (texData.texture == null) {
            if (!program.packedInputs && util_exports.sizeFromShape(input.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
              return {
                shape: input.shape,
                texData: null,
                isUniform: true,
                uniformValues: texData.values
              };
            }
            if (program.packedInputs) {
              texData.isPacked = true;
              texData.shape = input.shape;
            }
          } else if (!!texData.isPacked !== !!program.packedInputs) {
            input = texData.isPacked ? this.unpackTensor(input) : this.packTensor(input);
            dataToDispose.push(input);
            texData = this.texData.get(input.dataId);
          } else if (texData.isPacked && !isReshapeFree(texData.shape, input.shape)) {
            const savedInput = input;
            const targetShape = input.shape;
            input.shape = texData.shape;
            input = this.packedReshape(input, targetShape);
            dataToDispose.push(input);
            texData = this.texData.get(input.dataId);
            savedInput.shape = targetShape;
          }
          this.uploadToGPU(input.dataId);
          return { shape: input.shape, texData, isUniform: false };
        });
        this.uploadToGPU(output.dataId);
        const outputData = { shape: output.shape, texData: outData, isUniform: false };
        const key = makeShaderKey(program, inputsData, outputData);
        const binary = this.getAndSaveBinary(key, () => {
          return compileProgram(this.gpgpu, program, inputsData, outputData);
        });
        const shouldTimeProgram = this.activeTimers != null;
        let query;
        if (shouldTimeProgram) {
          query = this.startTimer();
        }
        runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);
        dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
        if (shouldTimeProgram) {
          query = this.endTimer(query);
          this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
        }
        const glFlushThreshold = env().get("WEBGL_FLUSH_THRESHOLD");
        if (glFlushThreshold > 0) {
          const time = util_exports.now();
          if (time - this.lastGlFlushTime > glFlushThreshold) {
            this.gpgpu.gl.flush();
            this.lastGlFlushTime = time;
          }
        }
        if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
          const unpacked = this.unpackTensor(output);
          this.disposeIntermediateTensorInfo(output);
          return unpacked;
        }
        return output;
      }
      compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        outputDtype = outputDtype || inputs[0].dtype;
        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);
        return outInfo;
      }
      getAndSaveBinary(key, getBinary) {
        if (!(key in this.binaryCache)) {
          this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
      }
      getTextureManager() {
        return this.textureManager;
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        if (!env().getBool("IS_TEST")) {
          const allKeys = Object.keys(this.binaryCache);
          allKeys.forEach((key) => {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
            delete this.binaryCache[key];
          });
        }
        this.textureManager.dispose();
        if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
          this.canvas.remove();
        } else {
          this.canvas = null;
        }
        if (this.gpgpuCreatedLocally) {
          this.gpgpu.program = null;
          this.gpgpu.dispose();
        }
        this.disposed = true;
      }
      floatPrecision() {
        if (this.floatPrecisionValue == null) {
          this.floatPrecisionValue = tidy(() => {
            if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
              const debugFlag = env().getBool("DEBUG");
              env().set("DEBUG", false);
              const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
              env().set("DEBUG", debugFlag);
              if (underflowCheckValue > 0) {
                return 32;
              }
            }
            return 16;
          });
        }
        return this.floatPrecisionValue;
      }
      epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
      }
      uploadToGPU(dataId) {
        const texData = this.texData.get(dataId);
        const { shape, dtype, values, texture, usage, isPacked } = texData;
        if (texture != null) {
          return;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
          start = util_exports.now();
        }
        let texShape = texData.texShape;
        if (texShape == null) {
          texShape = getTextureShapeFromLogicalShape(shape, isPacked);
          texData.texShape = texShape;
        }
        if (values != null) {
          const shapeAs3D = getShapeAs3D(shape);
          let program;
          let width = texShape[1], height = texShape[0];
          const isByteArray = values instanceof Uint8Array;
          if (isPacked) {
            [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
            program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);
          } else {
            program = new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);
          }
          const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);
          if (isByteArray) {
            this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.PIXELS;
          } else {
            this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.UPLOAD;
          }
          this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
          const preventEagerUnpacking = true;
          const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);
          const outputTexData = this.texData.get(encodedOutputTarget.dataId);
          texData.texture = outputTexData.texture;
          texData.texShape = outputTexData.texShape;
          texData.isPacked = outputTexData.isPacked;
          texData.usage = outputTexData.usage;
          this.disposeIntermediateTensorInfo(tempDenseInputHandle);
          this.texData.delete(encodedOutputTarget.dataId);
          texData.values = null;
          if (shouldTimeProgram) {
            this.uploadWaitMs += util_exports.now() - start;
          }
        } else {
          const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
          texData.texture = newTexture;
        }
      }
      convertAndCacheOnCPU(dataId, float32Values) {
        const texData = this.texData.get(dataId);
        const { dtype } = texData;
        this.releaseGPUData(dataId);
        if (float32Values != null) {
          texData.values = float32ToTypedArray(float32Values, dtype);
        }
        return texData.values;
      }
      acquireTexture(texShape, texType, dtype, isPacked) {
        this.numBytesInGPU += this.computeBytes(texShape, dtype);
        if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
          const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = true;
          console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(texShape, texType, isPacked);
      }
      computeBytes(shape, dtype) {
        return shape[0] * shape[1] * util_exports.bytesPerElement(dtype);
      }
    };
    MathBackendWebGL.nextDataId = 0;
    function float32ToTypedArray(a, dtype) {
      if (dtype === "float32" || dtype === "complex64") {
        return a;
      } else if (dtype === "int32" || dtype === "bool") {
        const result2 = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
        for (let i = 0; i < result2.length; ++i) {
          result2[i] = Math.round(a[i]);
        }
        return result2;
      } else {
        throw new Error(`Unknown dtype ${dtype}`);
      }
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/base.js
    if (device_util_exports.isBrowser()) {
      registerBackend("webgl", () => new MathBackendWebGL(), 2);
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/binaryop_gpu.js
    var CHECK_NAN_SNIPPET2 = `
    if (isnan(a)) return a;
    if (isnan(b)) return b;
  `;
    var BinaryOpProgram = class {
      constructor(op2, aShape, bShape) {
        this.variableNames = ["A", "B"];
        this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = `
        float binaryOperation(float a, float b) {
          ${op2}
        }
  
        void main() {
          float a = getAAtOutCoords();
          float b = getBAtOutCoords();
          setOutput(binaryOperation(a, b));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/binaryop_packed_gpu.js
    var CHECK_NAN_SNIPPET3 = `
    result.r = isNaN.r > 0. ? NAN : result.r;
    result.g = isNaN.g > 0. ? NAN : result.g;
    result.b = isNaN.b > 0. ? NAN : result.b;
    result.a = isNaN.a > 0. ? NAN : result.a;
  `;
    var BinaryOpPackedProgram = class {
      constructor(op2, aShape, bShape, checkOutOfBounds = false) {
        this.variableNames = ["A", "B"];
        this.supportsBroadcasting = true;
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
        const rank = this.outputShape.length;
        let checkOutOfBoundsString = "";
        if (checkOutOfBounds) {
          if (rank === 0 || util_exports.sizeFromShape(this.outputShape) === 1) {
            checkOutOfBoundsString = `
            result.y = 0.;
            result.z = 0.;
            result.w = 0.;
          `;
          } else {
            const dtype = getCoordsDataType(rank);
            checkOutOfBoundsString = `
            ${dtype} coords = getOutputCoords();
          `;
            if (rank === 1) {
              checkOutOfBoundsString += `
              result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
              result.z = 0.;
              result.w = 0.;
            `;
            } else {
              const channels = getChannels("coords", rank);
              checkOutOfBoundsString += `
              bool nextRowOutOfBounds =
                (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
              bool nextColOutOfBounds =
                (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
              result.y = nextColOutOfBounds ? 0. : result.y;
              result.z = nextRowOutOfBounds ? 0. : result.z;
              result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
            `;
            }
          }
        }
        this.userCode = `
        vec4 binaryOperation(vec4 a, vec4 b) {
          ${op2}
        }
  
        void main() {
          vec4 a = getAAtOutCoords();
          vec4 b = getBAtOutCoords();
  
          vec4 result = binaryOperation(a, b);
          ${checkOutOfBoundsString}
  
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Identity.js
    function identity2(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      backend.incRef(x.dataId);
      return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
    }
    var identityConfig = {
      kernelName: Identity,
      backendName: "webgl",
      kernelFunc: identity2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Complex.js
    function complex3(args) {
      const { inputs, backend } = args;
      const { real: real3, imag: imag2 } = inputs;
      const complexInfo = backend.makeTensorInfo(real3.shape, "complex64");
      const complex4 = backend.texData.get(complexInfo.dataId);
      const realTensorInfo = identity2({ inputs: { x: real3 }, backend });
      const imagTensorInfo = identity2({ inputs: { x: imag2 }, backend });
      complex4.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
      return complexInfo;
    }
    var complexConfig = {
      kernelName: Complex,
      backendName: "webgl",
      kernelFunc: complex3
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LeakyRelu.js
    var LEAKYRELU = `return (a < 0.) ? b * a : a;`;
    var LEAKYRELU_PACKED = `
    vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
    return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
  `;
    function leakyRelu2(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { alpha } = attrs;
      const $alpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(alpha, "float32"));
      const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);
      const result2 = backend.runWebGLProgram(program, [x, $alpha], x.dtype);
      backend.disposeIntermediateTensorInfo($alpha);
      return result2;
    }
    var leakyReluConfig = {
      kernelName: LeakyRelu,
      backendName: "webgl",
      kernelFunc: leakyRelu2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Prelu.js
    var PRELU = `return (a < 0.) ? b * a : a;`;
    var PRELU_PACKED = `
    vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
    return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
  `;
    function prelu2(args) {
      const { inputs, backend } = args;
      const { x, alpha } = inputs;
      const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) : new BinaryOpProgram(PRELU, x.shape, alpha.shape);
      return backend.runWebGLProgram(program, [x, alpha], x.dtype);
    }
    var preluConfig = {
      kernelName: Prelu,
      backendName: "webgl",
      kernelFunc: prelu2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js
    var CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
    var CHECK_NAN_SNIPPET_BINARY = `
    if (isnan(a)) return a;
    if (isnan(b)) return b;
  `;
    var CHECK_NAN_SNIPPET_BINARY_PACKED = `
    result.r = isNaN.r > 0. ? NAN : result.r;
    result.g = isNaN.g > 0. ? NAN : result.g;
    result.b = isNaN.b > 0. ? NAN : result.b;
    result.a = isNaN.a > 0. ? NAN : result.a;
  `;
    function unaryKernelFunc({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
      return ({ inputs, backend }) => {
        const { x } = inputs;
        const webglBackend = backend;
        const $dtype = dtype || x.dtype;
        if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
          const xData = webglBackend.texData.get(x.dataId);
          const outValues = cpuKernelImpl(xData.values, $dtype);
          return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
        }
        const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) {
          program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);
        } else {
          program = new UnaryOpProgram(x.shape, opSnippet);
        }
        return webglBackend.runWebGLProgram(program, [x], $dtype);
      };
    }
    function binaryKernelFunc2({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
      return ({ inputs, backend }) => {
        const { a, b } = inputs;
        const webglBackend = backend;
        if (supportsComplex && a.dtype === "complex64") {
          const aData = webglBackend.texData.get(a.dataId);
          const bData = webglBackend.texData.get(b.dataId);
          const [real3, imag2] = [
            [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
            [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
          ].map((complexParts) => {
            const [aPart, bPart] = complexParts;
            const aHandle = {
              dataId: aPart.dataId,
              dtype: aPart.dtype,
              shape: a.shape
            };
            const bHandle = {
              dataId: bPart.dataId,
              dtype: bPart.dtype,
              shape: b.shape
            };
            const program2 = new BinaryOpProgram(opSnippet, a.shape, b.shape);
            return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
          });
          const complexOutput = complex3({ inputs: { real: real3, imag: imag2 }, backend: webglBackend });
          webglBackend.disposeIntermediateTensorInfo(real3);
          webglBackend.disposeIntermediateTensorInfo(imag2);
          return complexOutput;
        }
        const $dtype = dtype || upcastType(a.dtype, b.dtype);
        if ((a.dtype === "string" || b.dtype === "string" || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {
          const aVals = webglBackend.texData.get(a.dataId).values;
          const bVals = webglBackend.texData.get(b.dataId).values;
          const decodedAVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
          const decodedBVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
          const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
          const out = webglBackend.makeTensorInfo(outShape, $dtype);
          const outData = webglBackend.texData.get(out.dataId);
          outData.values = outValues;
          return out;
        }
        const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) {
          program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
        } else {
          program = new BinaryOpProgram(opSnippet, a.shape, b.shape);
        }
        return webglBackend.runWebGLProgram(program, [a, b], $dtype);
      };
    }
    function mapActivationToShaderProgram(activation, packed = false) {
      if (activation === "linear") {
        if (packed) {
          return LINEAR2;
        }
        return LINEAR;
      } else if (activation === "relu") {
        if (packed) {
          return RELU2;
        }
        return RELU;
      } else if (activation === "elu") {
        if (packed) {
          return ELU2;
        }
        return ELU;
      } else if (activation === "relu6") {
        if (packed) {
          return RELU62;
        }
        return RELU6;
      } else if (activation === "prelu") {
        if (packed) {
          return PRELU_PACKED;
        }
        return PRELU;
      } else if (activation === "leakyrelu") {
        if (packed) {
          return LEAKYRELU_PACKED;
        }
        return LEAKYRELU;
      } else if (activation === "sigmoid") {
        if (packed) {
          return SIGMOID2;
        }
        return SIGMOID;
      }
      throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/mulmat_packed_gpu.js
    var MatMulPackedProgram = class {
      constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
        this.variableNames = ["matrixA", "matrixB"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const sharedDim = transposeA ? aShape[1] : aShape[2];
        const sharedDimensionPacked = Math.ceil(sharedDim / 2);
        const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
        const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
        const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
        const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation) {
          if (hasPreluActivation) {
            activationSnippet = `vec4 activation(vec4 a) {
            vec4 b = getPreluActivationWeightsAtOutCoords();
            ${activation}
          }`;
          } else if (hasLeakyreluActivation) {
            activationSnippet = `vec4 activation(vec4 a) {
            vec4 b = getLeakyreluAlphaAtOutCoords();
            ${activation}
          }`;
          } else {
            activationSnippet = `vec4 activation(vec4 x) {
            ${activation}
          }`;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        if (hasLeakyreluActivation) {
          this.variableNames.push("leakyreluAlpha");
        }
        let batchASnippet = "rc.x";
        let batchBSnippet = "rc.x";
        if (aShape[0] < bShape[0]) {
          batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
        } else if (bShape[0] < aShape[0]) {
          batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
        }
        this.userCode = `
        ${activationSnippet}
  
        const float sharedDimension = ${sharedDimensionPacked}.0;
  
        vec4 dot2x2ARowBCol(ivec3 rc) {
          vec4 result = vec4(0);
          for (int i = 0; i < ${sharedDimensionPacked}; i++) {
            int batchA = ${batchASnippet};
            int batchB = ${batchBSnippet};
            vec4 a = getMatrixA(batchA, ${aSample});
            vec4 b = getMatrixB(batchB, ${bSample});
  
            // These swizzled products need to be separately added.
            // See: https://github.com/tensorflow/tfjs/issues/1735
            result += (${aSwizzle[0]} * ${bSwizzle[0]});
            result += (${aSwizzle[1]} * ${bSwizzle[1]});
          }
          return result;
        }
  
        void main() {
          ivec3 rc = getOutputCoords();
          vec4 result = dot2x2ARowBCol(rc);
  
          ${addBiasSnippet}
  
          ${applyActivationSnippet}
  
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/binaryop_complex_gpu.js
    var COMPLEX_MULTIPLY = {
      REAL: "return areal * breal - aimag * bimag;",
      IMAG: "return areal * bimag + aimag * breal;"
    };
    var BinaryOpComplexProgram = class {
      constructor(op2, aShape, bShape) {
        this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
        this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = `
        float binaryOpComplex(
            float areal, float aimag, float breal, float bimag) {
          ${op2}
        }
  
        void main() {
          float areal = getARealAtOutCoords();
          float aimag = getAImagAtOutCoords();
          float breal = getBRealAtOutCoords();
          float bimag = getBImagAtOutCoords();
          setOutput(binaryOpComplex(areal, aimag, breal, bimag));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Multiply.js
    var MUL = "return a * b;";
    function multiply2(args) {
      const { inputs, backend } = args;
      const { a, b } = inputs;
      const dtype = backend_util_exports.upcastType(a.dtype, b.dtype);
      if (a.dtype === "complex64") {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
        const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
        const inputs2 = [
          {
            dataId: aData.complexTensorInfos.real.dataId,
            dtype: aData.complexTensorInfos.real.dtype,
            shape: a.shape
          },
          {
            dataId: aData.complexTensorInfos.imag.dataId,
            dtype: aData.complexTensorInfos.imag.dtype,
            shape: a.shape
          },
          {
            dataId: bData.complexTensorInfos.real.dataId,
            dtype: bData.complexTensorInfos.real.dtype,
            shape: b.shape
          },
          {
            dataId: bData.complexTensorInfos.imag.dataId,
            dtype: bData.complexTensorInfos.imag.dtype,
            shape: b.shape
          }
        ];
        const realPart = backend.runWebGLProgram(realProgram, inputs2, "float32");
        const imagPart = backend.runWebGLProgram(imagProgram, inputs2, "float32");
        const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(imagPart);
        return complexOutput;
      }
      if (backend.shouldExecuteOnCPU([a, b])) {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const [outValues, outShape] = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype);
        const out = backend.makeTensorInfo(outShape, dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
      }
      let program;
      if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
        program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);
      } else {
        program = new BinaryOpProgram(MUL, a.shape, b.shape);
      }
      return backend.runWebGLProgram(program, [a, b], dtype);
    }
    var multiplyConfig = {
      kernelName: Multiply,
      backendName: "webgl",
      kernelFunc: multiply2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/reshape.js
    function packedReshape(input, afterShape, backend) {
      const input3DShape = [
        getBatchDim(input.shape),
        ...getRowsCols(input.shape)
      ];
      const input3D = {
        dtype: input.dtype,
        shape: input3DShape,
        dataId: input.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const output = backend.runWebGLProgram(program, [input3D], input.dtype, null, preventEagerUnpackingOfOutput);
      return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Reshape.js
    function reshape2(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { shape } = attrs;
      const webglBackend = backend;
      const xSize = util_exports.sizeFromShape(x.shape);
      const $shape = util_exports.inferFromImplicitShape(shape, xSize);
      const $xSize = util_exports.sizeFromShape($shape);
      util_exports.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
      const xTexData = webglBackend.texData.get(x.dataId);
      if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
        return packedReshape(x, $shape, webglBackend);
      }
      webglBackend.incRef(x.dataId);
      return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
    }
    var reshapeConfig = {
      kernelName: Reshape,
      backendName: "webgl",
      kernelFunc: reshape2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/mean_gpu.js
    var MeanProgram = class {
      constructor(reduceInfo, divisor) {
        this.variableNames = ["x"];
        const { windowSize, batchSize, inSize, outSize } = reduceInfo;
        this.outputShape = [batchSize, outSize];
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `sumValue += dot(values, ones);`;
        if (divisor != null) {
          const denominator = 1 / divisor;
          updateSnippet = `sumValue += dot(values * ${util_exports.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
        }
        let checkOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkOutOfBounds = `
          if (inIdx < 0 || inIdx >= ${inSize}) {
            return 0.0;
          }
        `;
        }
        this.userCode = `
        const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);
  
        float getValue(int batch, int inIdx) {
          ${checkOutOfBounds}
          return getX(batch, inIdx);
        }
  
        void main() {
          ivec2 coords = getOutputCoords();
          int batch = coords[0];
          int outIdx = coords[1];
          int inOffset = outIdx * ${windowSize};
  
          float sumValue = 0.0;
  
          for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
            int inIdx = inOffset + i;
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2),
              getValue(batch, inIdx + 3)
            );
  
            ${updateSnippet}
          }
  
          int inIdx = inOffset + ${windowSizeNearestVec4};
          if (${windowSizeVec4Remainder === 1}) {
            vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1), 0.0, 0.0);
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2), 0.0);
  
            ${updateSnippet}
          }
          setOutput(sumValue);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/reduce_gpu.js
    var ReduceProgram = class {
      constructor(reduceInfo, reduceType) {
        this.variableNames = ["x"];
        const { windowSize, batchSize, inSize, outSize } = reduceInfo;
        this.outputShape = [batchSize, outSize];
        let initializationValue = "0.0";
        let compareOp = ``;
        if (reduceType === "prod") {
          initializationValue = "1.0";
        } else if (reduceType === "min") {
          initializationValue = "1.0 / 1e-20";
          compareOp = `min`;
        } else if (reduceType === "max") {
          initializationValue = "-1.0 / 1e-20";
          compareOp = `max`;
        }
        let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (reduceType === "sum") {
          returnValue = `sumValue`;
        } else if (reduceType === "prod") {
          returnValue = `prodValue`;
        } else if (reduceType === "all") {
          returnValue = `allValue`;
        } else if (reduceType === "any") {
          returnValue = `anyValue`;
        }
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `
        if (${reduceType === "sum"}) {
          sumValue += dot(values, ones);
        } else if (${reduceType === "prod"}) {
          vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
          prodValue *= tmp[0] * tmp[1];
        } else {
          minMaxValue = ${compareOp}(values, minMaxValue);
          if (${reduceType === "min"} || ${reduceType === "max"}) {
            minMaxValue = ${compareOp}(values, minMaxValue);
            bvec4 isNaN = isnan(values);
            if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
              minMaxValue = vec4(NAN);
            }
          }
        }
      `;
        let vecType = `vec4`;
        if (reduceType === "all") {
          initializationValue = "1.0";
          updateSnippet = `
          bool reducedAllValue = all(values);
          float floatedReducedAllValue = float(reducedAllValue);
          allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
        `;
          vecType = `bvec4`;
        } else if (reduceType === "any") {
          initializationValue = "0.0";
          updateSnippet = `
          bool reducedAnyValue = any(values);
          float floatedReducedAnyValue = float(reducedAnyValue);
          anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
        `;
          vecType = `bvec4`;
        }
        let checkOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkOutOfBounds = `
          if (inIdx < 0 || inIdx >= ${inSize}) {
            return initializationValue;
          }
        `;
        }
        this.userCode = `
        const float initializationValue = ${initializationValue};
        const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);
  
        float getValue(int batch, int inIdx) {
          ${checkOutOfBounds}
          return getX(batch, inIdx);
        }
  
        void main() {
          ivec2 coords = getOutputCoords();
          int batch = coords[0];
          int outIdx = coords[1];
          int inOffset = outIdx * ${windowSize};
  
          vec4 minMaxValue = vec4(${initializationValue});
          float prodValue = 1.0;
          float sumValue = 0.0;
          float allValue = 1.0;
          float anyValue = 0.0;
  
          for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
            int inIdx = inOffset + i;
            ${vecType} values = ${vecType}(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2),
              getValue(batch, inIdx + 3)
            );
  
            ${updateSnippet}
          }
  
          int inIdx = inOffset + ${windowSizeNearestVec4};
          if (${windowSizeVec4Remainder === 1}) {
            ${vecType} values = ${vecType}(
              getValue(batch, inIdx),
              initializationValue,
              initializationValue,
              initializationValue
            );
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 2}) {
            ${vecType} values = ${vecType}(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              initializationValue,
              initializationValue
            );
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 3}) {
            ${vecType} values = ${vecType}(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2),
              initializationValue
            );
  
            ${updateSnippet}
          }
          setOutput(${returnValue});
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/reduce.js
    function getReductionStages(inShape) {
      const stages = [];
      while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
        const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
        const windowSize = backend_util_exports.computeOptimalWindowSize(outSize);
        stages.push({
          inSize: outSize,
          windowSize,
          outSize: Math.ceil(outSize / windowSize)
        });
      }
      return stages;
    }
    function reduce(x, dtype, reductionType, backend) {
      const reductionStages = getReductionStages(x.shape);
      let result2 = x;
      for (let i = 0; i < reductionStages.length; i++) {
        const { inSize, windowSize, outSize } = reductionStages[i];
        let program;
        let previousResult;
        if (reductionType === "mean") {
          program = i === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });
        } else {
          program = new ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);
        }
        previousResult = result2;
        result2 = backend.runWebGLProgram(program, [result2], dtype);
        if (previousResult.dataId !== x.dataId) {
          backend.disposeIntermediateTensorInfo(previousResult);
        }
      }
      return result2;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/transpose_gpu.js
    var TransposeProgram = class {
      constructor(aShape, newDim) {
        this.variableNames = ["A"];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const switched = getSwitchedCoords(newDim);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${switched}));
      }
      `;
      }
    };
    function getSwitchedCoords(newDim) {
      const rank = newDim.length;
      if (rank > 6) {
        throw Error(`Transpose for rank ${rank} is not yet supported`);
      }
      const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
      const switchedCoords = new Array(rank);
      for (let i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
      }
      return switchedCoords.join();
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/transpose_packed_gpu.js
    var TransposePackedProgram = class {
      constructor(aShape, newDim) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        if (this.rank > 6) {
          throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
        }
        const dtype = getCoordsDataType(this.rank);
        const outputOrder = getVecChannels("rc", this.rank);
        const switchedOrder = new Array(this.rank);
        for (let i = 0; i < newDim.length; i++) {
          switchedOrder[newDim[i]] = outputOrder[i];
        }
        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
        this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 result = vec4(0.);
        result[0] = ${getc};
        if(${nextColumn}) {
          result[1] = ${getc};
        }
        --${outputOrder[this.rank - 1]};
        if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
          result[2] = ${getc};
          if(${nextColumn}) {
            result[3] = ${getc};
          }
        }
        setOutput(result);
      }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Transpose_impl.js
    function transposeImpl2(x, perm, backend) {
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x.shape, perm) : new TransposeProgram(x.shape, perm);
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sum_impl.js
    function sumImpl(x, axis, keepDims, backend) {
      const reductionIndices = axis;
      const xRank = x.shape.length;
      const origAxes = util_exports.parseAxisParam(reductionIndices, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      const sumInputIsTransposed = permutedAxes != null;
      let sumInput = x;
      if (sumInputIsTransposed) {
        sumInput = transposeImpl2(x, permutedAxes, backend);
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
      const [sumOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(sumInput.shape, axes);
      let outShape = sumOutShape;
      if (keepDims) {
        outShape = backend_util_exports.expandShapeToKeepDim(sumOutShape, origAxes);
      }
      const inSize = util_exports.sizeFromShape(reduceShape);
      const xSize = util_exports.sizeFromShape(x.shape);
      const batchSize = xSize / inSize;
      const reshapedInput = reshape2({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend });
      const outType = sumOutType(x.dtype);
      const reduced = reduce(reshapedInput, outType, "sum", backend);
      const out = reshape2({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
      backend.disposeIntermediateTensorInfo(reshapedInput);
      backend.disposeIntermediateTensorInfo(reduced);
      if (sumInputIsTransposed) {
        backend.disposeIntermediateTensorInfo(sumInput);
      }
      return out;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sum.js
    function sum3(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, keepDims } = attrs;
      return sumImpl(x, axis, keepDims, backend);
    }
    var sumConfig = {
      kernelName: Sum,
      backendName: "webgl",
      kernelFunc: sum3
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Transpose.js
    function transpose(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { perm } = attrs;
      const webglBackend = backend;
      const xRank = x.shape.length;
      const newShape = new Array(xRank);
      for (let i = 0; i < newShape.length; i++) {
        newShape[i] = x.shape[perm[i]];
      }
      let out;
      if (webglBackend.shouldExecuteOnCPU([x])) {
        const xTexData = webglBackend.texData.get(x.dataId);
        const values = xTexData.values;
        const outValues = transposeImplCPU(values, x.shape, x.dtype, perm, newShape);
        out = webglBackend.makeTensorInfo(newShape, x.dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
      } else {
        out = transposeImpl2(x, perm, webglBackend);
      }
      return out;
    }
    var transposeConfig = {
      kernelName: Transpose,
      backendName: "webgl",
      kernelFunc: transpose
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js
    var MATMUL_SHARED_DIM_THRESHOLD = 1e3;
    function batchMatMulImpl({ a, b, transposeA, transposeB, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
      const aRank = a.shape.length;
      const bRank = b.shape.length;
      const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
      const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
      const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
      const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
      const outerDimsA = a.shape.slice(0, -2);
      const outerDimsB = b.shape.slice(0, -2);
      const batchDimA = util_exports.sizeFromShape(outerDimsA);
      const batchDimB = util_exports.sizeFromShape(outerDimsB);
      const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
      util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
      const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
      const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
      util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
      const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
      const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
      const a3d = reshape2({ inputs: { x: a }, backend, attrs: { shape: a3dShape } });
      const b3d = reshape2({ inputs: { x: b }, backend, attrs: { shape: b3dShape } });
      const intermediates = [a3d, b3d];
      const batchDim = Math.max(batchDimA, batchDimB);
      const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
      const hasBias = bias != null;
      const hasPreluActivationWeights = preluActivationWeights != null;
      const hasLeakyreluAlpha = activation === "leakyrelu";
      const fusedActivation = activation != null ? mapActivationToShaderProgram(activation, true) : null;
      const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
      let out;
      if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
        let aVec = a3d;
        let bVec = b3d;
        if (transposeA) {
          aVec = transpose({ inputs: { x: a3d }, backend, attrs: { perm: [0, 2, 1] } });
          intermediates.push(aVec);
        }
        if (transposeB) {
          bVec = transpose({ inputs: { x: b3d }, backend, attrs: { perm: [0, 2, 1] } });
          intermediates.push(bVec);
        }
        const shouldReshapeA = outerShapeB !== 1;
        const shouldReshapeB = outerShapeB === 1;
        let aVec3d = aVec;
        if (shouldReshapeA) {
          aVec3d = reshape2({
            inputs: { x: aVec },
            backend,
            attrs: { shape: [batchDim, sharedDim, 1] }
          });
          intermediates.push(aVec3d);
        }
        const axis = outerShapeB === 1 ? 2 : 1;
        let bVec3d = bVec;
        if (shouldReshapeB) {
          bVec3d = reshape2({
            inputs: { x: bVec },
            backend,
            attrs: { shape: [batchDim, 1, sharedDim] }
          });
          intermediates.push(bVec3d);
        }
        const product = multiply2({ inputs: { a: aVec3d, b: bVec3d }, backend });
        out = sum3({ inputs: { x: product }, backend, attrs: { axis, keepDims: true } });
        intermediates.push(product);
      } else {
        const dtype = upcastType(a.dtype, b.dtype);
        const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [a3d, b3d];
        if (bias != null) {
          inputs.push(bias);
        }
        if (hasPreluActivationWeights) {
          inputs.push(preluActivationWeights);
        }
        if (hasLeakyreluAlpha) {
          const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
          inputs.push($leakyreluAlpha);
          intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, dtype);
      }
      const outReshaped = reshape2({ inputs: { x: out }, backend, attrs: { shape: outShape } });
      intermediates.push(out);
      for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
      }
      return outReshaped;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js
    function _fusedMatMul(args) {
      const { inputs, backend, attrs } = args;
      const { a, b, bias, preluActivationWeights } = inputs;
      const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;
      return batchMatMulImpl({
        a,
        b,
        transposeA,
        transposeB,
        backend,
        bias,
        preluActivationWeights,
        leakyreluAlpha,
        activation
      });
    }
    var _fusedMatMulConfig = {
      kernelName: _FusedMatMul,
      backendName: "webgl",
      kernelFunc: _fusedMatMul
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Abs.js
    var ABS2 = `return abs(x);`;
    function abs(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      if (backend.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
        const xData = backend.texData.get(x.dataId);
        const outValues = simpleAbsImplCPU(xData.values);
        return backend.makeTensorInfo(x.shape, x.dtype, outValues);
      }
      let program;
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        program = new UnaryOpPackedProgram(x.shape, ABS2);
      } else {
        program = new UnaryOpProgram(x.shape, ABS2);
      }
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
    var absConfig = {
      kernelName: Abs,
      backendName: "webgl",
      kernelFunc: abs
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Acos.js
    var ACOS = CHECK_NAN_SNIPPET + `
    if (abs(x) > 1.) {
      return NAN;
    }
    return acos(x);
  `;
    var acos = unaryKernelFunc({ opSnippet: ACOS });
    var acosConfig = {
      kernelName: Acos,
      backendName: "webgl",
      kernelFunc: acos
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Acosh.js
    var ACOSH = CHECK_NAN_SNIPPET + `
    if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`;
    var acosh = unaryKernelFunc({ opSnippet: ACOSH });
    var acoshConfig = {
      kernelName: Acosh,
      backendName: "webgl",
      kernelFunc: acosh
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Add.js
    var ADD = "return a + b;";
    var addKernelFunc = binaryKernelFunc2({
      opSnippet: ADD,
      packedOpSnippet: ADD,
      supportsComplex: true,
      cpuKernelImpl: addImplCPU
    });
    var addConfig = {
      kernelName: Add,
      backendName: "webgl",
      kernelFunc: addKernelFunc
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/addn_gpu.js
    var AddNProgram = class {
      constructor(outputShape, shapes) {
        this.outputShape = [];
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        this.variableNames.forEach((variable) => {
          snippets.push(`float v${variable} = get${variable}AtOutCoords();`);
        });
        const operation = this.variableNames.map((variable) => {
          return `v${variable}`;
        }).join(" + ");
        this.userCode = `
        void main() {
          ${snippets.join("\n        ")}
  
          float result = ${operation};
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/addn_packed_gpu.js
    var AddNPackedProgram = class {
      constructor(outputShape, shapes) {
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        this.variableNames.forEach((variable) => {
          snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);
        });
        const operation = this.variableNames.map((variable) => {
          return `v${variable}`;
        }).join(" + ");
        this.userCode = `
        void main() {
          ${snippets.join("\n        ")}
  
          vec4 result = ${operation};
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/AddN.js
    function addN(args) {
      const { inputs, backend } = args;
      const tensors = inputs;
      if (tensors.length === 1) {
        return identity2({ inputs: { x: tensors[0] }, backend });
      }
      if (tensors.length > env().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        const midIndex = Math.floor(tensors.length / 2);
        const leftSide = addN({ inputs: tensors.slice(0, midIndex), backend });
        const rightSide = addN({ inputs: tensors.slice(midIndex), backend });
        return addN({ inputs: [leftSide, rightSide], backend });
      }
      const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType(d1, d2));
      const shapes = tensors.map((t) => t.shape);
      const usePackedOp = env().getBool("WEBGL_PACK");
      const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
      return backend.runWebGLProgram(program, tensors, dtype);
    }
    var addNConfig = {
      kernelName: AddN,
      backendName: "webgl",
      kernelFunc: addN
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/All.js
    function all(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, keepDims } = attrs;
      const xRank = x.shape.length;
      const origAxes = util_exports.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      let permutedX = x;
      if (permutedAxes != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("all", axes, xRank);
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = util_exports.sizeFromShape(reduceShape);
      const a2D = reshape2({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
      const reduced = reduce(a2D, a2D.dtype, "all", backend);
      let res;
      if (keepDims) {
        const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
      } else {
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
      }
      backend.disposeIntermediateTensorInfo(a2D);
      backend.disposeIntermediateTensorInfo(reduced);
      if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
      }
      return res;
    }
    var allConfig = {
      kernelName: All,
      backendName: "webgl",
      kernelFunc: all
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Any.js
    function any(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, keepDims } = attrs;
      const xRank = x.shape.length;
      const origAxes = util_exports.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      let permutedX = x;
      if (permutedAxes != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("any", axes, xRank);
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = util_exports.sizeFromShape(reduceShape);
      const a2D = reshape2({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
      const reduced = reduce(a2D, a2D.dtype, "any", backend);
      let res;
      if (keepDims) {
        const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
      } else {
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
      }
      backend.disposeIntermediateTensorInfo(a2D);
      backend.disposeIntermediateTensorInfo(reduced);
      if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
      }
      return res;
    }
    var anyConfig = {
      kernelName: Any,
      backendName: "webgl",
      kernelFunc: any
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/argminmax_gpu.js
    var ArgMinMaxProgram = class {
      constructor(reduceInfo, op2, firstPass) {
        this.variableNames = ["A"];
        const { windowSize, batchSize, outSize } = reduceInfo;
        if (!firstPass) {
          this.variableNames.push("bestIndicesA");
        }
        this.outputShape = [batchSize, outSize];
        const compOp = op2 === "max" ? ">" : "<";
        const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
        this.userCode = `
        void main() {
          ivec2 coords = getOutputCoords();
          int batch = coords[0];
          int outIdx = coords[1];
          int inOffset = outIdx * ${windowSize};
  
          int bestIndex = inOffset;
          float bestValue = getA(batch, bestIndex);
  
          for (int i = 0; i < ${windowSize}; i++) {
            int inIdx = ${indexSnippet};
            float candidate = getA(batch, inIdx);
            if (candidate ${compOp} bestValue) {
              bestValue = candidate;
              bestIndex = inIdx;
            }
          }
          setOutput(float(bestIndex));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/argminmax_packed_gpu.js
    var ArgMinMaxPackedProgram = class {
      constructor(shape, windowSize, op2, firstPass) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        util_exports.assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
        const inSize = shape[shape.length - 1];
        const outSize = Math.ceil(inSize / windowSize);
        this.outputShape = shape.slice(0, -1);
        if (outSize > 1) {
          this.outputShape.push(outSize);
        }
        if (!firstPass) {
          this.variableNames.push("bestIndicesA");
        }
        const outShape = this.outputShape;
        const rank = outShape.length;
        const dtype = getCoordsDataType(rank);
        const coords2 = getChannels("coords", rank);
        let sourceLocSetup;
        let sourceRank;
        if (outSize === 1) {
          sourceRank = rank + 1;
          const sourceLocDType = getCoordsDataType(sourceRank);
          sourceLocSetup = `
          ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
          ++${coords2[rank - 1]};
          ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
          ++${coords2[rank - 2]};
          ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
          --${coords2[rank - 1]};
          ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
          --${coords2[rank - 2]};`;
        } else {
          sourceRank = rank;
          sourceLocSetup = `
          ${dtype} sourceLocR = coords;
          ++${coords2[rank - 1]};
          ${dtype} sourceLocG = coords;
          ++${coords2[rank - 2]};
          ${dtype} sourceLocA = coords;
          --${coords2[rank - 1]};
          ${dtype} sourceLocB = coords;
          --${coords2[rank - 2]};`;
        }
        const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
        const inChannel = "." + channels[sourceRank - 1];
        const intChannels = channels.map((x) => "int " + x);
        const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
        const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
        const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
        const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
        const compOp = op2 === "max" ? "greaterThan" : "lessThan";
        const fetchCandidateIdx = firstPass ? "" : `
            inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                               getBestIndicesAChannel(${srcGCoords.join()}),
                               getBestIndicesAChannel(${srcBCoords.join()}),
                               getBestIndicesAChannel(${srcACoords.join()})));`;
        const fetchValue = `vec4(
              getAChannel(${srcRCoords.join()}),
              hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
              hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
              hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
        const getBestIndicesAChannelSnippet = firstPass ? "" : `
        float getBestIndicesAChannel(${intChannels.join()}) {
          return getChannel(getBestIndicesA(${channels.join()}),
                                            vec2(${channels.slice(-2).join()}));
        }`;
        this.userCode = `
        float getAChannel(${intChannels.join()}) {
          return getChannel(getA(${channels.join()}),
                                 vec2(${channels.slice(-2).join()}));
        }
        ${getBestIndicesAChannelSnippet}
        void main() {
          ${dtype} coords = getOutputCoords();
          bool hasNextCol = ${coords2[rank - 1]} < ${outShape[rank - 1] - 1};
          bool hasNextRow = ${coords2[rank - 2]} < ${outShape[rank - 2] - 1};
          ${sourceLocSetup}
          ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
            sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
          ivec4 inIdx = srcIdx;
          vec4 bestIndex = vec4(inIdx);
          vec4 bestValue = ${fetchValue};
  
          for (int i = 0; i < ${windowSize}; i++) {
            inIdx = srcIdx;
            ${fetchCandidateIdx}
            vec4 candidate = ${fetchValue};
            bvec4 nan = isnan(candidate);
            bvec4 replace = bvec4(
              vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));
  
            bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                             replace.y  ? candidate.y : bestValue.y,
                             replace.z  ? candidate.z : bestValue.z,
                             replace.w  ? candidate.w : bestValue.w);
            bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
            srcIdx++;
          }
          setOutput(bestIndex);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js
    function argReduce(backend, x, reduceType, bestIndicesA = null) {
      let batchSize = x.shape[0];
      let inSize = x.shape[1];
      if (bestIndicesA != null) {
        batchSize = bestIndicesA.shape[0];
        inSize = bestIndicesA.shape[1];
      }
      const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
      const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
      const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
      const inputs = [x];
      if (bestIndicesA != null) {
        inputs.push(bestIndicesA);
      }
      const output = backend.runWebGLProgram(program, inputs, "int32");
      if (output.shape[1] === 1) {
        return output;
      }
      const result2 = argReduce(backend, x, reduceType, output);
      backend.disposeIntermediateTensorInfo(output);
      return result2;
    }
    function argReducePacked(backend, x, reduceType, bestIndicesA = null) {
      const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
      const inSize = inShape[inShape.length - 1];
      const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
      const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
      const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
      const output = backend.runWebGLProgram(program, inputs, "int32");
      if (output.shape.length === x.shape.length) {
        const result2 = argReducePacked(backend, x, reduceType, output);
        backend.disposeIntermediateTensorInfo(output);
        return result2;
      }
      return output;
    }
    function argMinMaxReduce(backend, x, axis, reduceType) {
      const axes = [axis];
      backend_util_exports.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
      if (!env().getBool("WEBGL_PACK_REDUCE") || x.shape.length <= 2) {
        const intermediateTensorInfos = [];
        const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(x.shape, axes);
        const inSize = util_exports.sizeFromShape(reduceShape);
        const a2D = reshape2({ inputs: { x }, backend, attrs: { shape: [-1, inSize] } });
        intermediateTensorInfos.push(a2D);
        const reduced = argReduce(backend, a2D, reduceType);
        intermediateTensorInfos.push(reduced);
        const reshaped = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
        intermediateTensorInfos.forEach((t) => backend.disposeIntermediateTensorInfo(t));
        return reshaped;
      }
      return argReducePacked(backend, x, reduceType);
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ArgMax.js
    function argMax(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis } = attrs;
      let axes = util_exports.parseAxisParam(axis, x.shape);
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
      let $x = x;
      const intermediateTensorInfos = [];
      if (permutedAxes != null) {
        $x = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        intermediateTensorInfos.push($x);
        axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
      }
      backend_util_exports.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
      const out = argMinMaxReduce(backend, $x, axes[0], "max");
      intermediateTensorInfos.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return out;
    }
    var argMaxConfig = {
      kernelName: ArgMax,
      backendName: "webgl",
      kernelFunc: argMax
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ArgMin.js
    function argMin(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis } = attrs;
      let axes = util_exports.parseAxisParam(axis, x.shape);
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
      let $x = x;
      const intermediateTensorInfos = [];
      if (permutedAxes != null) {
        $x = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        intermediateTensorInfos.push($x);
        axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
      }
      backend_util_exports.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
      const out = argMinMaxReduce(backend, $x, axes[0], "min");
      intermediateTensorInfos.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return out;
    }
    var argMinConfig = {
      kernelName: ArgMin,
      backendName: "webgl",
      kernelFunc: argMin
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Asin.js
    var ASIN = CHECK_NAN_SNIPPET + `
    if (abs(x) > 1.) {
      return NAN;
    }
    return asin(x);
  `;
    var asin = unaryKernelFunc({ opSnippet: ASIN });
    var asinConfig = {
      kernelName: Asin,
      backendName: "webgl",
      kernelFunc: asin
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Asinh.js
    var ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
    var asinh = unaryKernelFunc({ opSnippet: ASINH });
    var asinhConfig = {
      kernelName: Asinh,
      backendName: "webgl",
      kernelFunc: asinh
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Atan.js
    var ATAN = CHECK_NAN_SNIPPET + `
    return atan(x);
  `;
    var atan = unaryKernelFunc({ opSnippet: ATAN });
    var atanConfig = {
      kernelName: Atan,
      backendName: "webgl",
      kernelFunc: atan
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Atan2.js
    var ATAN2 = CHECK_NAN_SNIPPET_BINARY + `
    return atan(a, b);
  `;
    var ATAN2_PACKED = `
    vec4 result = atan(a, b);
    vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
    ` + CHECK_NAN_SNIPPET_BINARY_PACKED + `
    return result;
  `;
    var atan2 = binaryKernelFunc2({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
    var atan2Config = {
      kernelName: Atan2,
      backendName: "webgl",
      kernelFunc: atan2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Atanh.js
    var ATANH = CHECK_NAN_SNIPPET + `
    if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
    var atanh = unaryKernelFunc({ opSnippet: ATANH });
    var atanhConfig = {
      kernelName: Atanh,
      backendName: "webgl",
      kernelFunc: atanh
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/pool_gpu.js
    var Pool2DProgram = class {
      constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ["x"];
        if (poolType === "avg" && computePositions) {
          throw new Error("Cannot compute positions for average pool.");
        }
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === "avg";
        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        let initializationValue = "0.0";
        if (!isAvgPool) {
          initializationValue = "-1.0 / 1e-20";
        }
        if (computePositions) {
          const compareOp2 = ">=";
          this.userCode = `
          const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
          const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
          void main() {
            ivec4 coords = getOutputCoords();
            int batch = coords[0];
            int d = coords[3];
  
            ivec2 xRCCorner = coords.yz * strides - pads;
            int xRCorner = xRCCorner.x;
            int xCCorner = xRCCorner.y;
  
            // max/min x(?, ?, d) to get y(yR, yC, d).
            // ? = to be determined
            float minMaxValue = 0.0;
            float minMaxValueFound = 0.0;
            int minMaxPosition = 0;
            float avgValue = 0.0;
  
            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;
  
              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }
  
              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;
  
                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }
  
                float value = getX(batch, xR, xC, d);
  
                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
            setOutput(float(minMaxPosition));
          }
        `;
          return;
        }
        const compareOp = "max";
        let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (poolType === "avg") {
          returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
        if (${isAvgPool}) {
          avgValue += dot(values, ones);
        } else {
          minMaxValue = ${compareOp}(values, minMaxValue);
        }
      `;
        this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
        const float initializationValue = ${initializationValue};
        const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);
  
        float count = 0.0;
  
        float getValue(int batch, int xR, int xC, int d) {
          if (xC < 0 || xC >= ${convInfo.inWidth}) {
            return initializationValue;
          }
          count += 1.0;
          return getX(batch, xR, xC, d);
        }
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];
  
          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;
  
          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          vec4 minMaxValue = vec4(${initializationValue});
          float avgValue = 0.0;
          count = 0.0;
  
          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;
  
            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }
  
            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};
  
              vec4 values = vec4(
                getValue(batch, xR, xC, d),
                getValue(batch, xR, xC + ${dilationWidth}, d),
                getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
                getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
              );
  
              ${updateSnippet}
            }
  
            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xR, xC, d),
                initializationValue,
                initializationValue,
                initializationValue
              );
  
              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xR, xC, d),
                getValue(batch, xR, xC + ${dilationWidth}, d),
                initializationValue,
                initializationValue
              );
  
              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xR, xC, d),
                getValue(batch, xR, xC + ${dilationWidth}, d),
                getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
                initializationValue
              );
  
              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      `;
      }
    };
    var Pool3DProgram = class {
      constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ["x"];
        if (poolType === "avg" && computePositions) {
          throw new Error("Cannot compute positions for average pool.");
        }
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === "avg";
        let initializationValue = "0.0";
        if (!isAvgPool) {
          initializationValue = "-1.0 / 1e-20";
        }
        if (computePositions) {
          const compareOp2 = ">=";
          this.userCode = `
          const ivec3 strides =
              ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
          const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
  
          void main() {
            ivec5 coords = getOutputCoords();
            int batch = coords.x;
            int ch = coords.u;
  
            ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
            int xDCorner = xCorner.x;
            int xRCorner = xCorner.y;
            int xCCorner = xCorner.z;
  
            // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
            // ? = to be determined
            float minMaxValue = 0.0;
            float minMaxValueFound = 0.0;
            int minMaxPosition = 0;
  
            for (int wD = 0; wD < ${effectiveFilterDepth};
                wD += ${dilationDepth}) {
              int xD = xDCorner + wD;
  
              if (xD < 0 || xD >= ${convInfo.inDepth}) {
                continue;
              }
  
              for (int wR = 0; wR < ${effectiveFilterHeight};
                  wR += ${dilationHeight}) {
                int xR = xRCorner + wR;
  
                if (xR < 0 || xR >= ${convInfo.inHeight}) {
                  continue;
                }
  
                for (int wC = 0; wC < ${effectiveFilterWidth};
                    wC += ${dilationWidth}) {
                  int xC = xCCorner + wC;
  
                  if (xC < 0 || xC >= ${convInfo.inWidth}) {
                    continue;
                  }
  
                  float value = getX(batch, xD, xR, xC, ch);
  
                  // If a min / max value has already been found, use it. If not,
                  // use the current value.
                  float currMinMaxValue = mix(
                      value, minMaxValue, minMaxValueFound);
                  if (value ${compareOp2} currMinMaxValue) {
                    minMaxValue = value;
                    minMaxValueFound = 1.0;
                    minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                        wR * ${effectiveFilterWidth} + wC`};
                  }
                }
              }
            }
            setOutput(float(minMaxPosition));
          }
        `;
          return;
        }
        const compareOp = "max";
        let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (poolType === "avg") {
          returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
        if (${isAvgPool}) {
          avgValue += dot(values, ones);
        } else {
          minMaxValue = ${compareOp}(values, minMaxValue);
        }
      `;
        this.userCode = `
        const ivec3 strides =
          ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
        const float initializationValue = ${initializationValue};
        const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);
  
        float count = 0.0;
  
        float getValue(int batch, int xD, int xR, int xC, int ch) {
          if (xC < 0 || xC >= ${convInfo.inWidth}) {
            return initializationValue;
          }
          count += 1.0;
          return getX(batch, xD, xR, xC, ch);
        }
  
        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;
  
          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;
  
          // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
          // ? = to be determined
          vec4 minMaxValue = vec4(${initializationValue});
          float avgValue = 0.0;
          count = 0.0;
  
          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;
  
            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }
  
            for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
              int xR = xRCorner + wR;
  
              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }
  
              for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
                int xC = xCCorner + wC * ${dilationWidth};
  
                vec4 values = vec4(
                  getValue(batch, xD, xR, xC, ch),
                  getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                  getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                  getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
                );
  
                ${updateSnippet}
              }
  
              int xC = xCCorner + ${filterWidthNearestVec4};
              if (${filterWidthVec4Remainder === 1}) {
                vec4 values = vec4(
                  getValue(batch, xD, xR, xC, ch),
                  initializationValue,
                  initializationValue,
                  initializationValue
                );
  
                ${updateSnippet}
              } else if (${filterWidthVec4Remainder === 2}) {
                vec4 values = vec4(
                  getValue(batch, xD, xR, xC, ch),
                  getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                  initializationValue,
                  initializationValue
                );
  
                ${updateSnippet}
              } else if (${filterWidthVec4Remainder === 3}) {
                vec4 values = vec4(
                  getValue(batch, xD, xR, xC, ch),
                  getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                  getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                  initializationValue
                );
  
                ${updateSnippet}
              }
            }
            setOutput(${returnValue});
          }
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/AvgPool.js
    function avgPool(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      assertNotComplex(x, "avgPool");
      const { filterSize, strides, pad, dimRoundingMode } = attrs;
      const dilations = 1;
      util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
        return identity2({ inputs: { x }, backend });
      }
      const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
      return backend.runWebGLProgram(avgPoolProgram, [x], "float32");
    }
    var avgPoolConfig = {
      kernelName: AvgPool,
      backendName: "webgl",
      kernelFunc: avgPool
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/AvgPool3D.js
    function avgPool3D(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { filterSize, strides, pad, dimRoundingMode, dataFormat } = attrs;
      const dilations = [1, 1, 1];
      const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
      const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
      return backend.runWebGLProgram(avgPoolProgram, [x], "float32");
    }
    var avgPool3DConfig = {
      kernelName: AvgPool3D,
      backendName: "webgl",
      kernelFunc: avgPool3D
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js
    var AvgPool2DBackpropProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = `
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
        const float avgMultiplier = float(${avgMultiplier});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
  
          ivec2 dyRCCorner = coords.yz - pads;
          int dyRCorner = dyRCCorner.x;
          int dyCCorner = dyRCCorner.y;
  
          // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);
  
            for (int wC = 0; wC < ${effectiveFilterWidth};
              wC+= ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);
  
              float dyValue = getDy(b, idyR, idyC, d);
  
              dotProd += dyValue * avgMultiplier;
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var AvgPool3DBackpropProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy"];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
        this.userCode = `
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
        const float avgMultiplier = float(${avgMultiplier});
  
        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;
  
          ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
          int dyDCorner = dyCorner.x;
          int dyRCorner = dyCorner.y;
          int dyCCorner = dyCorner.z;
  
          // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
          // dx(xD, xR, xC, ch).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
  
          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            float dyD = float(dyDCorner + wD) / ${strideDepth}.0;
  
            if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
              continue;
            }
            int idyD = int(dyD);
  
            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
              if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                  fract(dyR) > 0.0) {
                continue;
              }
              int idyR = int(dyR);
  
              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
                if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                    fract(dyC) > 0.0) {
                  continue;
                }
                int idyC = int(dyC);
  
                float dyValue = getDy(batch, idyD, idyR, idyC, ch);
  
                dotProd += dyValue * avgMultiplier;
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js
    function avgPool3DGrad(args) {
      const { inputs, backend, attrs } = args;
      const { dy, input } = inputs;
      const x = input;
      const { filterSize, strides, pad, dimRoundingMode } = attrs;
      const dilations = [1, 1, 1];
      const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
      const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
      return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
    }
    var avgPoolGrad3DConfig = {
      kernelName: AvgPool3DGrad,
      backendName: "webgl",
      kernelFunc: avgPool3DGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js
    function avgPoolGrad(args) {
      const { inputs, backend, attrs } = args;
      const { dy, input } = inputs;
      const x = input;
      assertNotComplex([dy, input], "avgPoolGrad");
      const { filterSize, strides, pad } = attrs;
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad);
      const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
      return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
    }
    var avgPoolGradConfig = {
      kernelName: AvgPoolGrad,
      backendName: "webgl",
      kernelFunc: avgPoolGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/BatchMatMul.js
    function batchMatMul(args) {
      const { inputs, backend, attrs } = args;
      const { a, b } = inputs;
      const { transposeA, transposeB } = attrs;
      return batchMatMulImpl({ a, b, transposeA, transposeB, backend });
    }
    var batchMatMulConfig = {
      kernelName: BatchMatMul,
      backendName: "webgl",
      kernelFunc: batchMatMul
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/batchnorm_gpu.js
    var BatchNormProgram = class {
      constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.variableNames = ["x", "mean", "variance"];
        backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
        backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = "0.0";
        if (offsetShape != null) {
          backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
          this.variableNames.push("offset");
          offsetSnippet = "getOffsetAtOutCoords()";
        }
        let scaleSnippet = "1.0";
        if (scaleShape != null) {
          backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
          this.variableNames.push("scale");
          scaleSnippet = "getScaleAtOutCoords()";
        }
        this.outputShape = xShape;
        this.userCode = `
        void main() {
          float x = getXAtOutCoords();
          float mean = getMeanAtOutCoords();
          float variance = getVarianceAtOutCoords();
          float offset = ${offsetSnippet};
          float scale = ${scaleSnippet};
          float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
          setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js
    var BatchNormPackedProgram = class {
      constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.variableNames = ["x", "mean", "variance"];
        backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
        backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = "vec4(0.0)";
        if (offsetShape != null) {
          backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
          this.variableNames.push("offset");
          offsetSnippet = "getOffsetAtOutCoords()";
        }
        let scaleSnippet = "vec4(1.0)";
        if (scaleShape != null) {
          backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
          this.variableNames.push("scale");
          scaleSnippet = "getScaleAtOutCoords()";
        }
        this.outputShape = xShape;
        this.userCode = `
        void main() {
          vec4 offset = ${offsetSnippet};
          vec4 scale = ${scaleSnippet};
  
          vec4 x = getXAtOutCoords();
          vec4 mean = getMeanAtOutCoords();
          vec4 variance = getVarianceAtOutCoords();
  
          vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));
  
          setOutput((x - mean) * inv + offset);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/BatchNorm.js
    var batchNorm = ({ inputs, backend, attrs }) => {
      const { x, mean, variance, offset, scale } = inputs;
      util_exports.assert(mean.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
      util_exports.assert(offset == null || mean.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
      util_exports.assert(scale == null || mean.shape.length === scale.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
      let { varianceEpsilon } = attrs;
      if (varianceEpsilon == null) {
        varianceEpsilon = 1e-3;
      }
      const finalInputs = [x, mean, variance];
      let offsetShape = null;
      if (offset != null) {
        offsetShape = offset.shape;
        finalInputs.push(offset);
      }
      let scaleShape = null;
      if (scale != null) {
        scaleShape = scale.shape;
        finalInputs.push(scale);
      }
      const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
      const output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
      return output;
    };
    var batchNormConfig = {
      kernelName: FusedBatchNorm,
      backendName: "webgl",
      kernelFunc: batchNorm
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/slice_gpu.js
    var SliceProgram = class {
      constructor(destSize) {
        this.variableNames = ["source"];
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = getCoordsDataType(this.rank);
        const uniformPart = `uniform int start[${this.rank}];`;
        const sourceCoords = getCoords(this.rank);
        let body;
        const coordSum = destSize.map((_, i) => {
          return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
        });
        body = `
          ${dtype} sourceLoc;
          ${dtype} coords = getOutputCoords();
          ${coordSum.join("\n")}
        `;
        this.userCode = `
        ${uniformPart}
        void main() {
          ${body}
          setOutput(getSource(${sourceCoords}));
        }
      `;
      }
      getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
          throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
          if (this.startLoc == null) {
            this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "start");
            if (this.startLoc == null) {
              return;
            }
          }
          gpgpu.gl.uniform1iv(this.startLoc, start);
        };
      }
    };
    var coords = ["x", "y", "z", "w", "u", "v"];
    function getCoords(rank) {
      if (rank === 1) {
        return "sourceLoc";
      } else if (rank <= 6) {
        return coords.slice(0, rank).map((x) => "sourceLoc." + x).join(",");
      } else {
        throw Error(`Slicing for rank ${rank} is not yet supported`);
      }
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/slice_packed_gpu.js
    var SlicePackedProgram = class {
      constructor(destSize) {
        this.variableNames = ["source"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = getCoordsDataType(this.rank);
        const coords2 = getChannels("coords", this.rank);
        const sourceLoc = getChannels("sourceLoc", this.rank);
        const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
        const upperRow = `
        result.x = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.y = ${getChannel};
          --${sourceLoc[this.rank - 1]};
        }
      `;
        const lowerRow = this.rank === 1 ? "" : `
        --${coords2[this.rank - 1]};
        if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
          ++${sourceLoc[this.rank - 2]};
          result.z = ${getChannel};
          if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
            ++${sourceLoc[this.rank - 1]};
            result.w = ${getChannel};
          }
        }
      `;
        const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
              ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` : destSize.map((_, i) => `${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join("\n");
        this.userCode = `
        uniform int start[${this.rank}];
        void main() {
          ${dtype} coords = getOutputCoords();
          ${dtype} sourceLoc;
          ${sourceLocSetup}
          vec4 result = vec4(0.);
          ${upperRow}
          ${lowerRow}
          setOutput(result);
        }
      `;
      }
      getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
          throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
          if (this.startLoc == null) {
            this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "start");
            if (this.startLoc == null) {
              return;
            }
          }
          gpgpu.gl.uniform1iv(this.startLoc, start);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Slice.js
    function shallowSlice(x, begin, size, backend) {
      const xTexData = backend.texData.get(x.dataId);
      const t = backend.makeTensorInfo(size, x.dtype);
      const newTexData = backend.texData.get(t.dataId);
      Object.assign(newTexData, xTexData);
      newTexData.refCount = 1;
      newTexData.shape = size;
      newTexData.dtype = x.dtype;
      let flatOffset = slice_util_exports.computeFlatOffset(begin, util_exports.computeStrides(x.shape));
      if (xTexData.slice) {
        flatOffset += xTexData.slice.flatOffset;
      }
      newTexData.slice = {
        flatOffset,
        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
      };
      const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;
      backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
      return t;
    }
    function slice(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { begin, size } = attrs;
      const [$begin, $size] = slice_util_exports.parseSliceParams(x, begin, size);
      slice_util_exports.assertParamsValid(x, $begin, $size);
      if (util_exports.sizeFromShape($size) === 0) {
        return backend.makeTensorInfo($size, x.dtype, []);
      }
      if (backend.shouldExecuteOnCPU([x]) || x.dtype === "string") {
        const xTexData = backend.texData.get(x.dataId);
        const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);
        return backend.makeTensorInfo($size, x.dtype, outValues);
      }
      const { isPacked } = backend.texData.get(x.dataId);
      const isContinous = slice_util_exports.isSliceContinous(x.shape, $begin, $size);
      if (isPacked || !isContinous) {
        const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
        const customSetup = program.getCustomSetupFunc($begin);
        return backend.runWebGLProgram(program, [x], x.dtype, customSetup);
      }
      backend.uploadToGPU(x.dataId);
      return shallowSlice(x, $begin, $size, backend);
    }
    var sliceConfig = {
      kernelName: Slice,
      backendName: "webgl",
      kernelFunc: slice
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js
    var batchToSpaceND = (args) => {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { blockShape, crops } = attrs;
      util_exports.assert(x.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
      const prod2 = blockShape.reduce((a, b) => a * b);
      const reshaped = backend_util_exports.getReshaped(x.shape, blockShape, prod2);
      const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
      const reshapedPermuted = backend_util_exports.getReshapedPermuted(x.shape, blockShape, prod2);
      const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
      const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
      const toDispose = [];
      const reshapedIntermediate = reshape2({ inputs: { x }, backend, attrs: { shape: reshaped } });
      const transposedIntermediate = transpose({ inputs: { x: reshapedIntermediate }, backend, attrs: { perm: permuted } });
      const reshapedIntermediate2 = reshape2({
        inputs: { x: transposedIntermediate },
        backend,
        attrs: { shape: reshapedPermuted }
      });
      const sliced = slice({
        inputs: { x: reshapedIntermediate2 },
        backend,
        attrs: { begin: sliceBeginCoords, size: sliceSize }
      });
      toDispose.push(reshapedIntermediate);
      toDispose.push(transposedIntermediate);
      toDispose.push(reshapedIntermediate2);
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return sliced;
    };
    var batchToSpaceNDConfig = {
      kernelName: BatchToSpaceND,
      backendName: "webgl",
      kernelFunc: batchToSpaceND
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Bincount.js
    function bincount(args) {
      const { inputs, backend, attrs } = args;
      const { x, weights } = inputs;
      const { size } = attrs;
      const xVals = backend.readSync(x.dataId);
      const weightsVals = backend.readSync(weights.dataId);
      const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
      return backend.makeTensorInfo([size], weights.dtype, outVals);
    }
    var bincountConfig = {
      kernelName: Bincount,
      backendName: "webgl",
      kernelFunc: bincount
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/NotEqual.js
    var NOT_EQUAL = `return float(a != b);`;
    var notEqual2 = binaryKernelFunc2({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
    var notEqualConfig = {
      kernelName: NotEqual,
      backendName: "webgl",
      kernelFunc: notEqual2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Real.js
    function real2(args) {
      const { inputs, backend } = args;
      const { input } = inputs;
      const inputData = backend.texData.get(input.dataId);
      return identity2({ inputs: { x: inputData.complexTensorInfos.real }, backend });
    }
    var realConfig = {
      kernelName: Real,
      backendName: "webgl",
      kernelFunc: real2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernel_utils/int.js
    var TO_INT = `return float(int(x));`;
    function int(input, backend) {
      const program = new UnaryOpProgram(input.shape, TO_INT);
      const output = backend.runWebGLProgram(program, [input], "int32");
      console.log(input.dataId, output.dataId);
      return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Cast.js
    function cast3(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { dtype } = attrs;
      if (dtype === "complex64") {
        if (x.dtype === "complex64") {
          return identity2({ inputs: { x }, backend });
        }
        const zerosTensor = zeros(x.shape);
        const floatX = cast3({ inputs: { x }, backend, attrs: { dtype: "float32" } });
        const result2 = complex3({ inputs: { real: floatX, imag: zerosTensor }, backend });
        zerosTensor.dispose();
        backend.disposeIntermediateTensorInfo(floatX);
        return result2;
      }
      if (x.dtype === "complex64") {
        const realPart = real2({ inputs: { input: x }, backend });
        const result2 = cast3({ inputs: { x: realPart }, backend, attrs: { dtype } });
        backend.disposeIntermediateTensorInfo(realPart);
        return result2;
      }
      if (!util_exports.hasEncodingLoss(x.dtype, dtype)) {
        const result2 = identity2({ inputs: { x }, backend });
        return { dataId: result2.dataId, shape: result2.shape, dtype };
      }
      if (dtype === "int32") {
        return int(x, backend);
      }
      if (dtype === "bool") {
        const zerosTensorInfo = backend.makeTensorInfo([], "bool", util_exports.getTypedArrayFromDType("bool", 1));
        const binaryInputs = { a: x, b: zerosTensorInfo };
        const result2 = notEqual2({ inputs: binaryInputs, backend });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        return result2;
      }
      throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
    }
    var castConfig = {
      kernelName: Cast,
      backendName: "webgl",
      kernelFunc: cast3
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Ceil.js
    var CEIL = `return ceil(x);`;
    var ceil2 = unaryKernelFunc({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
    var ceilConfig = {
      kernelName: Ceil,
      backendName: "webgl",
      kernelFunc: ceil2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/clip_gpu.js
    var ClipProgram = class {
      constructor(aShape) {
        this.variableNames = ["A"];
        this.outputShape = aShape;
        this.userCode = `
        uniform float minVal;
        uniform float maxVal;
  
        void main() {
          float value = getAAtOutCoords();
          if (isnan(value)) {
            setOutput(value);
            return;
          }
  
          setOutput(clamp(value, minVal, maxVal));
        }
      `;
      }
      getCustomSetupFunc(min2, max2) {
        return (gpgpu, webGLProgram) => {
          if (this.minLoc == null) {
            this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "minVal");
            this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "maxVal");
          }
          gpgpu.gl.uniform1f(this.minLoc, min2);
          gpgpu.gl.uniform1f(this.maxLoc, max2);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/clip_packed_gpu.js
    var ClipPackedProgram = class {
      constructor(aShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
        uniform float minVal;
        uniform float maxVal;
  
        void main() {
          vec4 value = getAAtOutCoords();
  
          if (any(isnan(value))) {
            setOutput(value);
            return;
          }
  
          setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
        }
      `;
      }
      getCustomSetupFunc(min2, max2) {
        return (gpgpu, webGLProgram) => {
          if (this.minLoc == null) {
            this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "minVal");
            this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "maxVal");
          }
          gpgpu.gl.uniform1f(this.minLoc, min2);
          gpgpu.gl.uniform1f(this.maxLoc, max2);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ClipByValue.js
    function clipByValue(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { clipValueMin, clipValueMax } = attrs;
      let program;
      if (env().getBool("WEBGL_PACK_CLIP")) {
        program = new ClipPackedProgram(x.shape);
      } else {
        program = new ClipProgram(x.shape);
      }
      const customSetup = program.getCustomSetupFunc(clipValueMin, clipValueMax);
      return backend.runWebGLProgram(program, [x], x.dtype, customSetup);
    }
    var clipByValueConfig = {
      kernelName: ClipByValue,
      backendName: "webgl",
      kernelFunc: clipByValue
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/complex_abs_gpu.js
    var ComplexAbsProgram = class {
      constructor(shape) {
        this.variableNames = ["real", "imag"];
        this.outputShape = shape;
        this.userCode = `
        void main() {
          float re = abs(getRealAtOutCoords());
          float im = abs(getImagAtOutCoords());
          float mx = max(re, im);
  
          // sadly the length function in glsl is not underflow-safe
          // (at least not on Intel GPUs). So the safe solution is
          // to ensure underflow-safety in all cases.
          setOutput(
            mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
          );
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ComplexAbs.js
    function makeComplexComponentTensorInfo(complexTensor, complexPart) {
      return {
        dataId: complexPart.dataId,
        dtype: complexPart.dtype,
        shape: complexTensor.shape
      };
    }
    function complexAbs(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      const xData = backend.texData.get(x.dataId);
      const program = new ComplexAbsProgram(x.shape);
      const programInputs = [
        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag)
      ];
      return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);
    }
    var complexAbsConfig = {
      kernelName: ComplexAbs,
      backendName: "webgl",
      kernelFunc: complexAbs
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/concat_gpu.js
    var ConcatProgram = class {
      constructor(shapes) {
        this.outputShape = [];
        this.outputShape = backend_util_exports.computeOutShape(shapes, 1);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][1];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][1];
        }
        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
        for (let i = 1; i < offsets.length; i++) {
          const shift = offsets[i - 1];
          snippets.push(`else if (yC < ${offsets[i]}) setOutput(getT${i}(yR, yC-${shift}));`);
        }
        const lastIndex = offsets.length;
        const lastShift = offsets[offsets.length - 1];
        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
        this.userCode = `
        void main() {
          ivec2 coords = getOutputCoords();
          int yR = coords.x;
          int yC = coords.y;
  
          ${snippets.join("\n        ")}
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/concat_packed_gpu.js
    var ConcatPackedProgram = class {
      constructor(shapes, axis) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        this.outputShape = backend_util_exports.computeOutShape(shapes, axis);
        const shape = this.outputShape;
        const rank = shape.length;
        const dtype = getCoordsDataType(rank);
        const coords2 = getChannels("coords", rank);
        const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][axis];
        }
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
          return getChannel(
              getT0(${allChannels}), vec2(${lastChannels.join()}));
          }`;
        for (let i = 1; i < offsets.length; i++) {
          const shift2 = offsets[i - 1];
          getValueSnippet += `
          if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
            return getChannel(
              getT${i}(${shiftedChannels(channels, channel, shift2)}),
              vec2(${shiftedChannels(lastChannels, channel, shift2)}));
          }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
          return getChannel(
            getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
            vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
        this.userCode = `
        float getValue(${channels.map((x) => "int " + x)}) {
          ${getValueSnippet}
        }
  
        void main() {
          ${dtype} coords = getOutputCoords();
          vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);
  
          ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
          if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
            result.g = getValue(${coords2});
          }
  
          ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
          if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
            result.a = getValue(${coords2});
          }
  
          ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
          if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
              ${coords2[rank - 1]} < ${shape[rank - 1]}) {
            result.b = getValue(${coords2});
          }
          setOutput(result);
        }
      `;
      }
    };
    function shiftedChannels(channels, channel, shift) {
      const channelIdx = channels.indexOf(channel);
      const res = channels.map((c, idx) => {
        if (idx === channelIdx) {
          return `${c} - ${shift}`;
        } else {
          return c;
        }
      });
      return res.join();
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Imag.js
    function imag(args) {
      const { inputs, backend } = args;
      const { input } = inputs;
      const inputData = backend.texData.get(input.dataId);
      return identity2({ inputs: { x: inputData.complexTensorInfos.imag }, backend });
    }
    var imagConfig = {
      kernelName: Imag,
      backendName: "webgl",
      kernelFunc: imag
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Concat_impl.js
    function concatImpl2(inputs, axis, backend) {
      const dtype = inputs[0].dtype;
      if (dtype === "complex64") {
        const reals = inputs.map((t) => real2({ inputs: { input: t }, backend }));
        const imags = inputs.map((t) => imag({ inputs: { input: t }, backend }));
        const realConcated = concatImpl2(reals, axis, backend);
        const imagConcated = concatImpl2(imags, axis, backend);
        const result3 = complex3({ inputs: { real: realConcated, imag: imagConcated }, backend });
        reals.forEach((r) => backend.disposeIntermediateTensorInfo(r));
        imags.forEach((i) => backend.disposeIntermediateTensorInfo(i));
        backend.disposeIntermediateTensorInfo(realConcated);
        backend.disposeIntermediateTensorInfo(imagConcated);
        return result3;
      }
      let runOnCpu = backend.shouldExecuteOnCPU(inputs);
      if (dtype === "string") {
        runOnCpu = true;
      }
      if (runOnCpu) {
        const tensors2D2 = inputs.map((t) => {
          const innerSize = util_exports.sizeFromShape(t.shape.slice(axis));
          const shape = [-1, innerSize];
          return reshape2({ inputs: { x: t }, backend, attrs: { shape } });
        });
        const inputsValShapes = tensors2D2.map((t) => {
          return { vals: backend.readSync(t.dataId), shape: t.shape };
        });
        const outShape2 = backend_util_exports.computeOutShape(tensors2D2.map((t) => t.shape), 1);
        const simplyConcat = tensors2D2[0].shape[0] === 1;
        const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
        const finalOutShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), axis);
        const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);
        tensors2D2.forEach((t) => backend.disposeIntermediateTensorInfo(t));
        return outInfo;
      }
      if (inputs.length > env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        const midIndex = Math.floor(inputs.length / 2);
        const leftSide = concatImpl2(inputs.slice(0, midIndex), axis, backend);
        const rightSide = concatImpl2(inputs.slice(midIndex), axis, backend);
        const result3 = concatImpl2([leftSide, rightSide], axis, backend);
        backend.disposeIntermediateTensorInfo(leftSide);
        backend.disposeIntermediateTensorInfo(rightSide);
        return result3;
      }
      if (env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && inputs[0].shape.length > 1) {
        const program2 = new ConcatPackedProgram(inputs.map((t) => t.shape), axis);
        return backend.runWebGLProgram(program2, inputs, dtype);
      }
      const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);
      const program = new ConcatProgram(tensors2D.map((t) => t.shape));
      const result2 = backend.runWebGLProgram(program, tensors2D, dtype);
      tensors2D.forEach((r) => backend.disposeIntermediateTensorInfo(r));
      const reshapedResult = reshape2({ inputs: { x: result2 }, attrs: { shape: outShape }, backend });
      backend.disposeIntermediateTensorInfo(result2);
      return reshapedResult;
    }
    function computeTensors2D(inputs, axis, backend) {
      const outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), axis);
      const tensors2D = inputs.map((x) => reshape2({
        inputs: { x },
        attrs: { shape: [-1, util_exports.sizeFromShape(x.shape.slice(axis))] },
        backend
      }));
      return { tensors2D, outShape };
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Concat.js
    function concat(args) {
      const { inputs, backend, attrs } = args;
      const { axis } = attrs;
      const $axis = util_exports.parseAxisParam(axis, inputs[0].shape)[0];
      const outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), $axis);
      if (util_exports.sizeFromShape(outShape) === 0) {
        return backend.makeTensorInfo(outShape, inputs[0].dtype, []);
      }
      const $inputs = inputs.filter((t) => util_exports.sizeFromShape(t.shape) > 0);
      if ($inputs.length === 1) {
        return identity2({ inputs: { x: $inputs[0] }, backend });
      }
      const shapes = $inputs.map((t) => t.shape);
      backend_util_exports.assertParamsConsistent(shapes, $axis);
      return concatImpl2($inputs, $axis, backend);
    }
    var concatConfig = {
      kernelName: Concat,
      backendName: "webgl",
      kernelFunc: concat
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/conv_gpu.js
    var Conv2DProgram = class {
      constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation) {
          if (hasPreluActivationWeights) {
            activationSnippet = `float activation(float a) {
            float b = getPreluActivationWeightsAtOutCoords();
            ${activation}
          }`;
          } else if (hasLeakyreluAlpha) {
            activationSnippet = `float activation(float a) {
            float b = getLeakyreluAlphaAtOutCoords();
            ${activation}
          }`;
          } else {
            activationSnippet = `
            float activation(float x) {
              ${activation}
            }
          `;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivationWeights) {
          this.variableNames.push("preluActivationWeights");
        }
        if (hasLeakyreluAlpha) {
          this.variableNames.push("leakyreluAlpha");
        }
        this.userCode = `
        ${activationSnippet}
  
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d2 = coords[${channelDim}];
  
          ivec2 xRCCorner =
              ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;
  
          // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};
  
            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }
  
            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};
  
              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }
  
              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 wValues = vec4(
                  getW(wR, wC, d1, d2),
                  getW(wR, wC, d1 + 1, d2),
                  getW(wR, wC, d1 + 2, d2),
                  getW(wR, wC, d1 + 3, d2)
                );
  
                if (${isChannelsLast}) {
                  vec4 xValues = vec4(
                    getX(batch, xR, xC, d1),
                    getX(batch, xR, xC, d1 + 1),
                    getX(batch, xR, xC, d1 + 2),
                    getX(batch, xR, xC, d1 + 3)
                  );
                  dotProd += dot(xValues, wValues);
                } else {
                  vec4 xValues = vec4(
                    getX(batch, d1, xR, xC),
                    getX(batch, d1 + 1, xR, xC),
                    getX(batch, d1 + 2, xR, xC),
                    getX(batch, d1 + 3, xR, xC)
                  );
                  dotProd += dot(xValues, wValues);
                }
              }
  
              if (${inputDepthVec4Remainder === 1}) {
  
                if (${isChannelsLast}) {
                  dotProd +=
                      getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                      getW(wR, wC, ${inputDepthNearestVec4}, d2);
                } else {
                  dotProd +=
                      getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                      getW(wR, wC, ${inputDepthNearestVec4}, d2);
                }
  
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 wValues = vec2(
                  getW(wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
  
                if (${isChannelsLast}) {
                  vec2 xValues = vec2(
                    getX(batch, xR, xC, ${inputDepthNearestVec4}),
                    getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                  );
                  dotProd += dot(xValues, wValues);
                } else {
                  vec2 xValues = vec2(
                    getX(batch, ${inputDepthNearestVec4}, xR, xC),
                    getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                  );
                  dotProd += dot(xValues, wValues);
                }
  
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 wValues = vec3(
                  getW(wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
  
                if (${isChannelsLast}) {
                  vec3 xValues = vec3(
                    getX(batch, xR, xC, ${inputDepthNearestVec4}),
                    getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                    getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                  );
                  dotProd += dot(xValues, wValues);
                } else {
                  vec3 xValues = vec3(
                    getX(batch, ${inputDepthNearestVec4}, xR, xC),
                    getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                    getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                  );
                  dotProd += dot(xValues, wValues);
                }
  
              }
            }
          }
  
          float result = dotProd;
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(result);
        }
      `;
      }
    };
    var Conv3DProgram = class {
      constructor(convInfo) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = `
        const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
  
        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int d2 = coords.u;
  
          ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xFCorner = xFRCCorner.x;
          int xRCorner = xFRCCorner.y;
          int xCCorner = xFRCCorner.z;
  
          // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
          // y(yF, yR, yC, d2). ? = to be determined. : = across all
          // values in that axis.
          float dotProd = 0.0;
          for (int wF = 0; wF < ${filterDepth}; wF++) {
            int xF = xFCorner + wF * ${dilationDepth};
  
            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }
  
            for (int wR = 0; wR < ${filterHeight}; wR++) {
              int xR = xRCorner + wR * ${dilationHeight};
  
              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }
  
              for (int wC = 0; wC < ${filterWidth}; wC++) {
                int xC = xCCorner + wC * ${dilationWidth};
  
                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }
  
                for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                  vec4 xValues = vec4(
                    getX(batch, xF, xR, xC, d1),
                    getX(batch, xF, xR, xC, d1 + 1),
                    getX(batch, xF, xR, xC, d1 + 2),
                    getX(batch, xF, xR, xC, d1 + 3)
                  );
                  vec4 wValues = vec4(
                    getW(wF, wR, wC, d1, d2),
                    getW(wF, wR, wC, d1 + 1, d2),
                    getW(wF, wR, wC, d1 + 2, d2),
                    getW(wF, wR, wC, d1 + 3, d2)
                  );
  
                  dotProd += dot(xValues, wValues);
                }
  
                if (${inputDepthVec4Remainder === 1}) {
                  dotProd +=
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
                } else if (${inputDepthVec4Remainder === 2}) {
                  vec2 xValues = vec2(
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                  );
                  vec2 wValues = vec2(
                    getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                    getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                  );
                  dotProd += dot(xValues, wValues);
                } else if (${inputDepthVec4Remainder === 3}) {
                  vec3 xValues = vec3(
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                    getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                  );
                  vec3 wValues = vec3(
                    getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                    getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                    getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                  );
                  dotProd += dot(xValues, wValues);
                }
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/im2col_packed_gpu.js
    var Im2ColPackedProgram = class {
      constructor(outputShape, inputShape, convInfo) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const { filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat } = convInfo;
        const { left, top } = padInfo;
        const itemsPerBlockRow = inChannels * filterWidth;
        const glsl = getGlslDifferences();
        const isChannelsLast = dataFormat === "channelsLast";
        const rowDim = isChannelsLast ? 0 : 1;
        const colDim = isChannelsLast ? 1 : 2;
        let unrolled = ``;
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            unrolled += `
            blockIndex = rc.y + ${col};
            pos = rc.x + ${row};
  
            if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {
              offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};
              d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});
  
              if(d0 < ${inputShape[rowDim]} && d0 >= 0) {
  
                offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);
                d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));
  
                if(d1 < ${inputShape[colDim]} && d1 >= 0) {
  
                  ch = int(mod(float(pos), ${inChannels}.));
  
                  if (${isChannelsLast}) {
                    innerDims = vec2(d1, ch);
                    result[${row * 2 + col}] = getChannel(
                      getA(d0, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                  } else {
                    innerDims = vec2(d0, d1);
                    result[${row * 2 + col}] = getChannel(
                      getA(ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                  }
                }
              }
            }
          `;
          }
        }
        this.userCode = `
        void main() {
          ivec2 rc = getOutputCoords();
  
          vec4 result = vec4(0);
  
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
  
          ${unrolled}
  
          ${glsl.output} = result;
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js
    function conv2dByMatMul({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
      const xShape = x.shape;
      const xTexData = backend.texData.get(x.dataId);
      const sharedMatMulDim = convInfo.inChannels;
      const outerShapeX = xShape[0] * xShape[1] * xShape[2];
      const outerShapeFilter = convInfo.outChannels;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const transposeA = false;
      const transposeB = false;
      let out;
      const intermediates = [];
      const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
      const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;
      if (batchMatMulWillBeUnpacked || !env().getBool("WEBGL_LAZILY_UNPACK") || !env().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !reshapeWillBeExpensive) {
        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
        const xReshaped = reshape2({
          inputs: { x },
          backend,
          attrs: { shape: [1, targetShape, convInfo.inChannels] }
        });
        const filterReshaped = reshape2({
          inputs: { x: filter },
          backend,
          attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        const result2 = batchMatMulImpl({
          a: xReshaped,
          b: filterReshaped,
          transposeA,
          transposeB,
          backend,
          bias,
          activation,
          preluActivationWeights,
          leakyreluAlpha
        });
        out = reshape2({ inputs: { x: result2 }, backend, attrs: { shape: convInfo.outShape } });
        intermediates.push(xReshaped);
        intermediates.push(filterReshaped);
        intermediates.push(result2);
      } else {
        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * (xShape[2] + 1) : xShape[0] * xShape[2] * (xShape[3] + 1);
        const xReshaped = {
          dataId: x.dataId,
          shape: [1, targetShape, convInfo.inChannels],
          dtype: x.dtype
        };
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        util_exports.assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
        const filterReshaped = reshape2({
          inputs: { x: filter },
          backend,
          attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        intermediates.push(filterReshaped);
        const pointwiseConv = batchMatMulImpl({
          a: xReshaped,
          b: filterReshaped,
          backend,
          transposeA,
          transposeB,
          bias,
          activation,
          preluActivationWeights,
          leakyreluAlpha
        });
        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
        util_exports.assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
        xTexData.shape = originalXTexDataShape;
        pointwiseConvTexData.shape = convInfo.outShape;
        out = identity2({ inputs: { x: pointwiseConv }, backend });
        out.shape = convInfo.outShape;
        intermediates.push(pointwiseConv);
      }
      for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
      }
      return out;
    }
    function conv2dWithIm2Row({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
      const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
      const isChannelsLast = dataFormat === "channelsLast";
      const sharedDim = filterWidth * filterHeight * inChannels;
      const numCols = outHeight * outWidth;
      const x2ColShape = [sharedDim, numCols];
      const transposeA = true;
      const transposeB = false;
      const intermediates = [];
      const xSqueezed = reshape2({ inputs: { x }, backend, attrs: { shape: x.shape.slice(1) } });
      const w2Row = reshape2({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, sharedDim, util_exports.sizeFromShape(filter.shape) / sharedDim] }
      });
      intermediates.push(xSqueezed);
      intermediates.push(w2Row);
      const im2ColProgram = new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);
      const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], "float32");
      const im2ColReshaped = reshape2({
        inputs: { x: im2Col },
        backend,
        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
      });
      intermediates.push(im2Col);
      intermediates.push(im2ColReshaped);
      const hasBias = bias != null;
      const hasPreluActivationWeights = preluActivationWeights != null;
      const hasLeakyreluAlpha = activation === "leakyrelu";
      const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
      const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs = [im2ColReshaped, w2Row];
      if (bias) {
        inputs.push(bias);
      }
      if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      const product = backend.runWebGLProgram(matmulProgram, inputs, "float32");
      const outShape = isChannelsLast ? [1, outHeight, outWidth, convInfo.outChannels] : [1, convInfo.outChannels, outHeight, outWidth];
      const out = reshape2({ inputs: { x: product }, backend, attrs: { shape: outShape } });
      intermediates.push(product);
      for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
      }
      return out;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv2D.js
    function conv2d(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter } = inputs;
      const { strides, pad, dataFormat, dilations, dimRoundingMode } = attrs;
      const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
      let out;
      if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
        out = conv2dByMatMul({ x, filter, convInfo, backend });
      } else if (env().getBool("WEBGL_CONV_IM2COL") && x.shape[0] === 1) {
        out = conv2dWithIm2Row({ x, filter, convInfo, backend });
      } else {
        const program = new Conv2DProgram(convInfo);
        out = backend.runWebGLProgram(program, [x, filter], "float32");
      }
      const outReshaped = reshape2({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
      backend.disposeIntermediateTensorInfo(out);
      return outReshaped;
    }
    var conv2DConfig = {
      kernelName: Conv2D,
      backendName: "webgl",
      kernelFunc: conv2d
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/conv_backprop_gpu.js
    var Conv2DDerFilterProgram = class {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int wR = coords.x;
          int wC = coords.y;
          int d1 = coords.z;
          int d2 = coords.w;
  
          // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
  
          for (int b = 0; b < ${convInfo.batchSize}; b++) {
            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};
  
              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }
  
              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};
  
                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }
  
                if (${isChannelsLast}) {
                  float dyValue = getDy(b, yR, yC, d2);
                  float xValue = getX(b, xR, xC, d1);
                  dotProd += (xValue * dyValue);
                } else {
                  float dyValue = getDy(b, d2, yR, yC);
                  float xValue = getX(b, d1, xR, xC);
                  dotProd += (xValue * dyValue);
                }
  
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var Conv2DDerInputProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        this.userCode = `
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d1 = coords[${channelDim}];
  
          ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
          int dyRCorner = dyCorner.x;
          int dyCCorner = dyCorner.y;
  
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);
  
            int wRPerm = ${filterHeight} - 1 - wR;
  
            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);
  
              int wCPerm = ${filterWidth} - 1 - wC;
  
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
  
                if (${isChannelsLast}) {
                  float xValue = getDy(batch, idyR, idyC, d2);
                  float wValue = getW(wRPerm, wCPerm, d1, d2);
                  dotProd += xValue * wValue;
                } else {
                  float xValue = getDy(batch, d2, idyR, idyC);
                  float wValue = getW(wRPerm, wCPerm, d1, d2);
                  dotProd += xValue * wValue;
                }
  
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var Conv3DDerFilterProgram = class {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.userCode = `
        void main() {
          ivec5 coords = getOutputCoords();
          int wF = coords.x;
          int wR = coords.y;
          int wC = coords.z;
          int d1 = coords.w;
          int d2 = coords.u;
  
          float dotProd = 0.0;
  
          for (int b = 0; b < ${convInfo.batchSize}; b++) {
            for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
              int xF = wF + yF * ${strideDepth} - ${padFront};
  
              if (xF < 0 || xF >= ${convInfo.inDepth}) {
                continue;
              }
  
              for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
                int xR = wR + yR * ${strideHeight} - ${padTop};
  
                if (xR < 0 || xR >= ${convInfo.inHeight}) {
                  continue;
                }
  
                for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                  int xC = wC + yC * ${strideWidth} - ${padLeft};
  
                  if (xC < 0 || xC >= ${convInfo.inWidth}) {
                    continue;
                  }
  
                  float dyValue = getDy(b, yF, yR, yC, d2);
                  float xValue = getX(b, xF, xR, xC, d1);
                  dotProd += (xValue * dyValue);
                }
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var Conv3DDerInputProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = filterDepth - 1 - convInfo.padInfo.front;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = `
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
  
        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int d1 = coords.u;
  
  
          ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
          int dyFCorner = dyCorner.x;
          int dyRCorner = dyCorner.y;
          int dyCCorner = dyCorner.z;
  
          float dotProd = 0.0;
          for (int wF = 0; wF < ${filterDepth}; wF++) {
            float dyF = float(dyFCorner + wF) / ${strideDepth}.0;
  
            if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
              continue;
            }
            int idyF = int(dyF);
  
            int wFPerm = ${filterDepth} - 1 - wF;
  
            for (int wR = 0; wR < ${filterHeight}; wR++) {
              float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
              if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
                continue;
              }
              int idyR = int(dyR);
  
              int wRPerm = ${filterHeight} - 1 - wR;
  
              for (int wC = 0; wC < ${filterWidth}; wC++) {
                float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
                if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                    fract(dyC) > 0.0) {
                  continue;
                }
                int idyC = int(dyC);
  
                int wCPerm = ${filterWidth} - 1 - wC;
  
                for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                  float xValue = getDy(batch, idyF, idyR, idyC, d2);
                  float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                  dotProd += xValue * wValue;
                }
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js
    function conv2DBackpropFilter(args) {
      const { inputs, backend, attrs } = args;
      const { x, dy } = inputs;
      const { strides, pad, dataFormat, dimRoundingMode, filterShape } = attrs;
      const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, 1, pad, dimRoundingMode, false, $dataFormat);
      const program = new Conv2DDerFilterProgram(convInfo);
      return backend.runWebGLProgram(program, [x, dy], "float32");
    }
    var conv2DBackpropFilterConfig = {
      kernelName: Conv2DBackpropFilter,
      backendName: "webgl",
      kernelFunc: conv2DBackpropFilter
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js
    function conv2DBackpropInput(args) {
      const { inputs, backend, attrs } = args;
      const { dy, filter } = inputs;
      const { inputShape, strides, pad, dataFormat, dimRoundingMode } = attrs;
      const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
      const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad, dimRoundingMode, false, $dataFormat);
      const program = new Conv2DDerInputProgram(convInfo);
      return backend.runWebGLProgram(program, [dy, filter], "float32");
    }
    var conv2DBackpropInputConfig = {
      kernelName: Conv2DBackpropInput,
      backendName: "webgl",
      kernelFunc: conv2DBackpropInput
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv3D.js
    function conv3D(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter } = inputs;
      const { strides, pad, dilations } = attrs;
      const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);
      const program = new Conv3DProgram(convInfo);
      return backend.runWebGLProgram(program, [x, filter], "float32");
    }
    var conv3DConfig = {
      kernelName: Conv3D,
      backendName: "webgl",
      kernelFunc: conv3D
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js
    function conv3DBackpropFilterV2(args) {
      const { inputs, backend, attrs } = args;
      const { x, dy } = inputs;
      const { strides, pad, filterShape } = attrs;
      const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filterShape, strides, 1, pad);
      const program = new Conv3DDerFilterProgram(convInfo);
      return backend.runWebGLProgram(program, [x, dy], "float32");
    }
    var conv3DBackpropFilterV2Config = {
      kernelName: Conv3DBackpropFilterV2,
      backendName: "webgl",
      kernelFunc: conv3DBackpropFilterV2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js
    function conv3DBackpropInput(args) {
      const { inputs, backend, attrs } = args;
      const { dy, filter } = inputs;
      const { pad, strides, inputShape } = attrs;
      const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad);
      const program = new Conv3DDerInputProgram(convInfo);
      return backend.runWebGLProgram(program, [dy, filter], "float32");
    }
    var conv3DBackpropInputConfig = {
      kernelName: Conv3DBackpropInputV2,
      backendName: "webgl",
      kernelFunc: conv3DBackpropInput
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Cos.js
    var COS = CHECK_NAN_SNIPPET_UNARY + `
    return cos(x);
  `;
    var cos = unaryKernelFunc({ opSnippet: COS });
    var cosConfig = {
      kernelName: Cos,
      backendName: "webgl",
      kernelFunc: cos
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Cosh.js
    var COSH = `
    float e2x = exp(-x);
    return (e2x + 1.0 / e2x) / 2.0;
  `;
    var cosh = unaryKernelFunc({ opSnippet: COSH });
    var coshConfig = {
      kernelName: Cosh,
      backendName: "webgl",
      kernelFunc: cosh
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/crop_and_resize_gpu.js
    var CropAndResizeProgram = class {
      constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
        this.variableNames = ["Image", "Boxes", "BoxInd"];
        this.outputShape = [];
        const [batch, imageHeight, imageWidth, depth] = imageShape;
        const [numBoxes] = boxShape;
        const [cropHeight, cropWidth] = cropSize;
        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
        const methodId = method === "bilinear" ? 1 : 0;
        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
        const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
          `${(imageHeight - 1) / (cropHeight - 1)}`,
          "(y2-y1) * height_ratio",
          `y1*${inputHeightFloat} + float(y)*(height_scale)`
        ] : [
          "0.0",
          "0.0",
          `0.5 * (y1+y2) * ${inputHeightFloat}`
        ];
        const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
          `${(imageWidth - 1) / (cropWidth - 1)}`,
          "(x2-x1) * width_ratio",
          `x1*${inputWidthFloat} + float(x)*(width_scale)`
        ] : [
          "0.0",
          "0.0",
          `0.5 * (x1+x2) * ${inputWidthFloat}`
        ];
        this.userCode = `
        const float height_ratio = float(${heightRatio});
        const float width_ratio = float(${widthRatio});
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int y = coords[1];
          int x = coords[2];
          int d = coords[3];
  
          // get box vals
          float y1 = getBoxes(b,0);
          float x1 = getBoxes(b,1);
          float y2 = getBoxes(b,2);
          float x2 = getBoxes(b,3);
  
          // get image in batch index
          int bInd = round(getBoxInd(b));
          if(bInd < 0 || bInd >= ${batch}) {
            return;
          }
  
          float height_scale = ${heightScale};
          float width_scale = ${widthScale};
  
          float in_y = ${inY};
          if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
            setOutput(float(${extrapolationValue}));
            return;
          }
          float in_x = ${inX};
          if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
            setOutput(float(${extrapolationValue}));
            return;
          }
  
          vec2 sourceFracIndexCR = vec2(in_x,in_y);
          if(${methodId} == 1) {
            // Compute the four integer indices.
            ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
            ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));
  
            float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
            float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
            float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
            float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);
  
            vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);
  
            float top = topLeft + (topRight - topLeft) * fracCR.x;
            float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
            float newValue = top + (bottom - top) * fracCR.y;
            setOutput(newValue);
          } else {
            // Compute the coordinators of nearest neighbor point.
            ivec2 sourceNearestCR = ivec2(floor(
              sourceFracIndexCR + vec2(0.5,0.5)));
            float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
            setOutput(newValue);
          }
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/CropAndResize.js
    var cropAndResize = (args) => {
      const { inputs, backend, attrs } = args;
      const { image: image2, boxes, boxInd } = inputs;
      const { cropSize, method, extrapolationValue } = attrs;
      const program = new CropAndResizeProgram(image2.shape, boxes.shape, cropSize, method, extrapolationValue);
      return backend.runWebGLProgram(program, [image2, boxes, boxInd], "float32");
    };
    var cropAndResizeConfig = {
      kernelName: CropAndResize,
      backendName: "webgl",
      kernelFunc: cropAndResize
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/cumsum_gpu.js
    var CumSumProgram = class {
      constructor(shape, exclusive, reverse2) {
        this.variableNames = ["x"];
        this.outputShape = shape;
        const rank = shape.length;
        const val = exclusive ? "0.0" : `getX(${getCoords2(rank, "coords")})`;
        const length = shape[shape.length - 1];
        let condition = "";
        let idxString = "";
        if (exclusive) {
          condition = reverse2 ? `end != ${length - 1}` : "end != 0";
          idxString = reverse2 ? "end + 1" : "end - 1";
        } else {
          condition = reverse2 ? `end + pow2 < ${length}` : "end >= pow2";
          idxString = reverse2 ? "end + pow2" : "end - pow2";
        }
        this.userCode = `
        uniform float index;
        void main() {
          ${getCoordsDataType(rank)} coords = getOutputCoords();
          int end = ${getFinalCoord(rank, "coords")};
          float val = ${val};
          int pow2 = int(pow(2.0, index));
          if (${condition}) {
            int idx = ${idxString};
            ${getFinalCoord(rank, "coords")} = idx;
            val += getX(${getCoords2(rank, "coords")});
          }
          setOutput(val);
        }
      `;
      }
      getCustomSetupFunc(index2) {
        return (gpgpu, webGLProgram) => {
          if (this.index == null) {
            this.index = gpgpu.getUniformLocation(webGLProgram, "index");
          }
          gpgpu.gl.uniform1f(this.index, index2);
        };
      }
    };
    function getCoords2(rank, name) {
      if (rank === 1) {
        return `${name}`;
      } else if (rank === 2) {
        return `${name}.x, ${name}.y`;
      } else if (rank === 3) {
        return `${name}.x, ${name}.y, ${name}.z`;
      } else if (rank === 4) {
        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
      } else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
      }
    }
    function getFinalCoord(rank, name) {
      if (rank === 1) {
        return `${name}`;
      } else if (rank === 2) {
        return `${name}.y`;
      } else if (rank === 3) {
        return `${name}.z`;
      } else if (rank === 4) {
        return `${name}.w`;
      } else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
      }
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Cumsum.js
    function cumsum(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, exclusive, reverse: reverse2 } = attrs;
      const xRank = x.shape.length;
      const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
      let permutedX = x;
      if (permutation != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });
      }
      const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
      if (permutedAxis !== xRank - 1) {
        throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.shape.length - 1} but got axis=${axis}`);
      }
      const size = permutedX.shape[permutedAxis];
      let result2 = identity2({ inputs: { x: permutedX }, backend });
      for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {
        const program = new CumSumProgram(permutedX.shape, false, reverse2);
        const customSetup = program.getCustomSetupFunc(i);
        const prevResult = result2;
        result2 = backend.runWebGLProgram(program, [result2], result2.dtype, customSetup);
        backend.disposeIntermediateTensorInfo(prevResult);
      }
      if (exclusive) {
        const program = new CumSumProgram(permutedX.shape, exclusive, reverse2);
        const prevResult = result2;
        result2 = backend.runWebGLProgram(program, [result2], result2.dtype);
        backend.disposeIntermediateTensorInfo(prevResult);
      }
      if (permutation != null) {
        const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = transpose({ inputs: { x: result2 }, backend, attrs: { perm: reversePermutation } });
        backend.disposeIntermediateTensorInfo(result2);
        backend.disposeIntermediateTensorInfo(permutedX);
        return reverseTransposedResult;
      }
      return result2;
    }
    var cumsumConfig = {
      kernelName: Cumsum,
      backendName: "webgl",
      kernelFunc: cumsum
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/DenseBincount.js
    function denseBincount(args) {
      const { inputs, backend, attrs } = args;
      const { x, weights } = inputs;
      const { size, binaryOutput } = attrs;
      if (x.shape.length === 1) {
        const xVals = backend.readSync(x.dataId);
        const weightsVals = backend.readSync(weights.dataId);
        const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
        return backend.makeTensorInfo([size], weights.dtype, outVals);
      } else if (x.shape.length === 2) {
        const xBuf = backend.bufferSync(x);
        const weightsBuf = backend.bufferSync(weights);
        const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);
        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
      }
      throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x.shape.length}.`);
    }
    var denseBincountConfig = {
      kernelName: DenseBincount,
      backendName: "webgl",
      kernelFunc: denseBincount
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/depth_to_space_gpu.js
    var DepthToSpaceProgram = class {
      constructor(outputShape, blockSize, dataFormat) {
        this.variableNames = ["x"];
        this.outputShape = [];
        this.outputShape = outputShape;
        this.blockSize = blockSize;
        this.dataFormat = dataFormat;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int h = ${this.getHeightCoordString()};
        int w = ${this.getWidthCoordString()};
        int d = ${this.getDepthCoordString()};
  
        int in_h = h / ${blockSize};
        int offset_h = imod(h, ${blockSize});
        int in_w = w / ${blockSize};
        int offset_w = imod(w, ${blockSize});
        int offset_d = (offset_h * ${blockSize} + offset_w) *
          ${this.getOutputDepthSize()};
        int in_d = d + offset_d;
  
        float result = ${this.getInputSamplingString()};
        setOutput(result);
      }
    `;
      }
      getHeightCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[1]`;
        } else {
          return `coords[2]`;
        }
      }
      getWidthCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[2]`;
        } else {
          return `coords[3]`;
        }
      }
      getDepthCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[3]`;
        } else {
          return `coords[1]`;
        }
      }
      getOutputDepthSize() {
        if (this.dataFormat === "NHWC") {
          return this.outputShape[3];
        } else {
          return this.outputShape[1];
        }
      }
      getInputSamplingString() {
        if (this.dataFormat === "NHWC") {
          return `getX(b, in_h, in_w, in_d)`;
        } else {
          return `getX(b, in_d, in_h, in_w)`;
        }
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/DepthToSpace.js
    function depthToSpace(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { blockSize, dataFormat } = attrs;
      util_exports.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
      const batchSize = x.shape[0];
      const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
      const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
      const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
      const outputHeight = inputHeight * blockSize;
      const outputWidth = inputWidth * blockSize;
      const outputDepth = inputDepth / (blockSize * blockSize);
      const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
      const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
    var depthToSpaceConfig = {
      kernelName: DepthToSpace,
      backendName: "webgl",
      kernelFunc: depthToSpace
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/conv_gpu_depthwise.js
    var DepthwiseConv2DProgram = class {
      constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation) {
          if (hasPreluActivation) {
            activationSnippet = `float activation(float a) {
            float b = getPreluActivationWeightsAtOutCoords();
            ${activation}
          }`;
          } else if (hasLeakyReluAlpha) {
            activationSnippet = `float activation(float a) {
            float b = getLeakyreluAlphaAtOutCoords();
            ${activation}
          }`;
          } else {
            activationSnippet = `
            float activation(float x) {
              ${activation}
            }
          `;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        if (hasLeakyReluAlpha) {
          this.variableNames.push("leakyreluAlpha");
        }
        this.userCode = `
        ${activationSnippet}
  
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords.x;
          ivec2 xRCCorner = coords.yz * strides - pads;
          int d2 = coords.w;
          int d1 = d2 / ${channelMul};
          int q = d2 - d1 * ${channelMul};
  
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;
  
          // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
          // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};
  
            if (xR < 0 || xR >= ${xNumRows}) {
              continue;
            }
  
            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};
  
              if (xC < 0 || xC >= ${xNumCols}) {
                continue;
              }
  
              float xVal = getX(batch, xR, xC, d1);
              float wVal = getW(wR, wC, d1, q);
              dotProd += xVal * wVal;
            }
          }
  
          float result = dotProd;
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js
    var DepthwiseConvPacked2DProgram = class {
      constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
        this.variableNames = ["x", "W"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = convInfo.outShape;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const texelsAcross = filterWidth;
        let mainLoop = `
        int xR; int xC; int xCOffset;
        vec4 wTexel; vec4 previous; vec4 final;`;
        for (let c = 0; c < filterWidth; c++) {
          mainLoop += `
            vec4 xTexelC${c * 2};
            int xTexelC${c * 2}Ready;
            vec4 xC${c};`;
        }
        for (let r = 0; r < filterHeight; r++) {
          for (let c = 0; c < filterWidth; c++) {
            mainLoop += `
            xTexelC${c * 2} = vec4(0.0);
            xTexelC${c * 2}Ready = 0;
            xC${c} = vec4(0.0);`;
          }
          mainLoop += `
          xR = xRCorner + ${r * dilationHeight};
          if (xR >=0 && xR < ${xNumRows}) {
        `;
          for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
            const colIndex = texelC * 2;
            const c = colIndex * dilationWidth;
            mainLoop += `
            xC = xCCorner + ${c};
            `;
            if (strideWidth === 1) {
              if (colIndex < filterWidth) {
                if (padLeft % 2 === 1) {
                  mainLoop += `
                  xCOffset = xC + 1;
                  if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {
                    xTexelC${c} = getX(batch, xR, xCOffset, d1);
  
                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= ${xNumCols}) {
                      xTexelC${c}.zw = vec2(0.0);
                    }
                    xTexelC${c}Ready = 1;
                  }
                `;
                  if (dilationWidth === 1 && c > 0) {
                    mainLoop += `
                  xC${colIndex} = vec4(xTexelC${c - 2}.zw, xTexelC${c}.xy);
                  `;
                  } else {
                    mainLoop += `
                    xCOffset = xC + 1 - 2;
  
                    if (xCOffset >= 0 && xCOffset < ${xNumCols}) {
                      previous = getX(batch, xR, xCOffset, d1);
  
                      // Need to manually clear unused channels in case
                      // we're reading from recycled texture.
                      if (xCOffset + 1 >= ${xNumCols}) {
                        previous.zw = vec2(0.0);
                      }
  
                      xC${colIndex} = vec4(previous.zw, xTexelC${c}.xy);
                    } else {
                      xC${colIndex} = vec4(0.0, 0.0, xTexelC${c}.xy);
                    }
                    `;
                  }
                } else {
                  mainLoop += `
                  if (xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {
                    xTexelC${c} = getX(batch, xR, xC, d1);
                    if (xC + 1 >= ${xNumCols}) {
                      xTexelC${c}.zw = vec2(0.0);
                    }
                    xTexelC${c}Ready = 1;
                  }
  
                  xC${colIndex} = xTexelC${c};
                  `;
                }
                if (c + 1 < filterWidth) {
                  const nextTexelOffset = padLeft % 2 === 0 ? util_exports.nearestLargerEven(dilationWidth) : dilationWidth;
                  if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                    mainLoop += `
                    xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};
  
                    if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {
                      xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);
  
                      // Need to manually clear unused channels in case
                      // we're reading from recycled texture.
                      if (xCOffset + 1 >= ${xNumCols}) {
                        xTexelC${c + 2}.zw = vec2(0.0);
                      }
                      xTexelC${c + 2}Ready = 1;
                    }
                    `;
                    if (dilationWidth > 1) {
                      mainLoop += `
                      xCOffset -= 2;
                      if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {
                        xTexelC${c} = getX(batch, xR, xCOffset, d1);
                        xTexelC${c}Ready = 1;
                      }
                      `;
                    }
                    mainLoop += `
                    xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.xy);
                    `;
                  } else {
                    if (nextTexelOffset === 1) {
                      mainLoop += `
                      xC${colIndex + 1} = xTexelC${c};
                      `;
                    } else {
                      mainLoop += `
                      xCOffset = xC + ${nextTexelOffset};
  
                      if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {
                        xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);
                        if (xCOffset + 1 >= ${xNumCols}) {
                          xTexelC${c + 2}.zw = vec2(0.0);
                        }
                        xTexelC${c + 2}Ready = 1;
                      }
  
                      xC${colIndex + 1} = xTexelC${c + 2};
                      `;
                    }
                  }
                }
              }
            } else {
              if (c < filterWidth) {
                if (padLeft % 2 === 1) {
                  mainLoop += `
                  xCOffset = xC + 1 - ${strideWidth};
                  if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {
                    xTexelC${c} = getX(batch, xR, xCOffset, d1);
                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= ${xNumCols}) {
                      xTexelC${c}.zw = vec2(0.0);
                    }
                    xTexelC${c}Ready = 1;
                  }
  
                  if(xC + 1 >= 0 && xC + 1 < ${xNumCols} && xTexelC${c + 2}Ready == 0) {
                    xTexelC${c + 2} = getX(batch, xR, xC + 1, d1);
                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xC + 2 >= ${xNumCols}) {
                      xTexelC${c + 2}.zw = vec2(0.0);
                    }
                    xTexelC${c + 2}Ready = 1;
                  }
  
                  xC${colIndex} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);
                `;
                  if (c + 1 < filterWidth) {
                    mainLoop += `
                    final = vec4(0.0);
                    xCOffset = xC + 1 + ${strideWidth};
                    if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                      final = getX(batch, xR, xCOffset, d1);
                    }
                    xC${colIndex + 1} = vec4(xTexelC${c + 2}.xy, final.xy);
                  `;
                  }
                } else {
                  mainLoop += `
                  if(xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {
                    xTexelC${c} = getX(batch, xR, xC, d1);
                    if (xC + 1 >= ${xNumCols}) {
                      xTexelC${c}.zw = vec2(0.0);
                    }
                    xTexelC${c}Ready = 1;
                  }
  
                  xCOffset = xC + ${strideWidth};
                  if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {
                    xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);
                    if (xCOffset + 1 >= ${xNumCols}) {
                      xTexelC${c + 2}.zw = vec2(0.);
                    }
                    xTexelC${c + 2}Ready = 1;
                  }
  
                  xC${colIndex} = vec4(
                    xTexelC${c}.xy, xTexelC${c + 2}.xy);
                `;
                  if (c + 1 < filterWidth) {
                    mainLoop += `
                    xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);
                  `;
                  }
                }
              }
            }
            if (colIndex < filterWidth) {
              mainLoop += `
              wTexel = getW(${r}, ${c}, d1, q);
              dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
            `;
              if (c + 1 < filterWidth) {
                mainLoop += `
                wTexel = getW(${r}, ${c + 1}, d1, q);
                dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
              `;
              }
            }
          }
          mainLoop += `
          }
        `;
        }
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation) {
          if (hasPreluActivation) {
            activationSnippet = `vec4 activation(vec4 a) {
            vec4 b = getPreluActivationWeightsAtOutCoords();
            ${activation}
          }`;
          } else if (hasLeakyReluAlpha) {
            activationSnippet = `vec4 activation(vec4 a) {
            vec4 b = getLeakyreluAlphaAtOutCoords();
            ${activation}
          }`;
          } else {
            activationSnippet = `vec4 activation(vec4 x) {
            ${activation}
          }`;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        if (hasLeakyReluAlpha) {
          this.variableNames.push("leakyreluAlpha");
        }
        this.userCode = `
        ${activationSnippet}
  
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
  
          ivec4 coords = getOutputCoords();
          int batch = coords.x;
          ivec2 xRCCorner = coords.yz * strides - pads;
          int d2 = coords.w;
          int d1 = d2 / ${channelMul};
          int q = d2 - d1 * ${channelMul};
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;
  
          //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
          vec4 dotProd = vec4(0.000000000000001);
  
          ${mainLoop}
  
          vec4 result = dotProd - vec4(0.000000000000001);
          ${addBiasSnippet}
          ${applyActivationSnippet}
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js
    function depthwiseConv2dNative(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter } = inputs;
      const { strides, pad, dilations, dimRoundingMode } = attrs;
      let $dilations = dilations;
      if ($dilations == null) {
        $dilations = [1, 1];
      }
      util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
      let program;
      if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
        program = new DepthwiseConvPacked2DProgram(convInfo);
      } else {
        program = new DepthwiseConv2DProgram(convInfo);
      }
      return backend.runWebGLProgram(program, [x, filter], "float32");
    }
    var depthwiseConv2dNativeConfig = {
      kernelName: DepthwiseConv2dNative,
      backendName: "webgl",
      kernelFunc: depthwiseConv2dNative
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js
    var DepthwiseConv2DDerFilterProgram = class {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int wR = coords.x;
          int wC = coords.y;
          int d1 = coords.z;
          int dm = coords.w;
          int d2 = d1 * ${channelMul} + dm;
  
          float dotProd = 0.0;
  
          // TO DO: Vec4 over the batch size
          for (int b = 0; b < ${convInfo.batchSize}; b++) {
            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};
  
              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }
  
              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};
  
                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }
  
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var DepthwiseConv2DDerInputProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d1 = coords[3];
          ivec2 dyCorner = coords.yz - pads;
          int dyRCorner = dyCorner.x;
          int dyCCorner = dyCorner.y;
  
          float dotProd = 0.0;
  
          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);
  
            int wRPerm = ${filterHeight} - 1 - wR;
  
            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);
  
              int wCPerm = ${filterWidth} - 1 - wC;
  
              // TO DO: Vec4 over the channelMul
              for (int dm = 0; dm < ${channelMul}; dm++) {
                int d2 = d1 * ${channelMul} + dm;
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, dm);
                dotProd += xValue * wValue;
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
    function depthwiseConv2dNativeBackpropFilter(args) {
      const { inputs, backend, attrs } = args;
      const { x, dy } = inputs;
      const { strides, dilations, pad, dimRoundingMode, filterShape } = attrs;
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true);
      const program = new DepthwiseConv2DDerFilterProgram(convInfo);
      return backend.runWebGLProgram(program, [x, dy], "float32");
    }
    var depthwiseConv2dNativeBackpropFilterConfig = {
      kernelName: DepthwiseConv2dNativeBackpropFilter,
      backendName: "webgl",
      kernelFunc: depthwiseConv2dNativeBackpropFilter
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
    function depthwiseConv2dNativeBackpropInput(args) {
      const { inputs, backend, attrs } = args;
      const { dy, filter } = inputs;
      const { strides, dilations, pad, dimRoundingMode, inputShape } = attrs;
      const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
      const program = new DepthwiseConv2DDerInputProgram(convInfo);
      return backend.runWebGLProgram(program, [dy, filter], "float32");
    }
    var depthwiseConv2dNativeBackpropInputConfig = {
      kernelName: DepthwiseConv2dNativeBackpropInput,
      backendName: "webgl",
      kernelFunc: depthwiseConv2dNativeBackpropInput
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/diag_gpu.js
    var DiagProgram = class {
      constructor(size) {
        this.variableNames = ["X"];
        this.outputShape = [size, size];
        this.userCode = `
        void main() {
            ivec2 coords = getOutputCoords();
            float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
            setOutput(val);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Diag.js
    function diag(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      const outShape = [...x.shape, ...x.shape];
      const xSize = util_exports.sizeFromShape(x.shape);
      const flat = reshape2({ inputs: { x }, backend, attrs: { shape: [xSize] } });
      const program = new DiagProgram(xSize);
      const res = backend.runWebGLProgram(program, [flat], flat.dtype);
      const out = reshape2({ inputs: { x: res }, backend, attrs: { shape: outShape } });
      backend.disposeIntermediateTensorInfo(flat);
      backend.disposeIntermediateTensorInfo(res);
      return out;
    }
    var diagConfig = {
      kernelName: Diag,
      backendName: "webgl",
      kernelFunc: diag
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/dilation_gpu.js
    var Dilation2DProgram = class {
      constructor(convInfo) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
        const { top: padTop, left: padLeft } = padInfo;
        this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
        const float neg_infinity = -3.4e38;
  
        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords.x;
          int d1 = coords.w;
          ivec2 outTopLeftCorner =
              coords.yz * strides - pads;
          int hBeg = outTopLeftCorner.x;
          int wBeg = outTopLeftCorner.y;
  
          float curVal = neg_infinity;
          for (int h = 0; h < ${filterHeight}; h++) {
            int hIn = hBeg + h * ${dilationHeight};
  
            if (hIn >= 0 && hIn < ${inHeight}) {
              for (int w = 0; w < ${filterWidth}; w++) {
                int wIn = wBeg + w * ${dilationWidth};
  
                if (wIn >= 0 && wIn < ${inWidth}) {
                  float xVal = getX(batch, hIn, wIn, d1);
                  float wVal = getW(h, w, d1);
  
                  float val = xVal + wVal;
                  if (val > curVal) {
                    curVal = val;
                  }
                }
              }
            }
          }
  
          float result = curVal;
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Dilation2D.js
    function dilation2D(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter } = inputs;
      const { strides, pad, dilations } = attrs;
      const convInfo = backend_util_exports.computeDilation2DInfo(x.shape, filter.shape, strides, pad, "NHWC", dilations);
      let out;
      const program = new Dilation2DProgram(convInfo);
      out = backend.runWebGLProgram(program, [x, filter], "float32");
      const outReshaped = reshape2({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
      backend.disposeIntermediateTensorInfo(out);
      return outReshaped;
    }
    var dilation2DConfig = {
      kernelName: Dilation2D,
      backendName: "webgl",
      kernelFunc: dilation2D
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Einsum.js
    function einsum(args) {
      const { inputs, backend, attrs } = args;
      const { equation } = attrs;
      const tensors = inputs;
      const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
      backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
      const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
      const nSteps = steps.length;
      let out = null;
      let numDimsRemaining = allDims.length;
      const tensorsToDispose = [];
      for (let i = 0; i < nSteps; ++i) {
        for (const idTerm of steps[i]) {
          const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
          let x;
          if (backend_util_exports.isIdentityPermutation(perm)) {
            x = tensors[idTerm];
          } else {
            x = transpose({ inputs: { x: tensors[idTerm] }, backend, attrs: { perm } });
            tensorsToDispose.push(x);
          }
          const targetShape = x.shape.slice();
          for (let k = 0; k < dimsToExpand.length; ++k) {
            targetShape.splice(dimsToExpand[k], 0, 1);
          }
          if (!util_exports.arraysEqual(x.shape, targetShape)) {
            x = reshape2({ inputs: { x }, backend, attrs: { shape: targetShape } });
            tensorsToDispose.push(x);
          }
          if (out === null) {
            out = x;
          } else {
            out = multiply2({ inputs: { a: x, b: out }, backend });
            tensorsToDispose.push(out);
          }
        }
        if (i < nSteps - 1) {
          if (path[i] >= 0) {
            out = sum3({
              inputs: { x: out },
              backend,
              attrs: {
                axis: path[i] - (allDims.length - numDimsRemaining),
                keepDims: false
              }
            });
            tensorsToDispose.push(out);
          }
          numDimsRemaining--;
        }
      }
      for (const tensorInfo of tensorsToDispose) {
        if (tensorInfo === out) {
          continue;
        }
        backend.disposeIntermediateTensorInfo(tensorInfo);
      }
      return out;
    }
    var einsumConfig = {
      kernelName: Einsum,
      backendName: "webgl",
      kernelFunc: einsum
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Elu.js
    var ELU3 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
    var ELU_PACKED = `
    vec4 result;
  
    result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
    result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
    result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
    result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);
  
    return result;
  `;
    var elu2 = unaryKernelFunc({ opSnippet: ELU3, packedOpSnippet: ELU_PACKED });
    var eluConfig = {
      kernelName: Elu,
      backendName: "webgl",
      kernelFunc: elu2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/EluGrad.js
    var ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
    var ELU_DER_PACKED = `
    vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
    return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
  `;
    var eluGrad = (args) => {
      const { inputs, backend } = args;
      const { dy, y } = inputs;
      const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y.shape);
      return backend.runWebGLProgram(program, [dy, y], dy.dtype);
    };
    var eluGradConfig = {
      kernelName: EluGrad,
      backendName: "webgl",
      kernelFunc: eluGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Equal.js
    var PACKED_EQUAL = `
    return vec4(equal(a, b));
  `;
    var EQUAL = `return float(a == b);`;
    var equal2 = binaryKernelFunc2({
      opSnippet: EQUAL,
      packedOpSnippet: PACKED_EQUAL,
      dtype: "bool",
      cpuKernelImpl: equalImplCPU
    });
    var equalConfig = {
      kernelName: Equal,
      backendName: "webgl",
      kernelFunc: equal2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Erf.js
    var ERF = `
    // Error function is calculated approximately with elementary function.
    // See "Handbook of Mathematical Functions with Formulas,
    // Graphs, and Mathematical Tables", Abramowitz and Stegun.
    float p = ${backend_util_exports.ERF_P};
    float a1 = ${backend_util_exports.ERF_A1};
    float a2 = ${backend_util_exports.ERF_A2};
    float a3 = ${backend_util_exports.ERF_A3};
    float a4 = ${backend_util_exports.ERF_A4};
    float a5 = ${backend_util_exports.ERF_A5};
  
    float sign = sign(x);
    x = abs(x);
    float t = 1.0 / (1.0 + p * x);
    return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
  `;
    var erf = unaryKernelFunc({ opSnippet: ERF });
    var erfConfig = {
      kernelName: Erf,
      backendName: "webgl",
      kernelFunc: erf
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Exp.js
    var EXP = `return exp(x);`;
    var exp2 = unaryKernelFunc({ opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: expImplCPU });
    var expConfig = {
      kernelName: Exp,
      backendName: "webgl",
      kernelFunc: exp2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ExpandDims.js
    function expandDims(args) {
      const { inputs, attrs, backend } = args;
      const { dim } = attrs;
      const { input } = inputs;
      const inputRank = input.shape.length;
      const newShape = input.shape.slice();
      let $dim = dim;
      if (dim < 0) {
        util_exports.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
        $dim = inputRank + dim + 1;
      }
      newShape.splice($dim, 0, 1);
      return reshape2({ inputs: { x: input }, backend, attrs: { shape: newShape } });
    }
    var expandDimsConfig = {
      kernelName: ExpandDims,
      backendName: "webgl",
      kernelFunc: expandDims
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Expm1.js
    var EXPM1 = `return exp(x) - 1.0;`;
    var expm12 = unaryKernelFunc({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
    var expm1Config = {
      kernelName: Expm1,
      backendName: "webgl",
      kernelFunc: expm12
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/fft_gpu.js
    var FFTProgram = class {
      constructor(component, inputShape, inverse) {
        this.variableNames = ["real", "imag"];
        const innerDim = inputShape[1];
        this.outputShape = inputShape;
        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
        const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
        let opString;
        if (component === "real") {
          opString = "return real * expR - imag * expI;";
        } else if (component === "imag") {
          opString = "return real * expI + imag * expR;";
        } else {
          throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
        }
        this.userCode = `
        const float exponentMultiplier = ${exponentMultiplierSnippet};
  
        float unaryOpComplex(float real, float expR, float imag, float expI) {
          ${opString}
        }
  
        float mulMatDFT(int batch, int index) {
          float indexRatio = float(index) / float(${innerDim});
          float exponentMultiplierTimesIndexRatio =
              exponentMultiplier * indexRatio;
  
          float result = 0.0;
  
          for (int i = 0; i < ${innerDim}; i++) {
            // x = (-2|2 * PI / N) * index * i;
            float x = exponentMultiplierTimesIndexRatio * float(i);
            float expR = cos(x);
            float expI = sin(x);
            float real = getReal(batch, i);
            float imag = getImag(batch, i);
  
            result +=
                unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
          }
  
          return result;
        }
  
        void main() {
          ivec2 coords = getOutputCoords();
          setOutput(mulMatDFT(coords[0], coords[1]));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FFT_impl.js
    function fftImpl(x, inverse, backend) {
      const xData = backend.texData.get(x.dataId);
      const inputSize = util_exports.sizeFromShape(x.shape);
      const innerDimensionSize = x.shape[x.shape.length - 1];
      const batch = inputSize / innerDimensionSize;
      const input2D = reshape2({ inputs: { x }, backend, attrs: { shape: [batch, innerDimensionSize] } });
      const xShape = input2D.shape;
      const realProgram = new FFTProgram("real", xShape, inverse);
      const imagProgram = new FFTProgram("imag", xShape, inverse);
      const inputs = [
        {
          dataId: xData.complexTensorInfos.real.dataId,
          dtype: xData.complexTensorInfos.real.dtype,
          shape: xShape
        },
        {
          dataId: xData.complexTensorInfos.imag.dataId,
          dtype: xData.complexTensorInfos.imag.dtype,
          shape: xShape
        }
      ];
      const realPart = backend.runWebGLProgram(realProgram, inputs, "float32");
      const imagPart = backend.runWebGLProgram(imagProgram, inputs, "float32");
      const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend });
      backend.disposeIntermediateTensorInfo(realPart);
      backend.disposeIntermediateTensorInfo(imagPart);
      const complexOutputReshaped = reshape2({ inputs: { x: complexOutput }, backend, attrs: { shape: x.shape } });
      backend.disposeIntermediateTensorInfo(input2D);
      backend.disposeIntermediateTensorInfo(complexOutput);
      return complexOutputReshaped;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FFT.js
    function fft(args) {
      const { inputs, backend } = args;
      const { input } = inputs;
      return fftImpl(input, false, backend);
    }
    var fftConfig = {
      kernelName: FFT,
      backendName: "webgl",
      kernelFunc: fft
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/fill_gpu.js
    var FillProgram = class {
      constructor(shape, value) {
        this.outputShape = [];
        this.variableNames = ["x"];
        this.outputShape = shape;
        this.userCode = `
        uniform float value;
        void main() {
          // Input can be obtained from uniform value.
          setOutput(value);
        }
      `;
      }
      getCustomSetupFunc(value) {
        return (gpgpu, webGLProgram) => {
          if (this.valueLoc == null) {
            this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "value");
          }
          gpgpu.gl.uniform1f(this.valueLoc, value);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Fill.js
    function fill(args) {
      const { backend, attrs } = args;
      const { shape, value } = attrs;
      let { dtype } = attrs;
      dtype = dtype || util_exports.inferDtype(value);
      if (dtype === "string") {
        const values = util_exports.getArrayFromDType(dtype, util_exports.sizeFromShape(shape));
        values.fill(value);
        return backend.makeTensorInfo(shape, dtype, values);
      } else {
        const program = new FillProgram(shape, value);
        const customSetup = program.getCustomSetupFunc(value);
        return backend.runWebGLProgram(program, [], dtype, customSetup);
      }
    }
    var fillConfig = {
      kernelName: Fill,
      backendName: "webgl",
      kernelFunc: fill
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/flip_left_right_gpu.js
    var FlipLeftRightProgram = class {
      constructor(imageShape) {
        this.variableNames = ["Image"];
        this.outputShape = [];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        this.userCode = `
          void main() {
            ivec4 coords = getOutputCoords();
            int x = coords[2];
  
            int coordX = ${imageWidth} - x;
            float outputValue;
            if(coordX >= 0 && coordX < ${imageWidth}) {
              outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
            } else {
              outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
            }
            setOutput(outputValue);
          }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js
    var flipLeftRightConfig = {
      kernelName: FlipLeftRight,
      backendName: "webgl",
      kernelFunc: ({ inputs, backend }) => {
        const { image: image2 } = inputs;
        const webglBackend = backend;
        const program = new FlipLeftRightProgram(image2.shape);
        const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype);
        return output;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Floor.js
    var FLOOR = `return floor(x);`;
    var floor2 = unaryKernelFunc({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
    var floorConfig = {
      kernelName: Floor,
      backendName: "webgl",
      kernelFunc: floor2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FloorDiv.js
    var INT_DIV = `
    float s = sign(a) * sign(b);
    int ia = round(a);
    int ib = round(b);
    if (ib != 0) {
      // Windows (D3D) wants guaranteed non-zero int division at compile-time.
      return float(idiv(ia, ib, s));
    } else {
      return NAN;
    }
  `;
    var INT_DIV_PACKED = `
    ivec4 ia = round(a);
    ivec4 ib = round(b);
    bvec4 cond = notEqual(ib, ivec4(0));
    ivec4 result = ivec4(0);
    vec4 s = sign(a) * sign(b);
  
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    if (cond[0]) {
      result[0] = idiv(ia[0], ib[0], s[0]);
    }
    if (cond[1]) {
      result[1] = idiv(ia[1], ib[1], s[1]);
    }
    if (cond[2]) {
      result[2] = idiv(ia[2], ib[2], s[2]);
    }
    if (cond[3]) {
      result[3] = idiv(ia[3], ib[3], s[3]);
    }
    return vec4(result);
  `;
    var floorDiv = binaryKernelFunc2({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
    var floorDivConfig = {
      kernelName: FloorDiv,
      backendName: "webgl",
      kernelFunc: floorDiv
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js
    var FromPixelsProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        const glsl = getGlslDifferences();
        const [height, width] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
        void main() {
          ivec3 coords = getOutputCoords();
          int texR = coords[0];
          int texC = coords[1];
          int depth = coords[2];
          vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);
  
          vec4 values = ${glsl.texture2D}(A, uv);
          float value;
          if (depth == 0) {
            value = values.r;
          } else if (depth == 1) {
            value = values.g;
          } else if (depth == 2) {
            value = values.b;
          } else if (depth == 3) {
            value = values.a;
          }
  
          setOutput(floor(value * 255.0 + 0.5));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js
    var FromPixelsPackedProgram = class {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = getGlslDifferences();
        const [height, width] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
        void main() {
          ivec3 coords = getOutputCoords();
          int texR = coords[0];
          int texC = coords[1];
          int depth = coords[2];
  
          vec4 result = vec4(0.);
  
          for(int row=0; row<=1; row++) {
            for(int col=0; col<=1; col++) {
              texC = coords[1] + row;
              depth = coords[2] + col;
  
              vec2 uv = (vec2(texC, texR) + halfCR) /
                         vec2(${width}.0, ${height}.0);
              vec4 values = ${glsl.texture2D}(A, uv);
              float value;
              if (depth == 0) {
                value = values.r;
              } else if (depth == 1) {
                value = values.g;
              } else if (depth == 2) {
                value = values.b;
              } else if (depth == 3) {
                value = values.a;
              }
  
              result[row * 2 + col] = floor(value * 255.0 + 0.5);
            }
          }
  
          ${glsl.output} = result;
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FromPixels.js
    var fromPixelsConfig = {
      kernelName: FromPixels,
      backendName: "webgl",
      kernelFunc: fromPixels
    };
    var fromPixels2DContext;
    function fromPixels(args) {
      const { inputs, backend, attrs } = args;
      let { pixels } = inputs;
      const { numChannels } = attrs;
      const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
      const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
      const [width, height] = isVideo ? [
        pixels.videoWidth,
        pixels.videoHeight
      ] : [pixels.width, pixels.height];
      const texShape = [height, width];
      const outShape = [height, width, numChannels];
      if (isImage || isVideo) {
        if (fromPixels2DContext == null) {
          fromPixels2DContext = document.createElement("canvas").getContext("2d");
        }
        fromPixels2DContext.canvas.width = width;
        fromPixels2DContext.canvas.height = height;
        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
        pixels = fromPixels2DContext.canvas;
      }
      const tempPixelHandle = backend.makeTensorInfo(texShape, "int32");
      backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
      backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);
      const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
      const res = backend.runWebGLProgram(program, [tempPixelHandle], "int32");
      backend.disposeData(tempPixelHandle.dataId);
      return res;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FusedConv2D.js
    function fusedConv2d(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter, bias, preluActivationWeights } = inputs;
      const { strides, pad, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
      const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
      let out;
      const intermediates = [];
      if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
        out = conv2dByMatMul({
          x,
          filter,
          convInfo,
          backend,
          bias,
          activation,
          preluActivationWeights,
          leakyreluAlpha
        });
      } else if (env().getBool("WEBGL_CONV_IM2COL") && x.shape[0] === 1) {
        out = conv2dWithIm2Row({
          x,
          filter,
          convInfo,
          backend,
          bias,
          activation,
          preluActivationWeights,
          leakyreluAlpha
        });
      } else {
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const hasLeakyreluAlpha = activation === "leakyrelu";
        const fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;
        const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs2 = [x, filter];
        if (bias) {
          inputs2.push(bias);
        }
        if (preluActivationWeights) {
          inputs2.push(preluActivationWeights);
        }
        if (hasLeakyreluAlpha) {
          const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
          inputs2.push($leakyreluAlpha);
          intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs2, "float32");
      }
      const outReshaped = reshape2({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
      intermediates.push(out);
      intermediates.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return outReshaped;
    }
    var fusedConv2DConfig = {
      kernelName: FusedConv2D,
      backendName: "webgl",
      kernelFunc: fusedConv2d
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js
    function fusedDepthwiseConv2D(args) {
      const { inputs, backend, attrs } = args;
      const { x, filter, bias, preluActivationWeights } = inputs;
      const { strides, pad, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
      const intermediates = [];
      let $dilations = dilations;
      if ($dilations == null) {
        $dilations = [1, 1];
      }
      util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
      const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
      const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
      const fusedActivation = activation ? mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) : null;
      const programInputs = [x, filter];
      const hasBias = bias != null;
      const hasPreluActivationWeights = preluActivationWeights != null;
      const hasLeakyreluAlpha = activation === "leakyrelu";
      if (hasBias) {
        programInputs.push(bias);
      }
      if (hasPreluActivationWeights) {
        programInputs.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], "float32", util_exports.createScalarValue(leakyreluAlpha, "float32"));
        programInputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      let program;
      if (shouldPackDepthwiseConv) {
        program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      } else {
        program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      }
      const result2 = backend.runWebGLProgram(program, programInputs, "float32");
      intermediates.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return result2;
    }
    var fusedDepthwiseConv2DConfig = {
      kernelName: FusedDepthwiseConv2D,
      backendName: "webgl",
      kernelFunc: fusedDepthwiseConv2D
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/gather_nd_gpu.js
    var GatherNDProgram = class {
      constructor(sliceDim, strides, shape) {
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = ["x", "indices"];
        this.outputShape = shape;
        const stridesType = getCoordsDataType(strides.length);
        const dtype = getCoordsDataType(shape.length);
        const strideString = this.sliceDim > 1 ? "strides[j]" : "strides";
        this.userCode = `
          ${stridesType} strides = ${stridesType}(${this.strides});
           void main() {
            ${dtype} coords = getOutputCoords();
            int flattenIndex = 0;
            for (int j = 0; j < ${this.sliceDim}; j++) {
              int index = round(getIndices(coords[0], j));
              flattenIndex += index * ${strideString};
            }
            setOutput(getX(flattenIndex, coords[1]));
          }
        `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/GatherNd.js
    function gatherNd(args) {
      const { inputs, backend } = args;
      const { params, indices } = inputs;
      const indicesShape = indices.shape;
      const sliceRank = indicesShape[indicesShape.length - 1];
      const paramsSize = util_exports.sizeFromShape(params.shape);
      const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
      const flattenIndices = reshape2({ inputs: { x: indices }, backend, attrs: { shape: [numSlices, sliceRank] } });
      const flattenX = reshape2({
        inputs: { x: params },
        backend,
        attrs: { shape: [util_exports.sizeFromShape(params.shape) / sliceSize, sliceSize] }
      });
      if (backend.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
        const indicesData = backend.readSync(indices.dataId);
        const paramsBuf = backend.bufferSync(params);
        const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
        return backend.makeTensorInfo(resultShape, params.dtype, outValue.values);
      }
      const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
      const res = backend.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
      const reshaped = reshape2({ inputs: { x: res }, backend, attrs: { shape: resultShape } });
      backend.disposeIntermediateTensorInfo(flattenIndices);
      backend.disposeIntermediateTensorInfo(flattenX);
      backend.disposeIntermediateTensorInfo(res);
      return reshaped;
    }
    var gatherNdConfig = {
      kernelName: GatherNd,
      backendName: "webgl",
      kernelFunc: gatherNd
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/gather_gpu.js
    var GatherProgram = class {
      constructor(aShape, outputShape) {
        this.variableNames = ["A", "indices"];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const sourceCoords = getSourceCoords2(aShape, 2);
        this.userCode = `
        void main() {
          ${dtype} resRC = getOutputCoords();
          setOutput(getA(${sourceCoords}));
        }
      `;
      }
    };
    function getSourceCoords2(aShape, axis) {
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const sourceCoords = [];
      for (let i = 0; i < aShape.length; i++) {
        if (i === 2) {
          sourceCoords.push("int(getIndices(resRC.x, resRC.z))");
        } else {
          sourceCoords.push(`${currentCoords[i]}`);
        }
      }
      return sourceCoords.join();
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/GatherV2.js
    function gatherV2(args) {
      const { inputs, backend, attrs } = args;
      const { x, indices } = inputs;
      const { axis, batchDims } = attrs;
      const parsedAxis = util_exports.parseAxisParam(axis, x.shape)[0];
      const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
      const indicesSize = util_exports.sizeFromShape(indices.shape);
      const toDispose = [];
      const flattenX = reshape2({
        inputs: { x },
        backend,
        attrs: {
          shape: [
            shapeInfo.batchSize,
            shapeInfo.outerSize,
            shapeInfo.dimSize,
            shapeInfo.sliceSize
          ]
        }
      });
      const flattenIndex = reshape2({
        inputs: { x: indices },
        backend,
        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
      });
      toDispose.push(flattenX);
      toDispose.push(flattenIndex);
      const flattenOutputShape = [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
      ];
      if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === "string") {
        const indicesBuf = backend.bufferSync(flattenIndex);
        const xBuf = backend.bufferSync(flattenX);
        const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
        toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
      }
      const program = new GatherProgram(flattenX.shape, flattenOutputShape);
      const res = backend.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
      toDispose.push(res);
      const reshaped = reshape2({ inputs: { x: res }, backend, attrs: { shape: shapeInfo.outputShape } });
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return reshaped;
    }
    var gatherV2Config = {
      kernelName: GatherV2,
      backendName: "webgl",
      kernelFunc: gatherV2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Greater.js
    var GREATER = `return float(a > b);`;
    var GREATER_PACKED = `
    return vec4(greaterThan(a, b));
  `;
    var greater2 = binaryKernelFunc2({
      opSnippet: GREATER,
      packedOpSnippet: GREATER_PACKED,
      cpuKernelImpl: greaterImplCPU,
      dtype: "bool"
    });
    var greaterConfig = {
      kernelName: Greater,
      backendName: "webgl",
      kernelFunc: greater2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/GreaterEqual.js
    var GREATER_EQUAL = `return float(a >= b);`;
    var GREATER_EQUAL_PACKED = `
    return vec4(greaterThanEqual(a, b));
  `;
    var greaterEqual2 = binaryKernelFunc2({
      opSnippet: GREATER_EQUAL,
      packedOpSnippet: GREATER_EQUAL_PACKED,
      dtype: "bool",
      cpuKernelImpl: greaterEqualImplCPU
    });
    var greaterEqualConfig = {
      kernelName: GreaterEqual,
      backendName: "webgl",
      kernelFunc: greaterEqual2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/IFFT.js
    function ifft(args) {
      const { inputs, backend } = args;
      const { input } = inputs;
      return fftImpl(input, true, backend);
    }
    var ifftConfig = {
      kernelName: IFFT,
      backendName: "webgl",
      kernelFunc: ifft
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/IsFinite.js
    var IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
    var isFinite2 = unaryKernelFunc({ opSnippet: IS_FINITE, dtype: "bool" });
    var isFiniteConfig = {
      kernelName: IsFinite,
      backendName: "webgl",
      kernelFunc: isFinite2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/IsInf.js
    var IS_INF = `return float(isinf(x));`;
    var isInf = unaryKernelFunc({ opSnippet: IS_INF, dtype: "bool" });
    var isInfConfig = {
      kernelName: IsInf,
      backendName: "webgl",
      kernelFunc: isInf
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/IsNaN.js
    var IS_NAN = `return float(isnan(x));`;
    var isNaN2 = unaryKernelFunc({ opSnippet: IS_NAN, dtype: "bool" });
    var isNaNConfig = {
      kernelName: IsNan,
      backendName: "webgl",
      kernelFunc: isNaN2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Less.js
    var LESS = `return float(a < b);`;
    var LESS_PACKED = `
    return vec4(lessThan(a, b));
  `;
    var less2 = binaryKernelFunc2({
      opSnippet: LESS,
      packedOpSnippet: LESS_PACKED,
      cpuKernelImpl: lessImplCPU,
      dtype: "bool"
    });
    var lessConfig = {
      kernelName: Less,
      backendName: "webgl",
      kernelFunc: less2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LessEqual.js
    var LESS_EQUAL = `return float(a <= b);`;
    var LESS_EQUAL_PACKED = `
    return vec4(lessThanEqual(a, b));
  `;
    var lessEqual2 = binaryKernelFunc2({
      opSnippet: LESS_EQUAL,
      packedOpSnippet: LESS_EQUAL_PACKED,
      cpuKernelImpl: lessEqualImplCPU,
      dtype: "bool"
    });
    var lessEqualConfig = {
      kernelName: LessEqual,
      backendName: "webgl",
      kernelFunc: lessEqual2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LinSpace.js
    function linSpace(args) {
      const { backend, attrs } = args;
      const { start, stop, num } = attrs;
      const outVals = linSpaceImplCPU(start, stop, num);
      return backend.makeTensorInfo([outVals.length], "float32", outVals);
    }
    var linSpaceConfig = {
      kernelName: LinSpace,
      backendName: "webgl",
      kernelFunc: linSpace
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Log.js
    var LOG = `if (x < 0.0) return NAN;
    return log(x);`;
    var LOG_PACKED = `
    vec4 result = log(x);
    vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
    result.r = isNaN.r == 1.0 ? NAN : result.r;
    result.g = isNaN.g == 1.0 ? NAN : result.g;
    result.b = isNaN.b == 1.0 ? NAN : result.b;
    result.a = isNaN.a == 1.0 ? NAN : result.a;
  
    return result;
  `;
    var log3 = unaryKernelFunc({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
    var logConfig = {
      kernelName: Log,
      backendName: "webgl",
      kernelFunc: log3
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Log1p.js
    var LOG1P = `return log(1.0 + x);`;
    var log1p = unaryKernelFunc({ opSnippet: LOG1P });
    var log1pConfig = {
      kernelName: Log1p,
      backendName: "webgl",
      kernelFunc: log1p
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LogicalAnd.js
    var LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
    var LOGICAL_AND_PACKED = `
    return vec4(
      vec4(greaterThanEqual(a, vec4(1.0))) *
      vec4(greaterThanEqual(b, vec4(1.0))));
  `;
    var logicalAnd = binaryKernelFunc2({
      opSnippet: LOGICAL_AND,
      packedOpSnippet: LOGICAL_AND_PACKED,
      dtype: "bool"
    });
    var logicalAndConfig = {
      kernelName: LogicalAnd,
      backendName: "webgl",
      kernelFunc: logicalAnd
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LogicalNot.js
    var LOGICAL_NOT = `return float(!(x >= 1.0));`;
    var logicalNot = unaryKernelFunc({ opSnippet: LOGICAL_NOT });
    var logicalNotConfig = {
      kernelName: LogicalNot,
      backendName: "webgl",
      kernelFunc: logicalNot
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LogicalOr.js
    var LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
    var LOGICAL_OR_PACKED = `
    return min(
      vec4(greaterThanEqual(a, vec4(1.0))) +
      vec4(greaterThanEqual(b, vec4(1.0))),
      vec4(1.0));
  `;
    var logicalOr = binaryKernelFunc2({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
    var logicalOrConfig = {
      kernelName: LogicalOr,
      backendName: "webgl",
      kernelFunc: logicalOr
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/lrn_gpu.js
    var LRNProgram = class {
      constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ["x"];
        this.outputShape = [];
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
          powOperator = `inversesqrt(${basis})`;
        } else if (beta === 1) {
          powOperator = `1.0/(${basis})`;
        } else {
          powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int r = coords[1];
          int c = coords[2];
          int d = coords[3];
          float x = getX(b, r, c, d);
          float sum = 0.0;
          for (int j = -${rad}; j <= ${rad}; j++) {
            int idx = d + j;
            if (idx >= 0 && idx <=  ${maxD}) {
              float z = getX(b, r, c, idx);
              sum += z * z;
            }
          }
          float val = x * ${powOperator};
          setOutput(val);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/lrn_packed_gpu.js
    var LRNPackedProgram = class {
      constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ["x"];
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
          powOperator = `inversesqrt(${basis})`;
        } else if (beta === 1) {
          powOperator = `1.0/(${basis})`;
        } else {
          powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords.x;
          int r = coords.y;
          int c = coords.z;
          int d = coords.w;
  
          bool hasNextCol = d < ${this.outputShape[3]};
          bool hasNextRow = c < ${this.outputShape[2]};
  
          vec4 sum = vec4(0.);
          vec4 xFragAtOutputCoords = getX(b, r, c, d);
  
          vec4 xAtOutputCoords = vec4(
            getChannel(xFragAtOutputCoords, vec2(c, d)),
            hasNextCol ?
              getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
            hasNextRow ?
              getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
            (hasNextRow && hasNextCol) ?
              getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
          );
  
          int firstChannel = d - ${rad};
          vec2 cache = vec2(0.);
          if(firstChannel >= 0){
            vec4 firstChannelFrag = getX(b, r, c, firstChannel);
            cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
              if(hasNextRow){
                cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
              }
          }
  
          ivec2 depth = ivec2(d, d + 1);
          for (int j = - ${rad}; j <= ${rad}; j++) {
            ivec2 idx = depth + j;
            bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
            bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));
  
            bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
            bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;
  
            if(depthInRange || depthPlusOneInRange){
              vec4 z = vec4(0.);
              vec4 xFragAtCurrentDepth;
              z.xz = cache.xy;
              if(depthPlusOneInRange && hasNextCol){
                xFragAtCurrentDepth = idx.y != d ?
                  getX(b, r, c, idx.y) : xFragAtOutputCoords;
                z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
                if(hasNextRow){
                  z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
                }
              }
              cache.xy = z.yw;
              sum += z * z;
            }
          }
          vec4 result = xAtOutputCoords * ${powOperator};
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LRN.js
    var lrn = (args) => {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { depthRadius, bias, alpha, beta } = attrs;
      const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x.shape, depthRadius, bias, alpha, beta);
      return backend.runWebGLProgram(program, [x], x.dtype);
    };
    var LRNConfig = {
      kernelName: LRN,
      backendName: "webgl",
      kernelFunc: lrn
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/lrn_grad_gpu.js
    var LRNGradProgram = class {
      constructor(inputShape, depthRadius, bias, alpha, beta) {
        this.variableNames = ["inputImage", "outputImage", "dy"];
        this.outputShape = [];
        this.outputShape = inputShape;
        this.depth = inputShape[3];
        this.depthRadius = depthRadius;
        this.bias = bias;
        this.alpha = alpha;
        this.beta = beta;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int r = coords[1];
          int c = coords[2];
  
          float result = 0.0;
          for (int d = 0; d < ${this.depth}; ++d) {
            int depthBegin = int(max(0.0, float(d - ${depthRadius})));
            int depthEnd = int(min(float(${this.depth}),
                float(d + ${depthRadius} + 1)));
  
            const int MIN_DEPTH_BEGIN = 0;
            const int MAX_DEPTH_END = ${this.depth};
  
            float norm = 0.0;
            for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
              if (k < depthBegin){
                continue;
              }
              else if (k >= depthBegin && k < depthEnd) {
                norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
              }
              else {
                break;
              }
            }
  
            norm = float(${alpha}) * norm + float(${bias});
  
            for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
              if (k < depthBegin){
                continue;
              }
              else if (k >= depthBegin && k < depthEnd){
                float dyi = -2.0 * float(${alpha})
                  * float(${beta})
                  * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                  / norm;
                if (k == d) {
                  dyi += pow(norm, -1.0 * ${beta});
                }
                if (k == coords[3]) {
                  dyi *= getDy(b, r, c, d);
                  result += dyi;
                }
              }
              else {
                break;
              }
            }
        }
        setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/LRNGrad.js
    var lrnGrad = (args) => {
      const { inputs, backend, attrs } = args;
      const { x, y, dy } = inputs;
      const { depthRadius, bias, alpha, beta } = attrs;
      const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);
      return backend.runWebGLProgram(program, [x, y, dy], x.dtype);
    };
    var LRNGradConfig = {
      kernelName: LRNGrad,
      backendName: "webgl",
      kernelFunc: lrnGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Max_impl.js
    function maxImpl2(x, reduceShape, outShape, backend) {
      const inSize = util_exports.sizeFromShape(reduceShape);
      const xSize = util_exports.sizeFromShape(x.shape);
      const batchSize = xSize / inSize;
      const reshapedInput = reshape2({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });
      const reduced = reduce(reshapedInput, x.dtype, "max", backend);
      const reshapedOutput = reshape2({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
      backend.disposeIntermediateTensorInfo(reshapedInput);
      backend.disposeIntermediateTensorInfo(reduced);
      return reshapedOutput;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Max.js
    function max(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { reductionIndices, keepDims } = attrs;
      const xRank = x.shape.length;
      const origAxes = util_exports.parseAxisParam(reductionIndices, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      const maxInputIsTransposed = permutedAxes != null;
      const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);
      let maxInput = x;
      if (maxInputIsTransposed) {
        if (shouldExecuteOnCPU) {
          const xTexData = backend.texData.get(maxInput.dataId);
          const values = xTexData.values;
          const newShape = new Array(xRank);
          for (let i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[permutedAxes[i]];
          }
          const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
          maxInput = backend.makeTensorInfo(newShape, x.dtype);
          const maxInputData = backend.texData.get(maxInput.dataId);
          maxInputData.values = maxInputValues;
        } else {
          maxInput = transposeImpl2(x, permutedAxes, backend);
        }
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
      const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(maxInput.shape, axes);
      let outShape = maxOutShape;
      if (keepDims) {
        outShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
      }
      let out;
      if (shouldExecuteOnCPU) {
        const xTexData = backend.texData.get(maxInput.dataId);
        const values = xTexData.values;
        const outValues = maxImplCPU(values, util_exports.sizeFromShape(reduceShape), outShape, x.dtype);
        out = backend.makeTensorInfo(outShape, x.dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
      } else {
        out = maxImpl2(maxInput, reduceShape, outShape, backend);
      }
      if (maxInputIsTransposed) {
        backend.disposeIntermediateTensorInfo(maxInput);
      }
      return out;
    }
    var maxConfig = {
      kernelName: Max,
      backendName: "webgl",
      kernelFunc: max
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Maximum.js
    var MAXIMUM = CHECK_NAN_SNIPPET2 + `
    return max(a, b);
  `;
    var MAXIMUM_PACKED = `
    vec4 result = vec4(max(a, b));
    vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
    ` + CHECK_NAN_SNIPPET3 + `
    return result;
  `;
    var maximum2 = binaryKernelFunc2({
      opSnippet: MAXIMUM,
      packedOpSnippet: MAXIMUM_PACKED,
      cpuKernelImpl: maximumImplCPU
    });
    var maximumConfig = {
      kernelName: Maximum,
      backendName: "webgl",
      kernelFunc: maximum2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPool.js
    function maxPool(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      assertNotComplex(x, "maxPool");
      const { filterSize, strides, pad, dimRoundingMode } = attrs;
      const dilations = 1;
      util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports.arraysEqual(convInfo.inShape, convInfo.outShape)) {
        return identity2({ inputs: { x }, backend });
      }
      const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
      return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);
    }
    var maxPoolConfig = {
      kernelName: MaxPool,
      backendName: "webgl",
      kernelFunc: maxPool
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPool3D.js
    function maxPool3d(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { filterSize, strides, pad, dataFormat, dimRoundingMode } = attrs;
      const dilations = [1, 1, 1];
      const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
      const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
      return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);
    }
    var maxPool3DConfig = {
      kernelName: MaxPool3D,
      backendName: "webgl",
      kernelFunc: maxPool3d
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js
    var MaxPool2DBackpropProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy", "maxPos"];
        this.outputShape = convInfo.inShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
        const ivec2 pads = ivec2(${padTop}, ${padLeft});
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
  
          ivec2 dyRCCorner = coords.yz - pads;
          int dyRCorner = dyRCCorner.x;
          int dyCCorner = dyRCCorner.y;
  
          // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);
  
            for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);
  
              float dyValue = getDy(b, idyR, idyC, d);
              int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));
  
              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue = wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);
  
              dotProd += dyValue * mask;
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
    var MaxPool3DBackpropProgram = class {
      constructor(convInfo) {
        this.variableNames = ["dy", "maxPos"];
        this.outputShape = convInfo.inShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
  
        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;
  
          ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
          int dyDCorner = dyCorner.x;
          int dyRCorner = dyCorner.y;
          int dyCCorner = dyCorner.z;
  
          // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
          // dx(xD, xR, xC, ch).
          // ? = to be determined. : = across all values in that axis.
          float dotProd = 0.0;
  
          for (int wD = 0; wD < ${effectiveFilterDepth};
             wD += ${dilationDepth}) {
            float dyD = float(dyDCorner + wD) / ${strideDepth}.0;
  
            if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
              continue;
            }
            int idyD = int(dyD);
  
            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              float dyR = float(dyRCorner + wR) / ${strideHeight}.0;
  
              if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                  fract(dyR) > 0.0) {
                continue;
              }
              int idyR = int(dyR);
  
              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                float dyC = float(dyCCorner + wC) / ${strideWidth}.0;
  
                if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                    fract(dyC) > 0.0) {
                  continue;
                }
                int idyC = int(dyC);
  
                float dyValue = getDy(batch, idyD, idyR, idyC, ch);
                int maxPosValue = ${lastIndex} -
                    int(getMaxPos(batch, idyD, idyR, idyC, ch));
  
                // Get the current value, check it against the value from the
                // position matrix.
                int curPosValue =
                    wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                    wR * ${effectiveFilterWidth} + wC;
                float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);
  
                dotProd += dyValue * mask;
              }
            }
          }
          setOutput(dotProd);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js
    function maxPool3DGrad(args) {
      const { inputs, backend, attrs } = args;
      const { dy, input } = inputs;
      const x = input;
      const { filterSize, strides, pad, dimRoundingMode } = attrs;
      const dilations = [1, 1, 1];
      const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
      const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, "max", true);
      const maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);
      const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
      const result2 = backend.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);
      backend.disposeIntermediateTensorInfo(maxPool3dPositions);
      return result2;
    }
    var maxPoolGrad3DConfig = {
      kernelName: MaxPool3DGrad,
      backendName: "webgl",
      kernelFunc: maxPool3DGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js
    function maxPoolGrad(args) {
      const { inputs, backend, attrs } = args;
      const { dy, input, output } = inputs;
      const x = input;
      assertNotComplex([input, output], "maxPoolGrad");
      const { filterSize, strides, pad, dimRoundingMode } = attrs;
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad, dimRoundingMode);
      const getPositions = true;
      const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
      const maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
      const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
      const result2 = backend.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);
      backend.disposeIntermediateTensorInfo(maxPoolPositions);
      return result2;
    }
    var maxPoolGradConfig = {
      kernelName: MaxPoolGrad,
      backendName: "webgl",
      kernelFunc: maxPoolGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js
    function maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, backend) {
      let program = new Pool2DProgram(convInfo, "max", false);
      const poolOutput = backend.runWebGLProgram(program, [x], "float32");
      program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
      const indexOutput = backend.runWebGLProgram(program, [x], "float32");
      return [poolOutput, indexOutput];
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js
    var maxPoolWithArgmaxConfig = {
      kernelName: MaxPoolWithArgmax,
      backendName: "webgl",
      kernelFunc: ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        const { filterSize, strides, pad, includeBatchInIndex } = attrs;
        const webglBackend = backend;
        util_exports.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
        const dilations = [1, 1];
        util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
        const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad);
        const [result2, indexes] = maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);
        return [result2, indexes];
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Mean_impl.js
    function meanImpl(x, reduceShape, outShape, backend) {
      const inSize = util_exports.sizeFromShape(reduceShape);
      const xSize = util_exports.sizeFromShape(x.shape);
      const batchSize = xSize / inSize;
      const reshapedInput = reshape2({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });
      const reduced = reduce(reshapedInput, "float32", "mean", backend);
      const reshapedOutput = reshape2({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
      backend.disposeIntermediateTensorInfo(reshapedInput);
      backend.disposeIntermediateTensorInfo(reduced);
      return reshapedOutput;
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Mean.js
    var meanConfig = {
      kernelName: Mean,
      backendName: "webgl",
      kernelFunc: ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        const { keepDims, axis } = attrs;
        const webglBackend = backend;
        const xRank = x.shape.length;
        const origAxes = util_exports.parseAxisParam(axis, x.shape);
        let axes = origAxes;
        const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
        const meanInputIsTransposed = permutedAxes != null;
        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
        const intermediates = [];
        let meanInput = x;
        if (meanInputIsTransposed) {
          if (shouldExecuteOnCPU) {
            const xTexData = webglBackend.texData.get(meanInput.dataId);
            const values = xTexData.values;
            const newShape = new Array(xRank);
            for (let i = 0; i < newShape.length; i++) {
              newShape[i] = x.shape[permutedAxes[i]];
            }
            const meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
            meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
            const meanInputData = webglBackend.texData.get(meanInput.dataId);
            meanInputData.values = meanInputValues;
          } else {
            meanInput = transposeImpl2(x, permutedAxes, webglBackend);
          }
          intermediates.push(meanInput);
          axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
        }
        backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
        const [meanOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(meanInput.shape, axes);
        let outShape = meanOutShape;
        if (keepDims) {
          outShape = backend_util_exports.expandShapeToKeepDim(meanOutShape, origAxes);
        }
        const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
        for (const i of intermediates) {
          webglBackend.disposeIntermediateTensorInfo(i);
        }
        return out;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Min.js
    function min(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, keepDims } = attrs;
      const xRank = x.shape.length;
      const origAxes = util_exports.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      let permutedX = x;
      if (permutedAxes != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = backend_util_exports.getInnerMostAxes(axes.length, x.shape.length);
      }
      backend_util_exports.assertAxesAreInnerMostDims("min", axes, xRank);
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = util_exports.sizeFromShape(reduceShape);
      const a2D = reshape2({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
      const reduced = reduce(a2D, a2D.dtype, "min", backend);
      let res;
      if (keepDims) {
        const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
      } else {
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
      }
      backend.disposeIntermediateTensorInfo(a2D);
      backend.disposeIntermediateTensorInfo(reduced);
      if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
      }
      return res;
    }
    var minConfig = {
      kernelName: Min,
      backendName: "webgl",
      kernelFunc: min
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Minimum.js
    var MINIMUM = CHECK_NAN_SNIPPET2 + `
    return min(a, b);
  `;
    var MINIMUM_PACKED = `
    vec4 result = vec4(min(a, b));
    vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
    ` + CHECK_NAN_SNIPPET3 + `
    return result;
  `;
    var minimum2 = binaryKernelFunc2({
      opSnippet: MINIMUM,
      packedOpSnippet: MINIMUM_PACKED,
      cpuKernelImpl: minimumImplCPU
    });
    var minimumConfig = {
      kernelName: Minimum,
      backendName: "webgl",
      kernelFunc: minimum2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/mirror_pad_gpu.js
    var MirrorPadProgram = class {
      constructor(xShape, paddings, mode) {
        this.variableNames = ["x"];
        this.outputShape = paddings.map((p, i) => p[0] + xShape[i] + p[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p) => p[0]).join(",");
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
        const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
        const offset = mode === "reflect" ? 0 : 1;
        if (rank === 1) {
          this.userCode = `
          int start = ${start};
          int end = ${end};
  
          void main() {
            int outC = getOutputCoords();
            if (outC < start) {
              outC = start * 2 - outC - ${offset};
            } else if(outC >= end) {
              outC = (end - 1) * 2 - outC + ${offset};
            }
            setOutput(getX(outC - start));
          }
        `;
          return;
        }
        this.userCode = `
        ${dtype} start = ${dtype}(${start});
        ${dtype} end = ${dtype}(${end});
  
        void main() {
          ${dtype} outC = getOutputCoords();
          for (int i = 0; i < ${rank}; i++) {
            if (outC[i] < start[i]) {
              outC[i] = start[i] * 2 - outC[i] - ${offset};
            } else if(outC[i] >= end[i]) {
              outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
            }
          }
          ${dtype} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js
    var MirrorPadPackedProgram = class {
      constructor(xShape, paddings, mode) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p, i) => p[0] + xShape[i] + p[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p) => p[0]).join(",");
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
        const coords2 = getChannels("rc", rank);
        const source = getChannels("source", rank);
        const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
        const offset = mode === "reflect" ? 0 : 1;
        let mainLoop = "";
        if (rank === 1) {
          const padSetup = `
          ${dtype} source = rc;
          if (source < start) {
            source = start * 2 - source - ${offset};
          } else if (source >= end) {
            source = (end - 1) * 2 - source + ${offset};
          }
          source -= start;
        `;
          mainLoop = `
          ${dtype} rc = outputLoc;
          ${padSetup}
          result[0] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[1] = getChannel(getX(${source.join()}), ${innerDims});
          }
        `;
        } else {
          const padSetup = `
          ${dtype} source = rc;
          ${dtype} lt = ${dtype}(lessThan(source, start));
          ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
          ${dtype} orig = 1 - (lt + gte);
          source = orig * source +
                  lt * (start * 2 - source - ${offset}) +
                  gte * ((end - 1) * 2 - source + ${offset});
          source -= start;
        `;
          mainLoop = `
          ${dtype} rc = outputLoc;
          ${padSetup}
          result[0] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[1] = getChannel(getX(${source.join()}), ${innerDims});
          }
          rc = outputLoc;
          ${coords2[rank - 2]} += 1;
          if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
            ${padSetup}
            result[2] = getChannel(getX(${source.join()}), ${innerDims});
            ${coords2[rank - 1]} += 1;
            if(${cLimit}) {
              ${padSetup}
              result[3] = getChannel(getX(${source.join()}), ${innerDims});
            }
          }
        `;
        }
        this.userCode = `
        const ${dtype} start = ${dtype}(${start});
        const ${dtype} end = ${dtype}(${end});
  
        void main() {
          ${dtype} outputLoc = getOutputCoords();
          vec4 result = vec4(0.);
          ${mainLoop}
          setOutput(result);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/MirrorPad.js
    var mirrorPadKernelFunc = ({ inputs, backend, attrs }) => {
      const { x } = inputs;
      const { paddings, mode } = attrs;
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x.shape, paddings, mode) : new MirrorPadProgram(x.shape, paddings, mode);
      const output = backend.runWebGLProgram(program, [x], x.dtype);
      return output;
    };
    var mirrorPadConfig = {
      kernelName: MirrorPad,
      backendName: "webgl",
      kernelFunc: mirrorPadKernelFunc
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Mod.js
    var MOD = `if (b == 0.0) return NAN;
    return mod(a, b);`;
    var MOD_PACKED = `
    vec4 result = mod(a, b);
    vec4 isNaN = vec4(equal(b, vec4(0.0)));
    ` + CHECK_NAN_SNIPPET3 + `
    return result;
  `;
    var mod = binaryKernelFunc2({
      opSnippet: MOD,
      packedOpSnippet: MOD_PACKED
    });
    var modConfig = {
      kernelName: Mod,
      backendName: "webgl",
      kernelFunc: mod
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/multinomial_gpu.js
    var MultinomialProgram = class {
      constructor(batchSize, numOutcomes, numSamples) {
        this.variableNames = ["probs"];
        this.outputShape = [batchSize, numSamples];
        this.userCode = `
        uniform float seed;
  
        void main() {
          ivec2 coords = getOutputCoords();
          int batch = coords[0];
  
          float r = random(seed);
          float cdf = 0.0;
  
          for (int i = 0; i < ${numOutcomes - 1}; i++) {
            cdf += getProbs(batch, i);
  
            if (r < cdf) {
              setOutput(float(i));
              return;
            }
          }
  
          // If no other event happened, last event happened.
          setOutput(float(${numOutcomes - 1}));
        }
      `;
      }
      getCustomSetupFunc(seed) {
        return (gpgpu, webGLProgram) => {
          if (this.seedLoc == null) {
            this.seedLoc = gpgpu.getUniformLocation(webGLProgram, "seed");
          }
          gpgpu.gl.uniform1f(this.seedLoc, seed);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/RealDiv.js
    var DIV = `
  if (a == b) {
    return 1.0;
  };
  return a / b;`;
    var DIV_PACKED = `
    // vec4 one = vec4(equal(a, b));
    // return one + (vec4(1.0) - one) * a / b;
    vec4 result = a / b;
    if(a.x == b.x) {
      result.x = 1.;
    }
    if(a.y == b.y) {
      result.y = 1.;
    }
    if(a.z == b.z) {
      result.z = 1.;
    }
    if(a.w == b.w) {
      result.w = 1.;
    }
  
    return result;
  `;
    var realDiv = binaryKernelFunc2({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
    var realDivConfig = {
      kernelName: RealDiv,
      backendName: "webgl",
      kernelFunc: realDiv
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sub.js
    var SUB = "return a - b;";
    var sub2 = binaryKernelFunc2({
      opSnippet: SUB,
      packedOpSnippet: SUB,
      supportsComplex: true,
      cpuKernelImpl: subImplCPU
    });
    var subConfig = {
      kernelName: Sub,
      backendName: "webgl",
      kernelFunc: sub2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Softmax.js
    function softmax(args) {
      const { inputs, backend, attrs } = args;
      const { logits } = inputs;
      const { dim } = attrs;
      const axes = util_exports.parseAxisParam([dim], logits.shape);
      const maxLogit = max({
        inputs: { x: logits },
        backend,
        attrs: { reductionIndices: axes, keepDims: false }
      });
      const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
      const maxLogitsReshaped = reshape2({ inputs: { x: maxLogit }, backend, attrs: { shape: expandedShape } });
      const a = sub2({ inputs: { a: logits, b: maxLogitsReshaped }, backend });
      const b = exp2({ inputs: { x: a }, backend });
      const sumExp = sum3({ inputs: { x: b }, backend, attrs: { axis: axes, keepDims: false } });
      const sumExpReshaped = reshape2({ inputs: { x: sumExp }, backend, attrs: { shape: expandedShape } });
      const res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend });
      backend.disposeIntermediateTensorInfo(maxLogit);
      backend.disposeIntermediateTensorInfo(maxLogitsReshaped);
      backend.disposeIntermediateTensorInfo(a);
      backend.disposeIntermediateTensorInfo(b);
      backend.disposeIntermediateTensorInfo(sumExp);
      backend.disposeIntermediateTensorInfo(sumExpReshaped);
      return res;
    }
    var softmaxConfig = {
      kernelName: Softmax,
      backendName: "webgl",
      kernelFunc: softmax
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Multinomial.js
    function multinomial(args) {
      const { inputs, backend, attrs } = args;
      const { logits } = inputs;
      const { numSamples, seed, normalized } = attrs;
      const probs = normalized ? logits : softmax({ inputs: { logits }, backend, attrs: { dim: logits.shape.length - 1 } });
      const batchSize = probs.shape[0];
      const numOutcomes = probs.shape[1];
      const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
      const customSetup = program.getCustomSetupFunc(seed);
      const res = backend.runWebGLProgram(program, [probs], "int32", customSetup);
      if (!normalized) {
        backend.disposeIntermediateTensorInfo(probs);
      }
      return res;
    }
    var multinomialConfig = {
      kernelName: Multinomial,
      backendName: "webgl",
      kernelFunc: multinomial
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Neg.js
    var NEG = `return -x;`;
    function neg(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      if (backend.shouldExecuteOnCPU([x])) {
        const xData = backend.texData.get(x.dataId);
        const [outValues, newShape] = negImplCPU(xData.values, x.shape, x.dtype);
        return backend.makeTensorInfo(newShape, x.dtype, outValues);
      }
      let program;
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        program = new UnaryOpPackedProgram(x.shape, NEG);
      } else {
        program = new UnaryOpProgram(x.shape, NEG);
      }
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
    var negConfig = {
      kernelName: Neg,
      backendName: "webgl",
      kernelFunc: neg
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js
    var nonMaxSuppressionV3Impl2 = kernel_impls_exports.nonMaxSuppressionV3Impl;
    function nonMaxSuppressionV3(args) {
      backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      const { inputs, backend, attrs } = args;
      const { boxes, scores } = inputs;
      const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
      const boxesVals = backend.readSync(boxes.dataId);
      const scoresVals = backend.readSync(scores.dataId);
      const { selectedIndices } = nonMaxSuppressionV3Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
      return backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
    }
    var nonMaxSuppressionV3Config = {
      kernelName: NonMaxSuppressionV3,
      backendName: "webgl",
      kernelFunc: nonMaxSuppressionV3
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js
    var nonMaxSuppressionV4Impl2 = kernel_impls_exports.nonMaxSuppressionV4Impl;
    function nonMaxSuppressionV4(args) {
      backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      const { inputs, backend, attrs } = args;
      const { boxes, scores } = inputs;
      const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
      const boxesVals = backend.readSync(boxes.dataId);
      const scoresVals = backend.readSync(scores.dataId);
      const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
      return [
        backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
        backend.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
      ];
    }
    var nonMaxSuppressionV4Config = {
      kernelName: NonMaxSuppressionV4,
      backendName: "webgl",
      kernelFunc: nonMaxSuppressionV4
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js
    var nonMaxSuppressionV5Impl2 = kernel_impls_exports.nonMaxSuppressionV5Impl;
    function nonMaxSuppressionV5(args) {
      backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      const { inputs, backend, attrs } = args;
      const { boxes, scores } = inputs;
      const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
      const boxesVals = backend.readSync(boxes.dataId);
      const scoresVals = backend.readSync(scores.dataId);
      const maxOutputSizeVal = maxOutputSize;
      const iouThresholdVal = iouThreshold;
      const scoreThresholdVal = scoreThreshold;
      const softNmsSigmaVal = softNmsSigma;
      const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
      return [
        backend.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
        backend.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
      ];
    }
    var nonMaxSuppressionV5Config = {
      kernelName: NonMaxSuppressionV5,
      backendName: "webgl",
      kernelFunc: nonMaxSuppressionV5
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/onehot_gpu.js
    var OneHotProgram = class {
      constructor(numIndices, depth, onValue, offValue) {
        this.variableNames = ["indices"];
        this.outputShape = [numIndices, depth];
        this.userCode = `
        void main() {
          ivec2 coords = getOutputCoords();
          int index = round(getIndices(coords.x));
          setOutput(mix(float(${offValue}), float(${onValue}),
                        float(index == coords.y)));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/OneHot.js
    var oneHot = (args) => {
      const { inputs, backend, attrs } = args;
      const { indices } = inputs;
      const { depth, onValue, offValue } = attrs;
      const indicesSize = util_exports.sizeFromShape(indices.shape);
      const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
      const reshaped = reshape2({ inputs: { x: indices }, backend, attrs: { shape: [indicesSize] } });
      const result2 = backend.runWebGLProgram(program, [reshaped], indices.dtype);
      backend.disposeIntermediateTensorInfo(reshaped);
      const outShape = [...indices.shape, depth];
      const out = reshape2({ inputs: { x: result2 }, backend, attrs: { shape: outShape } });
      backend.disposeIntermediateTensorInfo(result2);
      return out;
    };
    var oneHotConfig = {
      kernelName: OneHot,
      backendName: "webgl",
      kernelFunc: oneHot
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ZerosLike.js
    function zerosLike(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      if (x.dtype === "complex64") {
        const realPart = real2({ inputs: { input: x }, backend });
        const r = zerosLike({ inputs: { x: realPart }, backend });
        const imagPart = imag({ inputs: { input: x }, backend });
        const i = zerosLike({ inputs: { x: imagPart }, backend });
        const result2 = complex3({ inputs: { real: r, imag: i }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result2;
      } else {
        return fill({
          attrs: {
            shape: x.shape,
            dtype: x.dtype,
            value: x.dtype === "string" ? "" : 0
          },
          backend
        });
      }
    }
    var zerosLikeConfig = {
      kernelName: ZerosLike,
      backendName: "webgl",
      kernelFunc: zerosLike
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/OnesLike.js
    function onesLike(args) {
      const { inputs, backend } = args;
      const { x } = inputs;
      if (x.dtype === "string") {
        throw new Error("onesLike is not supported under string dtype");
      } else if (x.dtype === "complex64") {
        const realPart = real2({ inputs: { input: x }, backend });
        const r = onesLike({ inputs: { x: realPart }, backend });
        const imagPart = imag({ inputs: { input: x }, backend });
        const i = zerosLike({ inputs: { x: imagPart }, backend });
        const result2 = complex3({ inputs: { real: r, imag: i }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result2;
      } else {
        return fill({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend });
      }
    }
    var onesLikeConfig = {
      kernelName: OnesLike,
      backendName: "webgl",
      kernelFunc: onesLike
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Pack.js
    function pack(args) {
      const { inputs, backend, attrs } = args;
      const { axis } = attrs;
      if (inputs.length === 1) {
        return expandDims({ inputs: { input: inputs[0] }, backend, attrs: { dim: axis } });
      }
      const shape = inputs[0].shape;
      const dtype = inputs[0].dtype;
      inputs.forEach((t) => {
        util_exports.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
        util_exports.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
      });
      const intermediateTensorInfos = [];
      const expandedTensors = inputs.map((t) => {
        const expandedT = expandDims({ inputs: { input: t }, backend, attrs: { dim: axis } });
        intermediateTensorInfos.push(expandedT);
        return expandedT;
      });
      const result2 = concat({ inputs: expandedTensors, backend, attrs: { axis } });
      intermediateTensorInfos.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return result2;
    }
    var packConfig = {
      kernelName: Pack,
      backendName: "webgl",
      kernelFunc: pack
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/pad_gpu.js
    var PadProgram = class {
      constructor(xShape, paddings, constantValue) {
        this.variableNames = ["x"];
        this.outputShape = paddings.map((p, i) => p[0] + xShape[i] + p[1]);
        const rank = xShape.length;
        const type = getCoordsDataType(rank);
        const start = paddings.map((p) => p[0]).join(",");
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
        const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
        if (rank === 1) {
          this.userCode = `
          int start = ${start};
          int end = ${end};
          uniform float value;
  
          void main() {
            int outC = getOutputCoords();
            if (outC < start || outC >= end) {
              setOutput(value);
            } else {
              setOutput(getX(outC - start));
            }
          }
        `;
          return;
        }
        this.userCode = `
        ${type} start = ${type}(${start});
        ${type} end = ${type}(${end});
        uniform float value;
  
        void main() {
          ${type} outC = getOutputCoords();
          if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
            setOutput(value);
          } else {
            ${type} coords = outC - start;
            setOutput(getX(${unpackedCoords}));
          }
        }
      `;
      }
      getCustomSetupFunc(value) {
        return (gpgpu, webGLProgram) => {
          if (this.valueLoc == null) {
            this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "value");
          }
          gpgpu.gl.uniform1f(this.valueLoc, value);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/pad_packed_gpu.js
    var PadPackedProgram = class {
      constructor(xShape, paddings, constantValue) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p, i) => p[0] + xShape[i] + p[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p) => p[0]).join(",");
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(",");
        const coords2 = getChannels("rc", rank);
        const source = getChannels("source", rank);
        const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
        const componentSetup = [
          `${dtype} rc = outputLoc;`,
          `${coords2[rank - 1]} += 1;
         if(${cLimit}) {
        `,
          rank === 1 ? "" : `}
         rc = outputLoc;
         ${coords2[rank - 2]} += 1;
         if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
          rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
           if(${cLimit}) {`
        ];
        const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
        let mainLoop = "";
        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {
          mainLoop += `
          ${componentSetup[i]}
          if (${paddingArea}) {
            result[${i}] = float(value);
          } else {
            ${dtype} source = rc - start;
            result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
          }
        `;
        }
        mainLoop += rank === 1 ? `} ` : `}}`;
        this.userCode = `
        const ${dtype} start = ${dtype}(${start});
        const ${dtype} end = ${dtype}(${end});
        uniform float value;
  
        void main() {
          ${dtype} outputLoc = getOutputCoords();
          vec4 result = vec4(0.);
          ${mainLoop}
          setOutput(result);
        }
      `;
      }
      getCustomSetupFunc(value) {
        return (gpgpu, webGLProgram) => {
          if (this.valueLoc == null) {
            this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "value");
          }
          gpgpu.gl.uniform1f(this.valueLoc, value);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/PadV2.js
    var padV2 = (args) => {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { paddings, constantValue } = attrs;
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x.shape, paddings, constantValue) : new PadProgram(x.shape, paddings, constantValue);
      const customSetup = program.getCustomSetupFunc(constantValue);
      return backend.runWebGLProgram(program, [x], x.dtype, customSetup);
    };
    var padV2Config = {
      kernelName: PadV2,
      backendName: "webgl",
      kernelFunc: padV2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Pow.js
    var POW = `
    if(a < 0.0 && floor(b) < b){
      return NAN;
    }
    if (b == 0.0) {
      return 1.0;
    }
    return (round(mod(b, 2.0)) != 1) ?
        pow(abs(a), b) : sign(a) * pow(abs(a), b);
  `;
    var POW_PACKED = `
    // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
    vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
    vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
    vec4 result = multiplier * pow(abs(a), b);
  
    // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
    bvec4 isExpZero = equal(b, vec4(0.0));
    result.r = isExpZero.r ? 1.0 : result.r;
    result.g = isExpZero.g ? 1.0 : result.g;
    result.b = isExpZero.b ? 1.0 : result.b;
    result.a = isExpZero.a ? 1.0 : result.a;
  
    vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
    ` + CHECK_NAN_SNIPPET3 + `
    return result;
  `;
    var pow = binaryKernelFunc2({ opSnippet: POW, packedOpSnippet: POW_PACKED });
    var powConfig = {
      kernelName: Pow,
      backendName: "webgl",
      kernelFunc: pow
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Prod.js
    function prod(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { axis, keepDims } = attrs;
      const xRank = x.shape.length;
      const toDispose = [];
      const origAxes = util_exports.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      let permutedX = x;
      if (permutedAxes != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
        toDispose.push(permutedX);
      }
      backend_util_exports.assertAxesAreInnerMostDims("prod", axes, xRank);
      let res;
      if (backend.shouldExecuteOnCPU([permutedX])) {
        const xVals = backend.texData.get(permutedX.dataId).values;
        const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
        res = backend.makeTensorInfo(outShape, outDtype, outVals);
      } else {
        const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
        const inSize = util_exports.sizeFromShape(reduceShape);
        const a2D = reshape2({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
        const outputDType = sumOutType(x.dtype);
        const reduced = reduce(a2D, outputDType, "prod", backend);
        res = reshape2({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
        toDispose.push(a2D);
        toDispose.push(reduced);
      }
      if (keepDims) {
        toDispose.push(res);
        const newShape = backend_util_exports.expandShapeToKeepDim(res.shape, origAxes);
        res = reshape2({ inputs: { x: res }, backend, attrs: { shape: newShape } });
      }
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return res;
    }
    var prodConfig = {
      kernelName: Prod,
      backendName: "webgl",
      kernelFunc: prod
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Range.js
    var range = (args) => {
      const { backend, attrs } = args;
      const { start, stop, step: step3, dtype } = attrs;
      const values = rangeImplCPU(start, stop, step3, dtype);
      return backend.makeTensorInfo([values.length], dtype, values);
    };
    var rangeConfig = {
      kernelName: Range,
      backendName: "webgl",
      kernelFunc: range
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Reciprocal.js
    var RECIPROCAL = `return 1.0 / x;`;
    var reciprocal = unaryKernelFunc({ opSnippet: RECIPROCAL });
    var reciprocalConfig = {
      kernelName: Reciprocal,
      backendName: "webgl",
      kernelFunc: reciprocal
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Relu.js
    var RELU3 = CHECK_NAN_SNIPPET + `
    return (x < 0.0) ? 0.0 : x;
  `;
    var RELU_PACKED = `
    vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
    bvec4 isNaN = isnan(x);
  
    result.r = isNaN.r ? x.r : result.r;
    result.g = isNaN.g ? x.g : result.g;
    result.b = isNaN.b ? x.b : result.b;
    result.a = isNaN.a ? x.a : result.a;
  
    return result;
  `;
    var relu2 = unaryKernelFunc({ opSnippet: RELU3, packedOpSnippet: RELU_PACKED });
    var reluConfig = {
      kernelName: Relu,
      backendName: "webgl",
      kernelFunc: relu2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Relu6.js
    var RELU63 = CHECK_NAN_SNIPPET + `
    return (x < 0.0) ? 0.0 : min(6.0, x);
  `;
    var RELU6_PACKED = `
    vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
    bvec4 isNaN = isnan(x);
  
    result.r = isNaN.r ? x.r : result.r;
    result.g = isNaN.g ? x.g : result.g;
    result.b = isNaN.b ? x.b : result.b;
    result.a = isNaN.a ? x.a : result.a;
  
    return result;
  `;
    var relu62 = unaryKernelFunc({ opSnippet: RELU63, packedOpSnippet: RELU6_PACKED });
    var relu6Config = {
      kernelName: Relu6,
      backendName: "webgl",
      kernelFunc: relu62
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_bilinear_gpu.js
    var ResizeBilinearProgram = class {
      constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ["A"];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) {
          sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`;
        } else {
          sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
        const vec2 effectiveInputOverOutputRatioRC = vec2(
            ${effectiveInSize[0] / effectiveOutSize[0]},
            ${effectiveInSize[1] / effectiveOutSize[1]});
        const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          ivec2 yRC = coords.yz;
  
          // Fractional source index.
          vec2 sourceFracIndexRC = ${sourceFracIndexRC};
  
          // Compute the four integer indices.
          ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
          ivec2 sourceCeilRC = ivec2(
            min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));
  
          float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
          float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
          float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
          float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);
  
          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);
  
          float top = topLeft + (topRight - topLeft) * fracRC.y;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          float newValue = top + (bottom - top) * fracRC.x;
  
          setOutput(newValue);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js
    var ResizeBilinearPackedProgram = class {
      constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) {
          sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`;
        } else {
          sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
        const vec3 effectiveInputOverOutputRatioRC = vec3(
            ${effectiveInSize[0] / effectiveOutSize[0]},
            ${effectiveInSize[1] / effectiveOutSize[1]},
            ${effectiveInSize[1] / effectiveOutSize[1]});
        const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                       ${oldWidth}.0);
  
        float getAValue(int b, int r, int c, int d) {
          return getChannel(getA(b, r, c, d), vec2(c, d));
        }
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          // Calculate values for next column in yRC.z.
          ivec3 yRC = coords.yzz + ivec3(0, 0, 1);
  
          // Fractional source index.
          vec3 sourceFracIndexRC = ${sourceFracIndexRC};
  
          // Compute the four integer indices.
          ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
          ivec3 sourceCeilRC = ivec3(
            min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));
  
          // Should we calculate next column and row elements in 2x2 packed cell.
          bool hasNextCol = d < ${depth - 1};
          bool hasNextRow = coords.z < ${newWidth - 1};
  
          // In parallel, construct four corners for all four components in
          // packed 2x2 cell.
          vec4 topLeft = vec4(
            getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
            hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                       : 0.0,
            hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                       : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);
  
          vec4 bottomLeft = vec4(
            getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
            hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                       : 0.0,
            hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                       : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);
  
          vec4 topRight = vec4(
            getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
            hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                       : 0.0,
            hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                       : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);
  
          vec4 bottomRight = vec4(
            getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
            hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                       : 0.0,
            hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                       : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);
  
          vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);
  
          vec4 top = mix(topLeft, topRight, fracRC.yyzz);
          vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
          vec4 newValue = mix(top, bottom, fracRC.x);
  
          setOutput(newValue);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js
    function resizeBilinear(args) {
      const { inputs, backend, attrs } = args;
      const { images } = inputs;
      const { alignCorners, halfPixelCenters, size } = attrs;
      const [newHeight, newWidth] = size;
      const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
      return backend.runWebGLProgram(program, [images], "float32");
    }
    var resizeBilinearConfig = {
      kernelName: ResizeBilinear,
      backendName: "webgl",
      kernelFunc: resizeBilinear
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js
    var ResizeBilinearBackpropProgram = class {
      constructor(dyShape, inputShape, alignCorners) {
        this.variableNames = ["dy"];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          int r = coords[1];
          int c = coords[2];
  
          float accumulator = 0.0;
  
          const float heightScale = float(${heightScale});
          const float widthScale = float(${widthScale});
  
          const float invHeightScale = float(${invHeightScale});
          const float invWidthScale = float(${invWidthScale});
  
          const int winHeight = int(${winHeight});
          const int winWidth = int(${winWidth});
  
          // Compute bounds for where in dy we will look
          float startRLerp = floor(float(r) * invHeightScale);
          int startDyR = int(startRLerp - float(winHeight / 2));
  
          float startCLerp = floor(float(c) * invWidthScale);
          int startDyC = int(startCLerp - float(winWidth / 2));
  
          // Loop over dy
          for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
            int dyR = dyROffset + startDyR;
  
            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= ${yHeight}) {
              continue;
            }
  
            for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
              int dyC = dyCOffset + startDyC;
  
              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= ${yWidth}) {
                continue;
              }
  
              float dxR = float(dyR) * heightScale;
              int topDxRIndex = int(floor(dxR));
              int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
              float dxRLerp = dxR - float(topDxRIndex);
              float inverseDxRLerp = 1.0 - dxRLerp;
  
              float dxC = float(dyC) * widthScale;
              int leftDxCIndex = int(floor(dxC));
              int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
              float dxCLerp = dxC - float(leftDxCIndex);
              float inverseDxCLerp = 1.0 - dxCLerp;
  
              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }
  
              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }
  
              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }
  
              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy
  
          setOutput(accumulator);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js
    function resizeBilinearGrad(args) {
      const { inputs, backend, attrs } = args;
      const { images, dy } = inputs;
      const { alignCorners } = attrs;
      const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
      return backend.runWebGLProgram(program, [dy], dy.dtype);
    }
    var resizeBilinearGradConfig = {
      kernelName: ResizeBilinearGrad,
      backendName: "webgl",
      kernelFunc: resizeBilinearGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js
    var ResizeNearestNeighborProgram = class {
      constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ["A"];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        const roundBase = alignCorners ? "0.5" : "0.0";
        let sourceFracIndexRC;
        if (halfPixelCenters) {
          sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`;
        } else {
          sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
        const vec2 effectiveInputOverOutputRatioRC = vec2(
            ${effectiveInSize[0] / effectiveOutSize[0]},
            ${effectiveInSize[1] / effectiveOutSize[1]});
        const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          ivec2 yRC = coords.yz;
  
          // Fractional source index.
          vec2 sourceFracIndexRC = ${sourceFracIndexRC};
  
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestRC = ivec2(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
          float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);
  
          setOutput(newValue);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js
    var ResizeNearestNeighborPackedProgram = class {
      constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        const roundBase = alignCorners ? "0.5" : "0.0";
        let sourceFracIndexRC;
        if (halfPixelCenters) {
          sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`;
        } else {
          sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
        const vec3 effectiveInputOverOutputRatioRC = vec3(
            ${effectiveInSize[0] / effectiveOutSize[0]},
            ${effectiveInSize[1] / effectiveOutSize[1]},
            ${effectiveInSize[1] / effectiveOutSize[1]});
        const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                       ${oldWidth}.0);
  
        float getAValue(int b, int r, int c, int d) {
          return getChannel(getA(b, r, c, d), vec2(c, d));
        }
  
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          // Calculate values for next column in yRC.z.
          ivec3 yRC = coords.yzz + ivec3(0, 0, 1);
  
          // Fractional source index.
          vec3 sourceFracIndexRC = ${sourceFracIndexRC};
  
          // Compute the coordinators of nearest neighbor point.
          ivec3 sourceNearestRC = ivec3(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
  
          // Should we calculate next column and row elements in 2x2 packed cell.
          bool hasNextCol = d < ${depth - 1};
          bool hasNextRow = coords.z < ${newWidth - 1};
  
          vec4 newValue = vec4(
            getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
            hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                       : 0.0,
            hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                       : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);
  
          setOutput(newValue);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js
    function resizeNearestNeighbor(args) {
      const { inputs, backend, attrs } = args;
      const { images } = inputs;
      const { alignCorners, halfPixelCenters, size } = attrs;
      const [newHeight, newWidth] = size;
      const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
      return backend.runWebGLProgram(program, [images], images.dtype);
    }
    var resizeNearestNeighborConfig = {
      kernelName: ResizeNearestNeighbor,
      backendName: "webgl",
      kernelFunc: resizeNearestNeighbor
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js
    var ResizeNearestNeigborBackpropProgram = class {
      constructor(dyShape, inputShape, alignCorners) {
        this.variableNames = ["dy"];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int b = coords[0];
          int d = coords[3];
          int r = coords[1];
          int c = coords[2];
  
          float accumulator = 0.0;
  
          const float heightScale = float(${heightScale});
          const float widthScale = float(${widthScale});
  
          const float invHeightScale = float(${invHeightScale});
          const float invWidthScale = float(${invWidthScale});
  
          const int winHeight = int(${winHeight});
          const int winWidth = int(${winWidth});
  
          // Compute bounds for where in dy we will look
          float startRLerp = floor(float(r) * invHeightScale);
          int startDyR = int(floor(startRLerp - float(winHeight / 2)));
  
          float startCLerp = floor(float(c) * invWidthScale);
          int startDyC = int(floor(startCLerp - float(winWidth / 2)));
  
          // Loop over dy
          for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
            int dyR = dyROffset + startDyR;
  
            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= ${yHeight}) {
              continue;
            }
  
            for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
              int dyC = dyCOffset + startDyC;
  
              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= ${yWidth}) {
                continue;
              }
  
              float sourceFracRow =
                float(${effectiveXSize[0]}) *
                  (float(dyR) / float(${effectiveYSize[0]}));
  
              float sourceFracCol =
                  float(${effectiveXSize[1]}) *
                    (float(dyC) / float(${effectiveYSize[1]}));
  
              int sourceNearestRow = int(min(
                  float(int(${xHeight}) - 1),
                  ${alignCorners} ? float(round(sourceFracRow)) :
                                    float(floor(sourceFracRow))));
  
              int sourceNearestCol = int(min(
                  float(int(${xWidth}) - 1),
                  ${alignCorners} ? float(round(sourceFracCol)) :
                                    float(floor(sourceFracCol))));
  
              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy
  
          setOutput(accumulator);
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js
    function resizeNearestNeighborGrad(args) {
      const { inputs, backend, attrs } = args;
      const { images, dy } = inputs;
      const { alignCorners } = attrs;
      const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
      return backend.runWebGLProgram(program, [dy], dy.dtype);
    }
    var resizeNearestNeighborGradConfig = {
      kernelName: ResizeNearestNeighborGrad,
      backendName: "webgl",
      kernelFunc: resizeNearestNeighborGrad
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/reverse_gpu.js
    var ReverseProgram = class {
      constructor(xShape, axis) {
        this.variableNames = ["x"];
        const rank = xShape.length;
        if (rank > 4) {
          throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        if (rank === 1) {
          this.userCode = `
          void main() {
            int coord = getOutputCoords();
            setOutput(getX(${xShape[0]} - coord - 1));
          }
        `;
          return;
        }
        const getInCoord = (i) => {
          if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
            return `${xShape[i]} - coords[${i}] - 1`;
          }
          return `coords[${i}]`;
        };
        const inCoords = xShape.map((_, i) => getInCoord(i)).join(",");
        const type = getCoordsDataType(rank);
        this.userCode = `
        void main() {
          ${type} coords = getOutputCoords();
          setOutput(getX(${inCoords}));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/reverse_packed_gpu.js
    var ReversePackedProgram = class {
      constructor(xShape, axis) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        const rank = xShape.length;
        if (rank > 4) {
          throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        const channels = getChannels("rc", rank);
        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
        const type = getCoordsDataType(rank);
        if (rank === 1) {
          this.userCode = `
          void main(){
            int rc = getOutputCoords();
            vec4 result = vec4(0.);
            result.r = getChannel(getX(${xShape[0]} - rc - 1),
              ${xShape[0]} - rc - 1);
            if(${nextColumn}){
                result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                  ${xShape[0]} - (rc  + 1) - 1);
            }
            setOutput(result);
          }
        `;
        } else {
          this.userCode = `
          void main() {
            ${type} rc = getOutputCoords();
            vec4 result = vec4(0.);
            result.r = ${getR(channels.slice())};
            if(${nextColumn}){
              result.g = ${getG(channels.slice())};
            }
            if(${nextRow}) {
              result.b = ${getB(channels.slice())};
              if(${nextColumn}) {
                result.a = ${getA(channels.slice())};
              }
            }
            setOutput(result);
          }
      `;
        }
        function getR(channels2) {
          return getChannel(channels2);
        }
        function getG(channels2) {
          channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
          return getChannel(channels2);
        }
        function getB(channels2) {
          channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
          return getChannel(channels2);
        }
        function getA(channels2) {
          channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
          channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
          return getChannel(channels2);
        }
        function getChannel(channels2) {
          const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels2));
          const inCoords = inCoordsArray.join(",");
          const innerDims = inCoordsArray.slice(-2).join(",");
          return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
        }
        function getInCoord(i, channels1) {
          if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
            return `${xShape[i]} - ${channels1[i]} - 1`;
          } else {
            return `${channels1[i]}`;
          }
        }
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Reverse.js
    function reverse(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { dims } = attrs;
      const xRank = x.shape.length;
      const $dims = util_exports.parseAxisParam(dims, x.shape);
      if (xRank === 0) {
        return identity2({ inputs: { x }, backend });
      }
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x.shape, $dims) : new ReverseProgram(x.shape, $dims);
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
    var reverseConfig = {
      kernelName: Reverse,
      backendName: "webgl",
      kernelFunc: reverse
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/rotate_gpu.js
    var RotateProgram = class {
      constructor(imageShape, fillValue) {
        this.variableNames = ["Image"];
        this.outputShape = [];
        const imageHeight = imageShape[1];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        let fillSnippet = "";
        if (typeof fillValue === "number") {
          fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
        } else {
          fillSnippet = `
          vec3 fill = vec3(${fillValue.join(",")});
          float outputValue = fill[coords[3]];`;
        }
        this.userCode = `
          uniform vec4 params;
          void main() {
            ivec4 coords = getOutputCoords();
            int x = coords[2];
            int y = coords[1];
            float coordXFloat = (float(x) - params[0]) * params[3] -
              (float(y) - params[1]) * params[2];
            float coordYFloat = (float(x) - params[0]) * params[2] +
              (float(y) - params[1]) * params[3];
            int coordX = int(round(coordXFloat + params[0]));
            int coordY = int(round(coordYFloat + params[1]));
            ${fillSnippet}
            if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
              outputValue = getImage(coords[0], coordY, coordX, coords[3]);
            }
            setOutput(outputValue);
          }
      `;
      }
      getCustomSetupFunc(centerX, centerY, sinFactor, cosFactor) {
        return (gpgpu, webGLProgram) => {
          if (this.paramsLoc == null) {
            this.paramsLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "params");
          }
          gpgpu.gl.uniform4f(this.paramsLoc, centerX, centerY, sinFactor, cosFactor);
        };
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js
    var rotateWithOffsetConfig = {
      kernelName: RotateWithOffset,
      backendName: "webgl",
      kernelFunc: ({ inputs, attrs, backend }) => {
        const { image: image2 } = inputs;
        const { radians, fillValue, center } = attrs;
        const webglBackend = backend;
        const program = new RotateProgram(image2.shape, fillValue);
        const [centerX, centerY] = backend_util_exports.getImageCenter(center, image2.shape[1], image2.shape[2]);
        const customSetup = program.getCustomSetupFunc(centerX, centerY, Math.sin(radians), Math.cos(radians));
        const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype, customSetup);
        return output;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Round.js
    var ROUND = `
    // OpenGL ES does not support round function.
    // The algorithm is based on banker's rounding.
    float base = floor(x);
    if ((x - base) < 0.5) {
      return floor(x);
    } else if ((x - base) > 0.5) {
      return ceil(x);
    } else {
      if (mod(base, 2.0) == 0.0) {
        return base;
      } else {
        return base + 1.0;
      }
    }
  `;
    var round2 = unaryKernelFunc({ opSnippet: ROUND });
    var roundConfig = {
      kernelName: Round,
      backendName: "webgl",
      kernelFunc: round2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Rsqrt.js
    var RSQRT = `return inversesqrt(x);`;
    var rsqrt2 = unaryKernelFunc({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
    var rsqrtConfig = {
      kernelName: Rsqrt,
      backendName: "webgl",
      kernelFunc: rsqrt2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/scatter_gpu.js
    var ScatterProgram = class {
      constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
        this.variableNames = ["updates", "indices", "defaultValue"];
        this.outputShape = shape;
        const stridesType = getCoordsDataType(strides.length);
        const dtype = getCoordsDataType(shape.length);
        let indicesString = "";
        if (indicesRank === 1) {
          indicesString = "i";
        } else if (indicesRank === 2) {
          indicesString = "i, j";
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        let updatesString = "";
        if (updatesRank === 1) {
          updatesString = "i";
        } else if (updatesRank === 2) {
          updatesString = "i, coords[1]";
        }
        const updatesSnippet = `getUpdates(${updatesString})`;
        const strideString = sliceDim > 1 ? "strides[j]" : "strides";
        this.userCode = `
          ${stridesType} strides = ${stridesType}(${strides});
  
          void main() {
            ${dtype} coords = getOutputCoords();
            float sum = 0.0;
            bool found = false;
            for (int i = 0; i < ${updateSize}; i++) {
              int flattenedIndex = 0;
              for (int j = 0; j < ${sliceDim}; j++) {
                int index = round(${indicesSnippet});
                flattenedIndex += index * ${strideString};
              }
              if (flattenedIndex == coords[0]) {
                sum += ${updatesSnippet};
                found = true;
              }
            }
            setOutput(mix(getDefaultValue(), sum, float(found)));
          }
        `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/ScatterNd.js
    function scatterNd(args) {
      const { inputs, backend, attrs } = args;
      const { indices, updates } = inputs;
      const { shape } = attrs;
      const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(updates, indices, shape);
      const flattenShape = [outputSize / sliceSize, sliceSize];
      if (outputSize === 0) {
        return backend.makeTensorInfo(shape, indices.dtype);
      }
      const flattenIndices = reshape2({ inputs: { x: indices }, backend, attrs: { shape: [numUpdates, sliceRank] } });
      const flattenX = reshape2({ inputs: { x: updates }, backend, attrs: { shape: [numUpdates, sliceSize] } });
      const defaultValue = backend.makeTensorInfo([], "float32", new Float32Array([0]));
      const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
      const res = backend.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
      const reshaped = reshape2({ inputs: { x: res }, backend, attrs: { shape } });
      backend.disposeIntermediateTensorInfo(flattenIndices);
      backend.disposeIntermediateTensorInfo(flattenX);
      backend.disposeIntermediateTensorInfo(res);
      backend.disposeIntermediateTensorInfo(defaultValue);
      return reshaped;
    }
    var scatterNdConfig = {
      kernelName: ScatterNd,
      backendName: "webgl",
      kernelFunc: scatterNd
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/select_gpu.js
    var SelectProgram = class {
      constructor(cRank, shape, rank) {
        this.variableNames = ["c", "a", "b"];
        this.outputShape = shape;
        let cCoords;
        let abCoords;
        if (rank > 4) {
          throw Error(`Where for rank ${rank} is not yet supported`);
        }
        if (rank === 1) {
          abCoords = `resRC`;
          cCoords = `resRC`;
        } else {
          const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
          const cCoordVars = [];
          const abCoordVars = [];
          for (let i = 0; i < shape.length; i++) {
            abCoordVars.push(`${currentCoords[i]}`);
            if (i < cRank) {
              cCoordVars.push(`${currentCoords[i]}`);
            }
          }
          cCoords = cCoordVars.join();
          abCoords = abCoordVars.join();
        }
        const dtype = getCoordsDataType(rank);
        this.userCode = `
        void main() {
          ${dtype} resRC = getOutputCoords();
          float cVal = getC(${cCoords});
          if (cVal >= 1.0) {
            setOutput(getA(${abCoords}));
          } else {
            setOutput(getB(${abCoords}));
          }
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Select.js
    function select(args) {
      const { inputs, backend } = args;
      const { condition, t, e } = inputs;
      const program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);
      return backend.runWebGLProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));
    }
    var selectConfig = {
      kernelName: Select,
      backendName: "webgl",
      kernelFunc: select
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Selu.js
    var SELU = `
    // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
    // see: https://arxiv.org/abs/1706.02515
    float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};
    float scale = ${backend_util_exports.SELU_SCALE};
    return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
  `;
    var selu = unaryKernelFunc({ opSnippet: SELU });
    var seluConfig = {
      kernelName: Selu,
      backendName: "webgl",
      kernelFunc: selu
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sigmoid.js
    var SIGMOID3 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
    var sigmoid2 = unaryKernelFunc({ opSnippet: SIGMOID3 });
    var sigmoidConfig = {
      kernelName: Sigmoid,
      backendName: "webgl",
      kernelFunc: sigmoid2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sign.js
    var SIGN = `
    if (isnan(x)) { return 0.0; }
    return sign(x);
  `;
    var sign = unaryKernelFunc({ opSnippet: SIGN });
    var signConfig = {
      kernelName: Sign,
      backendName: "webgl",
      kernelFunc: sign
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sin.js
    var SIN = CHECK_NAN_SNIPPET_UNARY + `
    return sin(x);
  `;
    var sin = unaryKernelFunc({ opSnippet: SIN });
    var sinConfig = {
      kernelName: Sin,
      backendName: "webgl",
      kernelFunc: sin
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sinh.js
    var SINH = `
    float e2x = exp(x);
    return (e2x - 1.0 / e2x) / 2.0;
  `;
    var sinh = unaryKernelFunc({ opSnippet: SINH });
    var sinhConfig = {
      kernelName: Sinh,
      backendName: "webgl",
      kernelFunc: sinh
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Softplus.js
    var SOFTPLUS = `
    float epsilon = 1.1920928955078125e-7;
    float threshold = log(epsilon) + 2.0;
  
    bool too_large = x > -threshold;
    bool too_small = x < threshold;
  
    float result;
    float exp_x = exp(x);
  
    if (too_large){
      result = x;
    }
    else if (too_small){
      result = exp_x;
    }
    else{
      result = log(exp_x + 1.0);
    }
    return result;
  `;
    var softplus = unaryKernelFunc({ opSnippet: SOFTPLUS });
    var softplusConfig = {
      kernelName: Softplus,
      backendName: "webgl",
      kernelFunc: softplus
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js
    var spaceToBatchND = (args) => {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { blockShape, paddings } = attrs;
      util_exports.assert(x.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
      const prod2 = blockShape.reduce((a, b) => a * b);
      const completePaddings = [[0, 0]];
      completePaddings.push(...paddings);
      for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
        completePaddings.push([0, 0]);
      }
      const toDispose = [];
      const paddedX = padV2({
        inputs: { x },
        backend,
        attrs: { paddings: completePaddings, constantValue: 0 }
      });
      const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod2, false);
      const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
      const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod2, false);
      const reshapedPaddedX = reshape2({ inputs: { x: paddedX }, backend, attrs: { shape: reshapedPaddedShape } });
      const paddedXT = transpose({
        inputs: { x: reshapedPaddedX },
        backend,
        attrs: { perm: permutedReshapedPaddedPermutation }
      });
      const result2 = reshape2({ inputs: { x: paddedXT }, backend, attrs: { shape: flattenShape } });
      toDispose.push(paddedX);
      toDispose.push(reshapedPaddedX);
      toDispose.push(paddedXT);
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return result2;
    };
    var spaceToBatchNDConfig = {
      kernelName: SpaceToBatchND,
      backendName: "webgl",
      kernelFunc: spaceToBatchND
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js
    function sparseFillEmptyRows(args) {
      const { inputs, backend } = args;
      const { indices, values, denseShape, defaultValue } = inputs;
      if (denseShape.shape.length !== 1) {
        throw new Error(`Dense shape must be a vector, saw:
           ${denseShape.shape}`);
      }
      if (indices.shape.length !== 2) {
        throw new Error(`Indices must be a matrix, saw:
           ${indices.shape}`);
      }
      if (values.shape.length !== 1) {
        throw new Error(`Values must be a vector, saw:
           ${values.shape}`);
      }
      if (defaultValue.shape.length !== 0) {
        throw new Error(`Default value must be a scalar, saw:
          ${defaultValue.shape}`);
      }
      const $indices = backend.readSync(indices.dataId);
      const $values = backend.readSync(values.dataId);
      const $denseShape = backend.readSync(denseShape.dataId);
      const $defaultValue = backend.readSync(defaultValue.dataId)[0];
      const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
      return [
        backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
        backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
        backend.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
        backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
      ];
    }
    var sparseFillEmptyRowsConfig = {
      kernelName: SparseFillEmptyRows,
      backendName: "webgl",
      kernelFunc: sparseFillEmptyRows
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SparseReshape.js
    function sparseReshape(args) {
      const { inputs, backend } = args;
      const { inputIndices, inputShape, newShape } = inputs;
      if (inputIndices.shape.length !== 2) {
        throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
      }
      if (inputShape.shape.length !== 1) {
        throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
      }
      if (newShape.shape.length !== 1) {
        throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
      }
      const $inputShape = Array.from(backend.readSync(inputShape.dataId));
      const $inputIndices = backend.readSync(inputIndices.dataId);
      const targetShape = Array.from(backend.readSync(newShape.dataId));
      const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
      return [
        backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
        backend.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
      ];
    }
    var sparseReshapeConfig = {
      kernelName: SparseReshape,
      backendName: "webgl",
      kernelFunc: sparseReshape
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js
    function sparseSegmentMean(args) {
      const { inputs, backend } = args;
      const { data, indices, segmentIds } = inputs;
      if (data.shape.length < 1) {
        throw new Error(`Data should be at least 1 dimensional but received scalar`);
      }
      if (indices.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
                ${indices.shape}`);
      }
      if (segmentIds.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
                ${segmentIds.shape}`);
      }
      const $data = backend.readSync(data.dataId);
      const $indices = backend.readSync(indices.dataId);
      const $segmentIds = backend.readSync(segmentIds.dataId);
      const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
      return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
    }
    var sparseSegmentMeanConfig = {
      kernelName: SparseSegmentMean,
      backendName: "webgl",
      kernelFunc: sparseSegmentMean
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js
    function sparseSegmentSum(args) {
      const { inputs, backend } = args;
      const { data, indices, segmentIds } = inputs;
      if (data.shape.length < 1) {
        throw new Error(`Data should be at least 1 dimensional but received scalar`);
      }
      if (indices.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
               ${indices.shape}`);
      }
      if (segmentIds.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
               ${segmentIds.shape}`);
      }
      const $data = backend.readSync(data.dataId);
      const $indices = backend.readSync(indices.dataId);
      const $segmentIds = backend.readSync(segmentIds.dataId);
      const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
      return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
    }
    var sparseSegmentSumConfig = {
      kernelName: SparseSegmentSum,
      backendName: "webgl",
      kernelFunc: sparseSegmentSum
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SparseToDense.js
    function sparseToDense(args) {
      const { inputs, backend, attrs } = args;
      const { sparseIndices, sparseValues, defaultValue } = inputs;
      const { outputShape } = attrs;
      const { sliceRank, numUpdates, strides, outputSize } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
      const sumDupeIndices = false;
      const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
      const res = backend.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
      const reshaped = reshape2({ inputs: { x: res }, backend, attrs: { shape: outputShape } });
      backend.disposeIntermediateTensorInfo(res);
      return reshaped;
    }
    var sparseToDenseConfig = {
      kernelName: SparseToDense,
      backendName: "webgl",
      kernelFunc: sparseToDense
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SplitV.js
    function splitV(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { numOrSizeSplits, axis } = attrs;
      const $axis = util_exports.parseAxisParam(axis, x.shape)[0];
      const splitSizes = backend_util_exports.prepareSplitSize(x, numOrSizeSplits, $axis);
      const xRank = x.shape.length;
      const begin = new Array(xRank).fill(0);
      const size = x.shape.slice();
      return splitSizes.map((s) => {
        const sliceSize = [...size];
        sliceSize[$axis] = s;
        const sliceT = slice({ inputs: { x }, backend, attrs: { begin, size: sliceSize } });
        begin[$axis] += s;
        return sliceT;
      });
    }
    var splitVConfig = {
      kernelName: SplitV,
      backendName: "webgl",
      kernelFunc: splitV
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Sqrt.js
    var SQRT = `return sqrt(x);`;
    var sqrt = unaryKernelFunc({ opSnippet: SQRT });
    var sqrtConfig = {
      kernelName: Sqrt,
      backendName: "webgl",
      kernelFunc: sqrt
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Square.js
    var SQUARE = `return x * x;`;
    var square = unaryKernelFunc({ opSnippet: SQUARE });
    var squareConfig = {
      kernelName: Square,
      backendName: "webgl",
      kernelFunc: square
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/SquaredDifference.js
    var SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
    var squaredDifference2 = binaryKernelFunc2({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
    var squaredDifferenceConfig = {
      kernelName: SquaredDifference,
      backendName: "webgl",
      kernelFunc: squaredDifference2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Step.js
    function step2({ inputs, attrs, backend }) {
      const { x } = inputs;
      const opSnippet = CHECK_NAN_SNIPPET + `
      return x > 0.0 ? 1.0 : float(${attrs.alpha});
    `;
      const program = new UnaryOpProgram(x.shape, opSnippet);
      return backend.runWebGLProgram(program, [x], x.dtype);
    }
    var stepConfig = {
      kernelName: Step,
      backendName: "webgl",
      kernelFunc: step2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/strided_slice_gpu.js
    var StridedSliceProgram = class {
      constructor(begin, strides, size) {
        this.variableNames = ["x"];
        this.outputShape = size;
        const rank = size.length;
        const inputDtype = getCoordsDataType(size.length);
        const dtype = getCoordsDataType(size.length);
        let newCoords = "";
        if (rank === 1) {
          newCoords = "coords * strides + begin";
        } else {
          let outputAxis = 0;
          newCoords = size.map((_, i) => {
            outputAxis++;
            return size.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
          }).join(",");
        }
        this.userCode = `
        ${inputDtype} begin = ${inputDtype}(${begin});
        ${inputDtype} strides = ${inputDtype}(${strides});
  
        void main() {
          ${dtype} coords = getOutputCoords();
          setOutput(getX(${newCoords}));
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/StridedSlice.js
    function stridedSlice(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
      const { nonStrided, $begin, $strides, size, newShape, outShape } = slice_util_exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
      const $x = reshape2({ inputs: { x }, backend, attrs: { shape: newShape } });
      let result2;
      if (nonStrided) {
        const sliced = slice({ inputs: { x: $x }, backend, attrs: { begin: $begin, size } });
        result2 = reshape2({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });
        backend.disposeIntermediateTensorInfo(sliced);
      } else if (outShape.some((axis) => axis === 0)) {
        result2 = backend.makeTensorInfo(outShape, x.dtype, []);
      } else {
        const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);
        if (shouldExecuteOnCPU) {
          const xTexData = backend.texData.get($x.dataId);
          const values = xTexData.values;
          const xBuf = buffer($x.shape, $x.dtype, values);
          const resultValues = stridedSliceImplCPU(outShape, xBuf, $strides, $begin);
          result2 = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);
        } else {
          const program = new StridedSliceProgram($begin, $strides, outShape);
          result2 = backend.runWebGLProgram(program, [$x], $x.dtype);
        }
      }
      const resultReshaped = reshape2({ inputs: { x: result2 }, backend, attrs: { shape: outShape } });
      backend.disposeIntermediateTensorInfo($x);
      backend.disposeIntermediateTensorInfo(result2);
      return resultReshaped;
    }
    var stridedSliceConfig = {
      kernelName: StridedSlice,
      backendName: "webgl",
      kernelFunc: stridedSlice
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/StringNGrams.js
    function stringNGrams(args) {
      const { inputs, backend, attrs } = args;
      const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
      const { data, dataSplits } = inputs;
      const $data = backend.readSync(data.dataId);
      const $dataSplits = backend.readSync(dataSplits.dataId);
      const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
      return [
        backend.makeTensorInfo([nGrams.length], "string", nGrams),
        backend.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
      ];
    }
    var stringNGramsConfig = {
      kernelName: StringNGrams,
      backendName: "webgl",
      kernelFunc: stringNGrams
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/StringSplit.js
    function stringSplit(args) {
      const { inputs, backend, attrs } = args;
      const { skipEmpty } = attrs;
      const { input, delimiter } = inputs;
      if (input.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (input.shape.length !== 1) {
        throw new Error(`Input must be a vector, got shape: ${input.shape}`);
      }
      if (delimiter.shape.length !== 0) {
        throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
      }
      const $input = backend.readSync(input.dataId);
      const $delimiter = backend.readSync(delimiter.dataId)[0];
      const [indices, values, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
      const outputSize = values.length;
      return [
        backend.makeTensorInfo([outputSize, 2], "int32", indices),
        backend.makeTensorInfo([outputSize], "string", values),
        backend.makeTensorInfo([2], "int32", new Int32Array(shape))
      ];
    }
    var stringSplitConfig = {
      kernelName: StringSplit,
      backendName: "webgl",
      kernelFunc: stringSplit
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js
    function stringToHashBucketFast(args) {
      const { inputs, backend, attrs } = args;
      const { numBuckets } = attrs;
      const { input } = inputs;
      if (input.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (numBuckets <= 0) {
        throw new Error(`Number of buckets must be at least 1`);
      }
      const $input = backend.readSync(input.dataId);
      const output = stringToHashBucketFastImplCPU($input, numBuckets);
      return backend.makeTensorInfo(input.shape, "int32", output);
    }
    var stringToHashBucketFastConfig = {
      kernelName: StringToHashBucketFast,
      backendName: "webgl",
      kernelFunc: stringToHashBucketFast
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Tan.js
    var TAN = `return tan(x);`;
    var tan = unaryKernelFunc({ opSnippet: TAN });
    var tanConfig = {
      kernelName: Tan,
      backendName: "webgl",
      kernelFunc: tan
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Tanh.js
    var TANH = `
    float e2x = exp(-2.0 * abs(x));
    return sign(x) * (1.0 - e2x) / (1.0 + e2x);
  `;
    var tanh2 = unaryKernelFunc({ opSnippet: TANH });
    var tanhConfig = {
      kernelName: Tanh,
      backendName: "webgl",
      kernelFunc: tanh2
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/tile_gpu.js
    var TileProgram = class {
      constructor(aShape, reps) {
        this.variableNames = ["A"];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const sourceCoords = getSourceCoords3(aShape);
        this.userCode = `
        void main() {
          ${dtype} resRC = getOutputCoords();
          setOutput(getA(${sourceCoords}));
        }
      `;
      }
    };
    function getSourceCoords3(aShape) {
      const rank = aShape.length;
      if (rank > 5) {
        throw Error(`Tile for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        return `imod(resRC, ${aShape[0]})`;
      }
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
      const sourceCoords = [];
      for (let i = 0; i < aShape.length; i++) {
        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
      }
      return sourceCoords.join();
    }
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Tile.js
    function tile(params) {
      const { inputs, backend, attrs } = params;
      const { x } = inputs;
      const { reps } = attrs;
      if (x.dtype === "string" || x.shape.length > 5) {
        const data = backend.readSync(x.dataId);
        const value = x.dtype === "string" ? data.map((d) => util_exports.decodeString(d)) : data;
        const buf = buffer(x.shape, x.dtype, value);
        const outBuf = tileImplCPU(buf, reps);
        return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
      }
      const program = new TileProgram(x.shape, reps);
      const output = backend.runWebGLProgram(program, [x], x.dtype);
      return output;
    }
    var tileConfig = {
      kernelName: Tile,
      backendName: "webgl",
      kernelFunc: tile
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/TopK.js
    function topK(args) {
      const { inputs, backend, attrs } = args;
      const { x } = inputs;
      const { k, sorted } = attrs;
      const xVals = backend.readSync(x.dataId);
      const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, x.shape, x.dtype, k, sorted);
      return [
        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
      ];
    }
    var topKConfig = {
      kernelName: TopK,
      backendName: "webgl",
      kernelFunc: topK
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/transform_gpu.js
    var TransformProgram = class {
      constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
        this.variableNames = ["Image", "Transforms"];
        this.outputShape = outShape;
        const interpolationModeId = interpolation === "nearest" ? 1 : 2;
        let fillModeId;
        switch (fillMode) {
          case "constant":
            fillModeId = 1;
            break;
          case "reflect":
            fillModeId = 2;
            break;
          case "wrap":
            fillModeId = 3;
            break;
          case "nearest":
            fillModeId = 4;
            break;
          default:
            fillModeId = 1;
            break;
        }
        this.userCode = `
              float mapCoord(float outCoord, float len) {
                float inCoord = outCoord;
                if(${fillModeId} == 2) {
                  if (inCoord < 0.0) {
                    if (len <= 1.0) {
                      inCoord = 0.0;
                    } else {
                      float sz2 = 2.0 * len;
                      if (inCoord < sz2) {
                        inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                        inCoord;
                      }
                      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                    }
                  } else if (inCoord > len - 1.0) {
                    if (len <= 1.0) {
                      inCoord = 0.0;
                    } else {
                      float sz2 = 2.0 * len;
                      inCoord -= sz2 * float(int(float(inCoord / sz2)));
                      if (inCoord >= len) {
                        inCoord = sz2 - inCoord - 1.0;
                      }
                    }
                  }
                  return clamp(inCoord, 0.0, len - 1.0);
                } else if (${fillModeId} == 3) {
                  if (inCoord < 0.0) {
                    if (len <= 1.0) {
                      inCoord = 0.0;
                    } else {
                      float sz = len - 1.0;
                      inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                    }
                  } else if (inCoord > len - 1.0) {
                    if (len <= 1.0) {
                      inCoord = 0.0;
                    } else {
                      float sz = len - 1.0;
                      inCoord -= len * float(int(float(inCoord / sz)));
                    }
                  }
                  return clamp(inCoord, 0.0, len - 1.0);
                } else if (${fillModeId} == 4) {
                  return clamp(outCoord, 0.0, len - 1.0);
                } else {
                  return outCoord;
                }
              }
  
              float readWithFillValue(int batch, int coordY, int coordX,
                int channel) {
                float outputValue;
                if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                    outputValue = getImage(batch, coordY, coordX, channel);
                } else {
                  outputValue = float(${fillValue});
                }
                return outputValue;
              }
  
              void main() {
                ivec4 coords = getOutputCoords();
                float outputValue;
                int batch = coords[0];
                int x = coords[2];
                int y = coords[1];
                int channel = coords[3];
                float xf = float(x);
                float yf = float(y);
                float a1 = getTransforms(batch, 0);
                float a2 = getTransforms(batch, 1);
                float a3 = getTransforms(batch, 2);
                float b1 = getTransforms(batch, 3);
                float b2 = getTransforms(batch, 4);
                float b3 = getTransforms(batch, 5);
                float c1 = getTransforms(batch, 6);
                float c2 = getTransforms(batch, 7);
                float projection = c1 * xf + c2 * yf + 1.0;
                if (projection == 0.0) {
                  outputValue = float(${fillValue});
                } else {
                  float inX = (a1 * xf + a2 * yf + a3) / projection;
                  float inY = (b1 * xf + b2 * yf + b3) / projection;
                  float mapX = mapCoord(inX, float(${imageWidth}));
                  float mapY = mapCoord(inY, float(${imageHeight}));
  
                  if (${interpolationModeId} == 1) {
                    int coordY = int(round(mapY));
                    int coordX = int(round(mapX));
                    outputValue = readWithFillValue(batch, coordY, coordX,
                      channel);
                  } else {
                    float yFloor = floor(mapY);
                    float xFloor = floor(mapX);
                    float yCeil = yFloor + 1.0;
                    float xCeil = xFloor + 1.0;
                    float valueYFloor = (xCeil - mapX) *
                    readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                    (mapX - xFloor) *
                    readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                    float valueYCeil = (xCeil - mapX) *
                    readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                    (mapX - xFloor) *
                    readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                    outputValue = (yCeil - mapY) * valueYFloor +
                    (mapY - yFloor) * valueYCeil;
                  }
                }
                setOutput(outputValue);
              }
          `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Transform.js
    function transform(args) {
      const { inputs, backend, attrs } = args;
      const { image: image2, transforms } = inputs;
      const { interpolation, fillMode, fillValue, outputShape } = attrs;
      const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
      const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
      const outShape = [
        batch,
        outHeight,
        outWidth,
        numChannels
      ];
      const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
      return backend.runWebGLProgram(program, [image2, transforms], "float32");
    }
    var transformConfig = {
      kernelName: Transform,
      backendName: "webgl",
      kernelFunc: transform
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Unique.js
    function unique(args) {
      const { inputs, attrs, backend } = args;
      const { axis } = attrs;
      const { x } = inputs;
      assertNotComplex(x, "unique");
      console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
      const values = backend.readSync(x.dataId);
      const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x.shape, x.dtype);
      return [
        backend.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend.makeTensorInfo([indices.length], "int32", indices)
      ];
    }
    var uniqueConfig = {
      kernelName: Unique,
      backendName: "webgl",
      kernelFunc: unique
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/Unpack.js
    function unpack(args) {
      const { inputs, backend, attrs } = args;
      const { value } = inputs;
      let { axis } = attrs;
      if (axis < 0) {
        axis += value.shape.length;
      }
      const x = value;
      const xRank = x.shape.length;
      const num = value.shape[axis];
      const outShape = new Array(xRank - 1);
      let outIndex = 0;
      for (let i = 0; i < xRank; i++) {
        if (i !== axis) {
          outShape[outIndex++] = x.shape[i];
        }
      }
      const toDispose = [];
      const begin = new Array(xRank).fill(0);
      const size = x.shape.slice();
      size[axis] = 1;
      const res = new Array(num);
      for (let i = 0; i < res.length; i++) {
        begin[axis] = i;
        const sliced = slice({ inputs: { x }, backend, attrs: { begin, size } });
        const reshaped = reshape2({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });
        res[i] = reshaped;
        toDispose.push(sliced);
      }
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return res;
    }
    var unpackConfig = {
      kernelName: Unpack,
      backendName: "webgl",
      kernelFunc: unpack
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/segment_gpu.js
    var SegmentOpProgram = class {
      constructor(segOpInfo, segOpType) {
        this.variableNames = ["x", "segmentIds"];
        const windowSize = segOpInfo.windowSize;
        const batchSize = segOpInfo.batchSize;
        const inSize = segOpInfo.inSize;
        const numSegments = segOpInfo.numSegments;
        const outSize = numSegments * Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        const initializationValue = "0.0";
        const returnValue = `sumValue`;
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        const updateSnippet = `
          sumValue += dot(values, segFilter);
      `;
        let checkValueOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkValueOutOfBounds = `
          if (inIdx < 0 || inIdx >= ${inSize}) {
            return initializationValue;
          }
        `;
        }
        let checkSegmentIdOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkSegmentIdOutOfBounds = `
          if (inIdx < 0 || inIdx >= ${inSize}) {
            return -1.0;
          }
        `;
        }
        this.userCode = `
        const float initializationValue = ${initializationValue};
  
        float getValue(int batch, int inIdx) {
          ${checkValueOutOfBounds}
          return getX(batch, inIdx);
        }
  
        float getSegmentIdAtIndex(int inIdx) {
          ${checkSegmentIdOutOfBounds}
          return getSegmentIds(inIdx);
        }
  
        void main() {
          ivec2 coords = getOutputCoords();
          int batch = coords[0];
          int outIdx = coords[1];
          int inOffset = int(floor(float(outIdx) / float(
            ${numSegments})) * float(${windowSize}));
          int currentSeg = int(mod(float(outIdx), float(${numSegments})));
  
          float sumValue = 0.0;
  
          for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
            int inIdx = inOffset + i;
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2),
              getValue(batch, inIdx + 3)
            );
  
            vec4 segFilter = vec4(
              int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
            );
  
            ${updateSnippet}
          }
  
          int inIdx = inOffset + ${windowSizeNearestVec4};
          if (${windowSizeVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, inIdx),
              initializationValue,
              initializationValue,
              initializationValue
            );
  
            int inIdxSeg = int(getSegmentIdAtIndex(inIdx));
  
            vec4 segFilter = vec4(
              int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
              0,
              0,
              0
            );
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              initializationValue,
              initializationValue
            );
  
            vec4 segFilter = vec4(
              int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
                0,
                0
            );
  
            ${updateSnippet}
          } else if (${windowSizeVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, inIdx),
              getValue(batch, inIdx + 1),
              getValue(batch, inIdx + 2),
              initializationValue
            );
  
            vec4 segFilter = vec4(
              int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
              0
            );
  
            ${updateSnippet}
          }
          setOutput(${returnValue});
        }
      `;
      }
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js
    function unsortedSegmentSum(args) {
      const { inputs, backend, attrs } = args;
      const { x, segmentIds } = inputs;
      const { numSegments } = attrs;
      const xRank = x.shape.length;
      const toDispose = [];
      let axis = 0;
      const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
      let permutedX = x;
      if (permutation != null) {
        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });
        toDispose.push(permutedX);
        axis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
      }
      const outShape = backend_util_exports.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
      const inSize = util_exports.sizeFromShape([permutedX.shape[axis]]);
      const a2D = reshape2({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
      toDispose.push(a2D);
      const outputDType = sumOutType(x.dtype);
      const segOpCompute = (x2, segOpType, segmentIds2, dtype, numSegments2) => {
        const batchSize = x2.shape[0];
        const inSize2 = x2.shape[1];
        const windowSize = backend_util_exports.segment_util.segOpComputeOptimalWindowSize(inSize2, numSegments2);
        const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
        const program = new SegmentOpProgram(segOpInfo, segOpType);
        const output = backend.compileAndRun(program, [x2, segmentIds2], dtype);
        toDispose.push(output);
        if (output.shape[1] === numSegments2) {
          return output;
        }
        const rangeInfo = range({
          backend,
          attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
        });
        const tileInfo = tile({
          inputs: { x: rangeInfo },
          backend,
          attrs: { reps: [inSize2 / windowSize] }
        });
        toDispose.push(rangeInfo);
        toDispose.push(tileInfo);
        const result3 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
        return result3;
      };
      const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
      const reshaped = reshape2({ inputs: { x: segOpResult }, backend, attrs: { shape: outShape } });
      let result2 = reshaped;
      if (permutation != null) {
        toDispose.push(reshaped);
        const perm = backend_util_exports.getUndoAxesPermutation(permutation);
        result2 = transpose({ inputs: { x: result2 }, backend, attrs: { perm } });
      }
      toDispose.forEach((t) => backend.disposeIntermediateTensorInfo(t));
      return result2;
    }
    var unsortedSegmentSumConfig = {
      kernelName: UnsortedSegmentSum,
      backendName: "webgl",
      kernelFunc: unsortedSegmentSum
    };
  
    // ../../../tfjs/tfjs-backend-webgl/dist/register_all_kernels.js
    var kernelConfigs = [
      LRNConfig,
      LRNGradConfig,
      _fusedMatMulConfig,
      absConfig,
      acosConfig,
      acoshConfig,
      addConfig,
      addNConfig,
      allConfig,
      anyConfig,
      argMaxConfig,
      argMinConfig,
      asinConfig,
      asinhConfig,
      atan2Config,
      atanConfig,
      atanhConfig,
      avgPool3DConfig,
      avgPoolConfig,
      avgPoolGrad3DConfig,
      avgPoolGradConfig,
      batchMatMulConfig,
      batchNormConfig,
      batchToSpaceNDConfig,
      bincountConfig,
      castConfig,
      ceilConfig,
      clipByValueConfig,
      complexAbsConfig,
      complexConfig,
      concatConfig,
      conv2DBackpropFilterConfig,
      conv2DBackpropInputConfig,
      conv2DConfig,
      conv3DBackpropFilterV2Config,
      conv3DBackpropInputConfig,
      conv3DConfig,
      cosConfig,
      coshConfig,
      cropAndResizeConfig,
      cumsumConfig,
      denseBincountConfig,
      depthToSpaceConfig,
      depthwiseConv2dNativeBackpropFilterConfig,
      depthwiseConv2dNativeBackpropInputConfig,
      depthwiseConv2dNativeConfig,
      diagConfig,
      dilation2DConfig,
      einsumConfig,
      eluConfig,
      eluGradConfig,
      equalConfig,
      erfConfig,
      expConfig,
      expandDimsConfig,
      expm1Config,
      fftConfig,
      fillConfig,
      flipLeftRightConfig,
      floorConfig,
      floorDivConfig,
      fromPixelsConfig,
      fusedConv2DConfig,
      fusedDepthwiseConv2DConfig,
      gatherNdConfig,
      gatherV2Config,
      greaterConfig,
      greaterEqualConfig,
      identityConfig,
      ifftConfig,
      imagConfig,
      isFiniteConfig,
      isInfConfig,
      isNaNConfig,
      leakyReluConfig,
      lessConfig,
      lessEqualConfig,
      linSpaceConfig,
      log1pConfig,
      logConfig,
      logicalAndConfig,
      logicalNotConfig,
      logicalOrConfig,
      maxConfig,
      maxPool3DConfig,
      maxPoolConfig,
      maxPoolGrad3DConfig,
      maxPoolGradConfig,
      maxPoolWithArgmaxConfig,
      maximumConfig,
      meanConfig,
      minConfig,
      minimumConfig,
      mirrorPadConfig,
      modConfig,
      multinomialConfig,
      multiplyConfig,
      negConfig,
      nonMaxSuppressionV3Config,
      nonMaxSuppressionV4Config,
      nonMaxSuppressionV5Config,
      notEqualConfig,
      oneHotConfig,
      onesLikeConfig,
      packConfig,
      padV2Config,
      powConfig,
      preluConfig,
      prodConfig,
      rangeConfig,
      realConfig,
      realDivConfig,
      reciprocalConfig,
      relu6Config,
      reluConfig,
      reshapeConfig,
      resizeBilinearConfig,
      resizeBilinearGradConfig,
      resizeNearestNeighborConfig,
      resizeNearestNeighborGradConfig,
      reverseConfig,
      rotateWithOffsetConfig,
      roundConfig,
      rsqrtConfig,
      scatterNdConfig,
      selectConfig,
      seluConfig,
      sigmoidConfig,
      signConfig,
      sinConfig,
      sinhConfig,
      sliceConfig,
      softmaxConfig,
      softplusConfig,
      spaceToBatchNDConfig,
      sparseFillEmptyRowsConfig,
      sparseReshapeConfig,
      sparseSegmentMeanConfig,
      sparseSegmentSumConfig,
      sparseToDenseConfig,
      splitVConfig,
      sqrtConfig,
      squareConfig,
      squaredDifferenceConfig,
      stepConfig,
      stridedSliceConfig,
      stringNGramsConfig,
      stringSplitConfig,
      stringToHashBucketFastConfig,
      subConfig,
      sumConfig,
      tanConfig,
      tanhConfig,
      tileConfig,
      topKConfig,
      transformConfig,
      transposeConfig,
      uniqueConfig,
      unpackConfig,
      unsortedSegmentSumConfig,
      zerosLikeConfig
    ];
    for (const kernelConfig of kernelConfigs) {
      registerKernel(kernelConfig);
    }
  
    // index.js
    var bodyPix = __toModule(require_body_pix());
  
    // node_modules/dat.gui/build/dat.gui.module.js
    function ___$insertStyle(css2) {
      if (!css2) {
        return;
      }
      if (typeof window === "undefined") {
        return;
      }
      var style = document.createElement("style");
      style.setAttribute("type", "text/css");
      style.innerHTML = css2;
      document.head.appendChild(style);
      return css2;
    }
    function colorToString(color2, forceCSSHex) {
      var colorFormat = color2.__state.conversionName.toString();
      var r = Math.round(color2.r);
      var g = Math.round(color2.g);
      var b = Math.round(color2.b);
      var a = color2.a;
      var h = Math.round(color2.h);
      var s = color2.s.toFixed(1);
      var v = color2.v.toFixed(1);
      if (forceCSSHex || colorFormat === "THREE_CHAR_HEX" || colorFormat === "SIX_CHAR_HEX") {
        var str = color2.hex.toString(16);
        while (str.length < 6) {
          str = "0" + str;
        }
        return "#" + str;
      } else if (colorFormat === "CSS_RGB") {
        return "rgb(" + r + "," + g + "," + b + ")";
      } else if (colorFormat === "CSS_RGBA") {
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      } else if (colorFormat === "HEX") {
        return "0x" + color2.hex.toString(16);
      } else if (colorFormat === "RGB_ARRAY") {
        return "[" + r + "," + g + "," + b + "]";
      } else if (colorFormat === "RGBA_ARRAY") {
        return "[" + r + "," + g + "," + b + "," + a + "]";
      } else if (colorFormat === "RGB_OBJ") {
        return "{r:" + r + ",g:" + g + ",b:" + b + "}";
      } else if (colorFormat === "RGBA_OBJ") {
        return "{r:" + r + ",g:" + g + ",b:" + b + ",a:" + a + "}";
      } else if (colorFormat === "HSV_OBJ") {
        return "{h:" + h + ",s:" + s + ",v:" + v + "}";
      } else if (colorFormat === "HSVA_OBJ") {
        return "{h:" + h + ",s:" + s + ",v:" + v + ",a:" + a + "}";
      }
      return "unknown format";
    }
    var ARR_EACH = Array.prototype.forEach;
    var ARR_SLICE = Array.prototype.slice;
    var Common = {
      BREAK: {},
      extend: function extend(target) {
        this.each(ARR_SLICE.call(arguments, 1), function(obj) {
          var keys = this.isObject(obj) ? Object.keys(obj) : [];
          keys.forEach(function(key) {
            if (!this.isUndefined(obj[key])) {
              target[key] = obj[key];
            }
          }.bind(this));
        }, this);
        return target;
      },
      defaults: function defaults(target) {
        this.each(ARR_SLICE.call(arguments, 1), function(obj) {
          var keys = this.isObject(obj) ? Object.keys(obj) : [];
          keys.forEach(function(key) {
            if (this.isUndefined(target[key])) {
              target[key] = obj[key];
            }
          }.bind(this));
        }, this);
        return target;
      },
      compose: function compose() {
        var toCall = ARR_SLICE.call(arguments);
        return function() {
          var args = ARR_SLICE.call(arguments);
          for (var i = toCall.length - 1; i >= 0; i--) {
            args = [toCall[i].apply(this, args)];
          }
          return args[0];
        };
      },
      each: function each(obj, itr, scope) {
        if (!obj) {
          return;
        }
        if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
          obj.forEach(itr, scope);
        } else if (obj.length === obj.length + 0) {
          var key = void 0;
          var l = void 0;
          for (key = 0, l = obj.length; key < l; key++) {
            if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
              return;
            }
          }
        } else {
          for (var _key in obj) {
            if (itr.call(scope, obj[_key], _key) === this.BREAK) {
              return;
            }
          }
        }
      },
      defer: function defer2(fnc) {
        setTimeout(fnc, 0);
      },
      debounce: function debounce(func, threshold, callImmediately) {
        var timeout = void 0;
        return function() {
          var obj = this;
          var args = arguments;
          function delayed() {
            timeout = null;
            if (!callImmediately)
              func.apply(obj, args);
          }
          var callNow = callImmediately || !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(delayed, threshold);
          if (callNow) {
            func.apply(obj, args);
          }
        };
      },
      toArray: function toArray(obj) {
        if (obj.toArray)
          return obj.toArray();
        return ARR_SLICE.call(obj);
      },
      isUndefined: function isUndefined(obj) {
        return obj === void 0;
      },
      isNull: function isNull(obj) {
        return obj === null;
      },
      isNaN: function(_isNaN) {
        function isNaN3(_x) {
          return _isNaN.apply(this, arguments);
        }
        isNaN3.toString = function() {
          return _isNaN.toString();
        };
        return isNaN3;
      }(function(obj) {
        return isNaN(obj);
      }),
      isArray: Array.isArray || function(obj) {
        return obj.constructor === Array;
      },
      isObject: function isObject(obj) {
        return obj === Object(obj);
      },
      isNumber: function isNumber2(obj) {
        return obj === obj + 0;
      },
      isString: function isString2(obj) {
        return obj === obj + "";
      },
      isBoolean: function isBoolean2(obj) {
        return obj === false || obj === true;
      },
      isFunction: function isFunction2(obj) {
        return obj instanceof Function;
      }
    };
    var INTERPRETATIONS = [
      {
        litmus: Common.isString,
        conversions: {
          THREE_CHAR_HEX: {
            read: function read(original) {
              var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
              if (test === null) {
                return false;
              }
              return {
                space: "HEX",
                hex: parseInt("0x" + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
              };
            },
            write: colorToString
          },
          SIX_CHAR_HEX: {
            read: function read2(original) {
              var test = original.match(/^#([A-F0-9]{6})$/i);
              if (test === null) {
                return false;
              }
              return {
                space: "HEX",
                hex: parseInt("0x" + test[1].toString(), 0)
              };
            },
            write: colorToString
          },
          CSS_RGB: {
            read: function read3(original) {
              var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
              if (test === null) {
                return false;
              }
              return {
                space: "RGB",
                r: parseFloat(test[1]),
                g: parseFloat(test[2]),
                b: parseFloat(test[3])
              };
            },
            write: colorToString
          },
          CSS_RGBA: {
            read: function read4(original) {
              var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
              if (test === null) {
                return false;
              }
              return {
                space: "RGB",
                r: parseFloat(test[1]),
                g: parseFloat(test[2]),
                b: parseFloat(test[3]),
                a: parseFloat(test[4])
              };
            },
            write: colorToString
          }
        }
      },
      {
        litmus: Common.isNumber,
        conversions: {
          HEX: {
            read: function read5(original) {
              return {
                space: "HEX",
                hex: original,
                conversionName: "HEX"
              };
            },
            write: function write(color2) {
              return color2.hex;
            }
          }
        }
      },
      {
        litmus: Common.isArray,
        conversions: {
          RGB_ARRAY: {
            read: function read6(original) {
              if (original.length !== 3) {
                return false;
              }
              return {
                space: "RGB",
                r: original[0],
                g: original[1],
                b: original[2]
              };
            },
            write: function write2(color2) {
              return [color2.r, color2.g, color2.b];
            }
          },
          RGBA_ARRAY: {
            read: function read7(original) {
              if (original.length !== 4)
                return false;
              return {
                space: "RGB",
                r: original[0],
                g: original[1],
                b: original[2],
                a: original[3]
              };
            },
            write: function write3(color2) {
              return [color2.r, color2.g, color2.b, color2.a];
            }
          }
        }
      },
      {
        litmus: Common.isObject,
        conversions: {
          RGBA_OBJ: {
            read: function read8(original) {
              if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
                return {
                  space: "RGB",
                  r: original.r,
                  g: original.g,
                  b: original.b,
                  a: original.a
                };
              }
              return false;
            },
            write: function write4(color2) {
              return {
                r: color2.r,
                g: color2.g,
                b: color2.b,
                a: color2.a
              };
            }
          },
          RGB_OBJ: {
            read: function read9(original) {
              if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
                return {
                  space: "RGB",
                  r: original.r,
                  g: original.g,
                  b: original.b
                };
              }
              return false;
            },
            write: function write5(color2) {
              return {
                r: color2.r,
                g: color2.g,
                b: color2.b
              };
            }
          },
          HSVA_OBJ: {
            read: function read10(original) {
              if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
                return {
                  space: "HSV",
                  h: original.h,
                  s: original.s,
                  v: original.v,
                  a: original.a
                };
              }
              return false;
            },
            write: function write6(color2) {
              return {
                h: color2.h,
                s: color2.s,
                v: color2.v,
                a: color2.a
              };
            }
          },
          HSV_OBJ: {
            read: function read11(original) {
              if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
                return {
                  space: "HSV",
                  h: original.h,
                  s: original.s,
                  v: original.v
                };
              }
              return false;
            },
            write: function write7(color2) {
              return {
                h: color2.h,
                s: color2.s,
                v: color2.v
              };
            }
          }
        }
      }
    ];
    var result = void 0;
    var toReturn = void 0;
    var interpret = function interpret2() {
      toReturn = false;
      var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
      Common.each(INTERPRETATIONS, function(family) {
        if (family.litmus(original)) {
          Common.each(family.conversions, function(conversion, conversionName) {
            result = conversion.read(original);
            if (toReturn === false && result !== false) {
              toReturn = result;
              result.conversionName = conversionName;
              result.conversion = conversion;
              return Common.BREAK;
            }
          });
          return Common.BREAK;
        }
      });
      return toReturn;
    };
    var tmpComponent = void 0;
    var ColorMath = {
      hsv_to_rgb: function hsv_to_rgb(h, s, v) {
        var hi = Math.floor(h / 60) % 6;
        var f = h / 60 - Math.floor(h / 60);
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
        return {
          r: c[0] * 255,
          g: c[1] * 255,
          b: c[2] * 255
        };
      },
      rgb_to_hsv: function rgb_to_hsv(r, g, b) {
        var min2 = Math.min(r, g, b);
        var max2 = Math.max(r, g, b);
        var delta = max2 - min2;
        var h = void 0;
        var s = void 0;
        if (max2 !== 0) {
          s = delta / max2;
        } else {
          return {
            h: NaN,
            s: 0,
            v: 0
          };
        }
        if (r === max2) {
          h = (g - b) / delta;
        } else if (g === max2) {
          h = 2 + (b - r) / delta;
        } else {
          h = 4 + (r - g) / delta;
        }
        h /= 6;
        if (h < 0) {
          h += 1;
        }
        return {
          h: h * 360,
          s,
          v: max2 / 255
        };
      },
      rgb_to_hex: function rgb_to_hex(r, g, b) {
        var hex = this.hex_with_component(0, 2, r);
        hex = this.hex_with_component(hex, 1, g);
        hex = this.hex_with_component(hex, 0, b);
        return hex;
      },
      component_from_hex: function component_from_hex(hex, componentIndex) {
        return hex >> componentIndex * 8 & 255;
      },
      hex_with_component: function hex_with_component(hex, componentIndex, value) {
        return value << (tmpComponent = componentIndex * 8) | hex & ~(255 << tmpComponent);
      }
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var get = function get2(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return void 0;
        } else {
          return get2(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var inherits = function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };
    var possibleConstructorReturn = function(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    };
    var Color = function() {
      function Color2() {
        classCallCheck(this, Color2);
        this.__state = interpret.apply(this, arguments);
        if (this.__state === false) {
          throw new Error("Failed to interpret color arguments");
        }
        this.__state.a = this.__state.a || 1;
      }
      createClass(Color2, [{
        key: "toString",
        value: function toString() {
          return colorToString(this);
        }
      }, {
        key: "toHexString",
        value: function toHexString() {
          return colorToString(this, true);
        }
      }, {
        key: "toOriginal",
        value: function toOriginal() {
          return this.__state.conversion.write(this);
        }
      }]);
      return Color2;
    }();
    function defineRGBComponent(target, component, componentHexIndex) {
      Object.defineProperty(target, component, {
        get: function get$$13() {
          if (this.__state.space === "RGB") {
            return this.__state[component];
          }
          Color.recalculateRGB(this, component, componentHexIndex);
          return this.__state[component];
        },
        set: function set$$13(v) {
          if (this.__state.space !== "RGB") {
            Color.recalculateRGB(this, component, componentHexIndex);
            this.__state.space = "RGB";
          }
          this.__state[component] = v;
        }
      });
    }
    function defineHSVComponent(target, component) {
      Object.defineProperty(target, component, {
        get: function get$$13() {
          if (this.__state.space === "HSV") {
            return this.__state[component];
          }
          Color.recalculateHSV(this);
          return this.__state[component];
        },
        set: function set$$13(v) {
          if (this.__state.space !== "HSV") {
            Color.recalculateHSV(this);
            this.__state.space = "HSV";
          }
          this.__state[component] = v;
        }
      });
    }
    Color.recalculateRGB = function(color2, component, componentHexIndex) {
      if (color2.__state.space === "HEX") {
        color2.__state[component] = ColorMath.component_from_hex(color2.__state.hex, componentHexIndex);
      } else if (color2.__state.space === "HSV") {
        Common.extend(color2.__state, ColorMath.hsv_to_rgb(color2.__state.h, color2.__state.s, color2.__state.v));
      } else {
        throw new Error("Corrupted color state");
      }
    };
    Color.recalculateHSV = function(color2) {
      var result2 = ColorMath.rgb_to_hsv(color2.r, color2.g, color2.b);
      Common.extend(color2.__state, {
        s: result2.s,
        v: result2.v
      });
      if (!Common.isNaN(result2.h)) {
        color2.__state.h = result2.h;
      } else if (Common.isUndefined(color2.__state.h)) {
        color2.__state.h = 0;
      }
    };
    Color.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
    defineRGBComponent(Color.prototype, "r", 2);
    defineRGBComponent(Color.prototype, "g", 1);
    defineRGBComponent(Color.prototype, "b", 0);
    defineHSVComponent(Color.prototype, "h");
    defineHSVComponent(Color.prototype, "s");
    defineHSVComponent(Color.prototype, "v");
    Object.defineProperty(Color.prototype, "a", {
      get: function get$$1() {
        return this.__state.a;
      },
      set: function set$$1(v) {
        this.__state.a = v;
      }
    });
    Object.defineProperty(Color.prototype, "hex", {
      get: function get$$12() {
        if (this.__state.space !== "HEX") {
          this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
          this.__state.space = "HEX";
        }
        return this.__state.hex;
      },
      set: function set$$12(v) {
        this.__state.space = "HEX";
        this.__state.hex = v;
      }
    });
    var Controller = function() {
      function Controller2(object, property) {
        classCallCheck(this, Controller2);
        this.initialValue = object[property];
        this.domElement = document.createElement("div");
        this.object = object;
        this.property = property;
        this.__onChange = void 0;
        this.__onFinishChange = void 0;
      }
      createClass(Controller2, [{
        key: "onChange",
        value: function onChange(fnc) {
          this.__onChange = fnc;
          return this;
        }
      }, {
        key: "onFinishChange",
        value: function onFinishChange(fnc) {
          this.__onFinishChange = fnc;
          return this;
        }
      }, {
        key: "setValue",
        value: function setValue(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        }
      }, {
        key: "getValue",
        value: function getValue() {
          return this.object[this.property];
        }
      }, {
        key: "updateDisplay",
        value: function updateDisplay2() {
          return this;
        }
      }, {
        key: "isModified",
        value: function isModified() {
          return this.initialValue !== this.getValue();
        }
      }]);
      return Controller2;
    }();
    var EVENT_MAP = {
      HTMLEvents: ["change"],
      MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
      KeyboardEvents: ["keydown"]
    };
    var EVENT_MAP_INV = {};
    Common.each(EVENT_MAP, function(v, k) {
      Common.each(v, function(e) {
        EVENT_MAP_INV[e] = k;
      });
    });
    var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
    function cssValueToPixels(val) {
      if (val === "0" || Common.isUndefined(val)) {
        return 0;
      }
      var match = val.match(CSS_VALUE_PIXELS);
      if (!Common.isNull(match)) {
        return parseFloat(match[1]);
      }
      return 0;
    }
    var dom = {
      makeSelectable: function makeSelectable(elem, selectable) {
        if (elem === void 0 || elem.style === void 0)
          return;
        elem.onselectstart = selectable ? function() {
          return false;
        } : function() {
        };
        elem.style.MozUserSelect = selectable ? "auto" : "none";
        elem.style.KhtmlUserSelect = selectable ? "auto" : "none";
        elem.unselectable = selectable ? "on" : "off";
      },
      makeFullscreen: function makeFullscreen(elem, hor, vert) {
        var vertical = vert;
        var horizontal = hor;
        if (Common.isUndefined(horizontal)) {
          horizontal = true;
        }
        if (Common.isUndefined(vertical)) {
          vertical = true;
        }
        elem.style.position = "absolute";
        if (horizontal) {
          elem.style.left = 0;
          elem.style.right = 0;
        }
        if (vertical) {
          elem.style.top = 0;
          elem.style.bottom = 0;
        }
      },
      fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
        var params = pars || {};
        var className = EVENT_MAP_INV[eventType];
        if (!className) {
          throw new Error("Event type " + eventType + " not supported.");
        }
        var evt = document.createEvent(className);
        switch (className) {
          case "MouseEvents": {
            var clientX = params.x || params.clientX || 0;
            var clientY = params.y || params.clientY || 0;
            evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, 0, clientX, clientY, false, false, false, false, 0, null);
            break;
          }
          case "KeyboardEvents": {
            var init = evt.initKeyboardEvent || evt.initKeyEvent;
            Common.defaults(params, {
              cancelable: true,
              ctrlKey: false,
              altKey: false,
              shiftKey: false,
              metaKey: false,
              keyCode: void 0,
              charCode: void 0
            });
            init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
            break;
          }
          default: {
            evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
            break;
          }
        }
        Common.defaults(evt, aux);
        elem.dispatchEvent(evt);
      },
      bind: function bind(elem, event, func, newBool) {
        var bool = newBool || false;
        if (elem.addEventListener) {
          elem.addEventListener(event, func, bool);
        } else if (elem.attachEvent) {
          elem.attachEvent("on" + event, func);
        }
        return dom;
      },
      unbind: function unbind(elem, event, func, newBool) {
        var bool = newBool || false;
        if (elem.removeEventListener) {
          elem.removeEventListener(event, func, bool);
        } else if (elem.detachEvent) {
          elem.detachEvent("on" + event, func);
        }
        return dom;
      },
      addClass: function addClass(elem, className) {
        if (elem.className === void 0) {
          elem.className = className;
        } else if (elem.className !== className) {
          var classes = elem.className.split(/ +/);
          if (classes.indexOf(className) === -1) {
            classes.push(className);
            elem.className = classes.join(" ").replace(/^\s+/, "").replace(/\s+$/, "");
          }
        }
        return dom;
      },
      removeClass: function removeClass(elem, className) {
        if (className) {
          if (elem.className === className) {
            elem.removeAttribute("class");
          } else {
            var classes = elem.className.split(/ +/);
            var index2 = classes.indexOf(className);
            if (index2 !== -1) {
              classes.splice(index2, 1);
              elem.className = classes.join(" ");
            }
          }
        } else {
          elem.className = void 0;
        }
        return dom;
      },
      hasClass: function hasClass(elem, className) {
        return new RegExp("(?:^|\\s+)" + className + "(?:\\s+|$)").test(elem.className) || false;
      },
      getWidth: function getWidth(elem) {
        var style = getComputedStyle(elem);
        return cssValueToPixels(style["border-left-width"]) + cssValueToPixels(style["border-right-width"]) + cssValueToPixels(style["padding-left"]) + cssValueToPixels(style["padding-right"]) + cssValueToPixels(style.width);
      },
      getHeight: function getHeight(elem) {
        var style = getComputedStyle(elem);
        return cssValueToPixels(style["border-top-width"]) + cssValueToPixels(style["border-bottom-width"]) + cssValueToPixels(style["padding-top"]) + cssValueToPixels(style["padding-bottom"]) + cssValueToPixels(style.height);
      },
      getOffset: function getOffset(el) {
        var elem = el;
        var offset = { left: 0, top: 0 };
        if (elem.offsetParent) {
          do {
            offset.left += elem.offsetLeft;
            offset.top += elem.offsetTop;
            elem = elem.offsetParent;
          } while (elem);
        }
        return offset;
      },
      isActive: function isActive(elem) {
        return elem === document.activeElement && (elem.type || elem.href);
      }
    };
    var BooleanController = function(_Controller) {
      inherits(BooleanController2, _Controller);
      function BooleanController2(object, property) {
        classCallCheck(this, BooleanController2);
        var _this2 = possibleConstructorReturn(this, (BooleanController2.__proto__ || Object.getPrototypeOf(BooleanController2)).call(this, object, property));
        var _this = _this2;
        _this2.__prev = _this2.getValue();
        _this2.__checkbox = document.createElement("input");
        _this2.__checkbox.setAttribute("type", "checkbox");
        function onChange() {
          _this.setValue(!_this.__prev);
        }
        dom.bind(_this2.__checkbox, "change", onChange, false);
        _this2.domElement.appendChild(_this2.__checkbox);
        _this2.updateDisplay();
        return _this2;
      }
      createClass(BooleanController2, [{
        key: "setValue",
        value: function setValue(v) {
          var toReturn2 = get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "setValue", this).call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn2;
        }
      }, {
        key: "updateDisplay",
        value: function updateDisplay2() {
          if (this.getValue() === true) {
            this.__checkbox.setAttribute("checked", "checked");
            this.__checkbox.checked = true;
            this.__prev = true;
          } else {
            this.__checkbox.checked = false;
            this.__prev = false;
          }
          return get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "updateDisplay", this).call(this);
        }
      }]);
      return BooleanController2;
    }(Controller);
    var OptionController = function(_Controller) {
      inherits(OptionController2, _Controller);
      function OptionController2(object, property, opts) {
        classCallCheck(this, OptionController2);
        var _this2 = possibleConstructorReturn(this, (OptionController2.__proto__ || Object.getPrototypeOf(OptionController2)).call(this, object, property));
        var options = opts;
        var _this = _this2;
        _this2.__select = document.createElement("select");
        if (Common.isArray(options)) {
          var map2 = {};
          Common.each(options, function(element) {
            map2[element] = element;
          });
          options = map2;
        }
        Common.each(options, function(value, key) {
          var opt = document.createElement("option");
          opt.innerHTML = key;
          opt.setAttribute("value", value);
          _this.__select.appendChild(opt);
        });
        _this2.updateDisplay();
        dom.bind(_this2.__select, "change", function() {
          var desiredValue = this.options[this.selectedIndex].value;
          _this.setValue(desiredValue);
        });
        _this2.domElement.appendChild(_this2.__select);
        return _this2;
      }
      createClass(OptionController2, [{
        key: "setValue",
        value: function setValue(v) {
          var toReturn2 = get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "setValue", this).call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn2;
        }
      }, {
        key: "updateDisplay",
        value: function updateDisplay2() {
          if (dom.isActive(this.__select))
            return this;
          this.__select.value = this.getValue();
          return get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "updateDisplay", this).call(this);
        }
      }]);
      return OptionController2;
    }(Controller);
    var StringController = function(_Controller) {
      inherits(StringController2, _Controller);
      function StringController2(object, property) {
        classCallCheck(this, StringController2);
        var _this2 = possibleConstructorReturn(this, (StringController2.__proto__ || Object.getPrototypeOf(StringController2)).call(this, object, property));
        var _this = _this2;
        function onChange() {
          _this.setValue(_this.__input.value);
        }
        function onBlur() {
          if (_this.__onFinishChange) {
            _this.__onFinishChange.call(_this, _this.getValue());
          }
        }
        _this2.__input = document.createElement("input");
        _this2.__input.setAttribute("type", "text");
        dom.bind(_this2.__input, "keyup", onChange);
        dom.bind(_this2.__input, "change", onChange);
        dom.bind(_this2.__input, "blur", onBlur);
        dom.bind(_this2.__input, "keydown", function(e) {
          if (e.keyCode === 13) {
            this.blur();
          }
        });
        _this2.updateDisplay();
        _this2.domElement.appendChild(_this2.__input);
        return _this2;
      }
      createClass(StringController2, [{
        key: "updateDisplay",
        value: function updateDisplay2() {
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return get(StringController2.prototype.__proto__ || Object.getPrototypeOf(StringController2.prototype), "updateDisplay", this).call(this);
        }
      }]);
      return StringController2;
    }(Controller);
    function numDecimals(x) {
      var _x = x.toString();
      if (_x.indexOf(".") > -1) {
        return _x.length - _x.indexOf(".") - 1;
      }
      return 0;
    }
    var NumberController = function(_Controller) {
      inherits(NumberController2, _Controller);
      function NumberController2(object, property, params) {
        classCallCheck(this, NumberController2);
        var _this = possibleConstructorReturn(this, (NumberController2.__proto__ || Object.getPrototypeOf(NumberController2)).call(this, object, property));
        var _params = params || {};
        _this.__min = _params.min;
        _this.__max = _params.max;
        _this.__step = _params.step;
        if (Common.isUndefined(_this.__step)) {
          if (_this.initialValue === 0) {
            _this.__impliedStep = 1;
          } else {
            _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
          }
        } else {
          _this.__impliedStep = _this.__step;
        }
        _this.__precision = numDecimals(_this.__impliedStep);
        return _this;
      }
      createClass(NumberController2, [{
        key: "setValue",
        value: function setValue(v) {
          var _v = v;
          if (this.__min !== void 0 && _v < this.__min) {
            _v = this.__min;
          } else if (this.__max !== void 0 && _v > this.__max) {
            _v = this.__max;
          }
          if (this.__step !== void 0 && _v % this.__step !== 0) {
            _v = Math.round(_v / this.__step) * this.__step;
          }
          return get(NumberController2.prototype.__proto__ || Object.getPrototypeOf(NumberController2.prototype), "setValue", this).call(this, _v);
        }
      }, {
        key: "min",
        value: function min2(minValue) {
          this.__min = minValue;
          return this;
        }
      }, {
        key: "max",
        value: function max2(maxValue) {
          this.__max = maxValue;
          return this;
        }
      }, {
        key: "step",
        value: function step3(stepValue) {
          this.__step = stepValue;
          this.__impliedStep = stepValue;
          this.__precision = numDecimals(stepValue);
          return this;
        }
      }]);
      return NumberController2;
    }(Controller);
    function roundToDecimal(value, decimals) {
      var tenTo = Math.pow(10, decimals);
      return Math.round(value * tenTo) / tenTo;
    }
    var NumberControllerBox = function(_NumberController) {
      inherits(NumberControllerBox2, _NumberController);
      function NumberControllerBox2(object, property, params) {
        classCallCheck(this, NumberControllerBox2);
        var _this2 = possibleConstructorReturn(this, (NumberControllerBox2.__proto__ || Object.getPrototypeOf(NumberControllerBox2)).call(this, object, property, params));
        _this2.__truncationSuspended = false;
        var _this = _this2;
        var prevY = void 0;
        function onChange() {
          var attempted = parseFloat(_this.__input.value);
          if (!Common.isNaN(attempted)) {
            _this.setValue(attempted);
          }
        }
        function onFinish() {
          if (_this.__onFinishChange) {
            _this.__onFinishChange.call(_this, _this.getValue());
          }
        }
        function onBlur() {
          onFinish();
        }
        function onMouseDrag(e) {
          var diff = prevY - e.clientY;
          _this.setValue(_this.getValue() + diff * _this.__impliedStep);
          prevY = e.clientY;
        }
        function onMouseUp() {
          dom.unbind(window, "mousemove", onMouseDrag);
          dom.unbind(window, "mouseup", onMouseUp);
          onFinish();
        }
        function onMouseDown(e) {
          dom.bind(window, "mousemove", onMouseDrag);
          dom.bind(window, "mouseup", onMouseUp);
          prevY = e.clientY;
        }
        _this2.__input = document.createElement("input");
        _this2.__input.setAttribute("type", "text");
        dom.bind(_this2.__input, "change", onChange);
        dom.bind(_this2.__input, "blur", onBlur);
        dom.bind(_this2.__input, "mousedown", onMouseDown);
        dom.bind(_this2.__input, "keydown", function(e) {
          if (e.keyCode === 13) {
            _this.__truncationSuspended = true;
            this.blur();
            _this.__truncationSuspended = false;
            onFinish();
          }
        });
        _this2.updateDisplay();
        _this2.domElement.appendChild(_this2.__input);
        return _this2;
      }
      createClass(NumberControllerBox2, [{
        key: "updateDisplay",
        value: function updateDisplay2() {
          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return get(NumberControllerBox2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox2.prototype), "updateDisplay", this).call(this);
        }
      }]);
      return NumberControllerBox2;
    }(NumberController);
    function map(v, i1, i2, o1, o2) {
      return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
    }
    var NumberControllerSlider = function(_NumberController) {
      inherits(NumberControllerSlider2, _NumberController);
      function NumberControllerSlider2(object, property, min2, max2, step3) {
        classCallCheck(this, NumberControllerSlider2);
        var _this2 = possibleConstructorReturn(this, (NumberControllerSlider2.__proto__ || Object.getPrototypeOf(NumberControllerSlider2)).call(this, object, property, { min: min2, max: max2, step: step3 }));
        var _this = _this2;
        _this2.__background = document.createElement("div");
        _this2.__foreground = document.createElement("div");
        dom.bind(_this2.__background, "mousedown", onMouseDown);
        dom.bind(_this2.__background, "touchstart", onTouchStart);
        dom.addClass(_this2.__background, "slider");
        dom.addClass(_this2.__foreground, "slider-fg");
        function onMouseDown(e) {
          document.activeElement.blur();
          dom.bind(window, "mousemove", onMouseDrag);
          dom.bind(window, "mouseup", onMouseUp);
          onMouseDrag(e);
        }
        function onMouseDrag(e) {
          e.preventDefault();
          var bgRect = _this.__background.getBoundingClientRect();
          _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
          return false;
        }
        function onMouseUp() {
          dom.unbind(window, "mousemove", onMouseDrag);
          dom.unbind(window, "mouseup", onMouseUp);
          if (_this.__onFinishChange) {
            _this.__onFinishChange.call(_this, _this.getValue());
          }
        }
        function onTouchStart(e) {
          if (e.touches.length !== 1) {
            return;
          }
          dom.bind(window, "touchmove", onTouchMove);
          dom.bind(window, "touchend", onTouchEnd);
          onTouchMove(e);
        }
        function onTouchMove(e) {
          var clientX = e.touches[0].clientX;
          var bgRect = _this.__background.getBoundingClientRect();
          _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
        }
        function onTouchEnd() {
          dom.unbind(window, "touchmove", onTouchMove);
          dom.unbind(window, "touchend", onTouchEnd);
          if (_this.__onFinishChange) {
            _this.__onFinishChange.call(_this, _this.getValue());
          }
        }
        _this2.updateDisplay();
        _this2.__background.appendChild(_this2.__foreground);
        _this2.domElement.appendChild(_this2.__background);
        return _this2;
      }
      createClass(NumberControllerSlider2, [{
        key: "updateDisplay",
        value: function updateDisplay2() {
          var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
          this.__foreground.style.width = pct * 100 + "%";
          return get(NumberControllerSlider2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider2.prototype), "updateDisplay", this).call(this);
        }
      }]);
      return NumberControllerSlider2;
    }(NumberController);
    var FunctionController = function(_Controller) {
      inherits(FunctionController2, _Controller);
      function FunctionController2(object, property, text) {
        classCallCheck(this, FunctionController2);
        var _this2 = possibleConstructorReturn(this, (FunctionController2.__proto__ || Object.getPrototypeOf(FunctionController2)).call(this, object, property));
        var _this = _this2;
        _this2.__button = document.createElement("div");
        _this2.__button.innerHTML = text === void 0 ? "Fire" : text;
        dom.bind(_this2.__button, "click", function(e) {
          e.preventDefault();
          _this.fire();
          return false;
        });
        dom.addClass(_this2.__button, "button");
        _this2.domElement.appendChild(_this2.__button);
        return _this2;
      }
      createClass(FunctionController2, [{
        key: "fire",
        value: function fire() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          this.getValue().call(this.object);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
        }
      }]);
      return FunctionController2;
    }(Controller);
    var ColorController = function(_Controller) {
      inherits(ColorController2, _Controller);
      function ColorController2(object, property) {
        classCallCheck(this, ColorController2);
        var _this2 = possibleConstructorReturn(this, (ColorController2.__proto__ || Object.getPrototypeOf(ColorController2)).call(this, object, property));
        _this2.__color = new Color(_this2.getValue());
        _this2.__temp = new Color(0);
        var _this = _this2;
        _this2.domElement = document.createElement("div");
        dom.makeSelectable(_this2.domElement, false);
        _this2.__selector = document.createElement("div");
        _this2.__selector.className = "selector";
        _this2.__saturation_field = document.createElement("div");
        _this2.__saturation_field.className = "saturation-field";
        _this2.__field_knob = document.createElement("div");
        _this2.__field_knob.className = "field-knob";
        _this2.__field_knob_border = "2px solid ";
        _this2.__hue_knob = document.createElement("div");
        _this2.__hue_knob.className = "hue-knob";
        _this2.__hue_field = document.createElement("div");
        _this2.__hue_field.className = "hue-field";
        _this2.__input = document.createElement("input");
        _this2.__input.type = "text";
        _this2.__input_textShadow = "0 1px 1px ";
        dom.bind(_this2.__input, "keydown", function(e) {
          if (e.keyCode === 13) {
            onBlur.call(this);
          }
        });
        dom.bind(_this2.__input, "blur", onBlur);
        dom.bind(_this2.__selector, "mousedown", function() {
          dom.addClass(this, "drag").bind(window, "mouseup", function() {
            dom.removeClass(_this.__selector, "drag");
          });
        });
        dom.bind(_this2.__selector, "touchstart", function() {
          dom.addClass(this, "drag").bind(window, "touchend", function() {
            dom.removeClass(_this.__selector, "drag");
          });
        });
        var valueField = document.createElement("div");
        Common.extend(_this2.__selector.style, {
          width: "122px",
          height: "102px",
          padding: "3px",
          backgroundColor: "#222",
          boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
        });
        Common.extend(_this2.__field_knob.style, {
          position: "absolute",
          width: "12px",
          height: "12px",
          border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? "#fff" : "#000"),
          boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
          borderRadius: "12px",
          zIndex: 1
        });
        Common.extend(_this2.__hue_knob.style, {
          position: "absolute",
          width: "15px",
          height: "2px",
          borderRight: "4px solid #fff",
          zIndex: 1
        });
        Common.extend(_this2.__saturation_field.style, {
          width: "100px",
          height: "100px",
          border: "1px solid #555",
          marginRight: "3px",
          display: "inline-block",
          cursor: "pointer"
        });
        Common.extend(valueField.style, {
          width: "100%",
          height: "100%",
          background: "none"
        });
        linearGradient(valueField, "top", "rgba(0,0,0,0)", "#000");
        Common.extend(_this2.__hue_field.style, {
          width: "15px",
          height: "100px",
          border: "1px solid #555",
          cursor: "ns-resize",
          position: "absolute",
          top: "3px",
          right: "3px"
        });
        hueGradient(_this2.__hue_field);
        Common.extend(_this2.__input.style, {
          outline: "none",
          textAlign: "center",
          color: "#fff",
          border: 0,
          fontWeight: "bold",
          textShadow: _this2.__input_textShadow + "rgba(0,0,0,0.7)"
        });
        dom.bind(_this2.__saturation_field, "mousedown", fieldDown);
        dom.bind(_this2.__saturation_field, "touchstart", fieldDown);
        dom.bind(_this2.__field_knob, "mousedown", fieldDown);
        dom.bind(_this2.__field_knob, "touchstart", fieldDown);
        dom.bind(_this2.__hue_field, "mousedown", fieldDownH);
        dom.bind(_this2.__hue_field, "touchstart", fieldDownH);
        function fieldDown(e) {
          setSV(e);
          dom.bind(window, "mousemove", setSV);
          dom.bind(window, "touchmove", setSV);
          dom.bind(window, "mouseup", fieldUpSV);
          dom.bind(window, "touchend", fieldUpSV);
        }
        function fieldDownH(e) {
          setH(e);
          dom.bind(window, "mousemove", setH);
          dom.bind(window, "touchmove", setH);
          dom.bind(window, "mouseup", fieldUpH);
          dom.bind(window, "touchend", fieldUpH);
        }
        function fieldUpSV() {
          dom.unbind(window, "mousemove", setSV);
          dom.unbind(window, "touchmove", setSV);
          dom.unbind(window, "mouseup", fieldUpSV);
          dom.unbind(window, "touchend", fieldUpSV);
          onFinish();
        }
        function fieldUpH() {
          dom.unbind(window, "mousemove", setH);
          dom.unbind(window, "touchmove", setH);
          dom.unbind(window, "mouseup", fieldUpH);
          dom.unbind(window, "touchend", fieldUpH);
          onFinish();
        }
        function onBlur() {
          var i = interpret(this.value);
          if (i !== false) {
            _this.__color.__state = i;
            _this.setValue(_this.__color.toOriginal());
          } else {
            this.value = _this.__color.toString();
          }
        }
        function onFinish() {
          if (_this.__onFinishChange) {
            _this.__onFinishChange.call(_this, _this.__color.toOriginal());
          }
        }
        _this2.__saturation_field.appendChild(valueField);
        _this2.__selector.appendChild(_this2.__field_knob);
        _this2.__selector.appendChild(_this2.__saturation_field);
        _this2.__selector.appendChild(_this2.__hue_field);
        _this2.__hue_field.appendChild(_this2.__hue_knob);
        _this2.domElement.appendChild(_this2.__input);
        _this2.domElement.appendChild(_this2.__selector);
        _this2.updateDisplay();
        function setSV(e) {
          if (e.type.indexOf("touch") === -1) {
            e.preventDefault();
          }
          var fieldRect = _this.__saturation_field.getBoundingClientRect();
          var _ref = e.touches && e.touches[0] || e, clientX = _ref.clientX, clientY = _ref.clientY;
          var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
          var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
          if (v > 1) {
            v = 1;
          } else if (v < 0) {
            v = 0;
          }
          if (s > 1) {
            s = 1;
          } else if (s < 0) {
            s = 0;
          }
          _this.__color.v = v;
          _this.__color.s = s;
          _this.setValue(_this.__color.toOriginal());
          return false;
        }
        function setH(e) {
          if (e.type.indexOf("touch") === -1) {
            e.preventDefault();
          }
          var fieldRect = _this.__hue_field.getBoundingClientRect();
          var _ref2 = e.touches && e.touches[0] || e, clientY = _ref2.clientY;
          var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
          if (h > 1) {
            h = 1;
          } else if (h < 0) {
            h = 0;
          }
          _this.__color.h = h * 360;
          _this.setValue(_this.__color.toOriginal());
          return false;
        }
        return _this2;
      }
      createClass(ColorController2, [{
        key: "updateDisplay",
        value: function updateDisplay2() {
          var i = interpret(this.getValue());
          if (i !== false) {
            var mismatch = false;
            Common.each(Color.COMPONENTS, function(component) {
              if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {};
              }
            }, this);
            if (mismatch) {
              Common.extend(this.__color.__state, i);
            }
          }
          Common.extend(this.__temp.__state, this.__color.__state);
          this.__temp.a = 1;
          var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
          var _flip = 255 - flip;
          Common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + "px",
            marginTop: 100 * (1 - this.__color.v) - 7 + "px",
            backgroundColor: this.__temp.toHexString(),
            border: this.__field_knob_border + "rgb(" + flip + "," + flip + "," + flip + ")"
          });
          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px";
          this.__temp.s = 1;
          this.__temp.v = 1;
          linearGradient(this.__saturation_field, "left", "#fff", this.__temp.toHexString());
          this.__input.value = this.__color.toString();
          Common.extend(this.__input.style, {
            backgroundColor: this.__color.toHexString(),
            color: "rgb(" + flip + "," + flip + "," + flip + ")",
            textShadow: this.__input_textShadow + "rgba(" + _flip + "," + _flip + "," + _flip + ",.7)"
          });
        }
      }]);
      return ColorController2;
    }(Controller);
    var vendors = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
    function linearGradient(elem, x, a, b) {
      elem.style.background = "";
      Common.each(vendors, function(vendor) {
        elem.style.cssText += "background: " + vendor + "linear-gradient(" + x + ", " + a + " 0%, " + b + " 100%); ";
      });
    }
    function hueGradient(elem) {
      elem.style.background = "";
      elem.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);";
      elem.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
      elem.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
      elem.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
      elem.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    }
    var css = {
      load: function load(url, indoc) {
        var doc = indoc || document;
        var link = doc.createElement("link");
        link.type = "text/css";
        link.rel = "stylesheet";
        link.href = url;
        doc.getElementsByTagName("head")[0].appendChild(link);
      },
      inject: function inject(cssContent, indoc) {
        var doc = indoc || document;
        var injected = document.createElement("style");
        injected.type = "text/css";
        injected.innerHTML = cssContent;
        var head = doc.getElementsByTagName("head")[0];
        try {
          head.appendChild(injected);
        } catch (e) {
        }
      }
    };
    var saveDialogContents = `<div id="dg-save" class="dg dialogue">
  
    Here's the new load parameter for your <code>GUI</code>'s constructor:
  
    <textarea id="dg-new-constructor"></textarea>
  
    <div id="dg-save-locally">
  
      <input id="dg-local-storage" type="checkbox"/> Automatically save
      values to <code>localStorage</code> on exit.
  
      <div id="dg-local-explain">The values saved to <code>localStorage</code> will
        override those passed to <code>dat.GUI</code>'s constructor. This makes it
        easier to work incrementally, but <code>localStorage</code> is fragile,
        and your friends may not see the same values you do.
  
      </div>
  
    </div>
  
  </div>`;
    var ControllerFactory = function ControllerFactory2(object, property) {
      var initialValue = object[property];
      if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
        return new OptionController(object, property, arguments[2]);
      }
      if (Common.isNumber(initialValue)) {
        if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
          if (Common.isNumber(arguments[4])) {
            return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
          }
          return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
        }
        if (Common.isNumber(arguments[4])) {
          return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
        }
        return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
      }
      if (Common.isString(initialValue)) {
        return new StringController(object, property);
      }
      if (Common.isFunction(initialValue)) {
        return new FunctionController(object, property, "");
      }
      if (Common.isBoolean(initialValue)) {
        return new BooleanController(object, property);
      }
      return null;
    };
    function requestAnimationFrame2(callback) {
      setTimeout(callback, 1e3 / 60);
    }
    var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame2;
    var CenteredDiv = function() {
      function CenteredDiv2() {
        classCallCheck(this, CenteredDiv2);
        this.backgroundElement = document.createElement("div");
        Common.extend(this.backgroundElement.style, {
          backgroundColor: "rgba(0,0,0,0.8)",
          top: 0,
          left: 0,
          display: "none",
          zIndex: "1000",
          opacity: 0,
          WebkitTransition: "opacity 0.2s linear",
          transition: "opacity 0.2s linear"
        });
        dom.makeFullscreen(this.backgroundElement);
        this.backgroundElement.style.position = "fixed";
        this.domElement = document.createElement("div");
        Common.extend(this.domElement.style, {
          position: "fixed",
          display: "none",
          zIndex: "1001",
          opacity: 0,
          WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
          transition: "transform 0.2s ease-out, opacity 0.2s linear"
        });
        document.body.appendChild(this.backgroundElement);
        document.body.appendChild(this.domElement);
        var _this = this;
        dom.bind(this.backgroundElement, "click", function() {
          _this.hide();
        });
      }
      createClass(CenteredDiv2, [{
        key: "show",
        value: function show2() {
          var _this = this;
          this.backgroundElement.style.display = "block";
          this.domElement.style.display = "block";
          this.domElement.style.opacity = 0;
          this.domElement.style.webkitTransform = "scale(1.1)";
          this.layout();
          Common.defer(function() {
            _this.backgroundElement.style.opacity = 1;
            _this.domElement.style.opacity = 1;
            _this.domElement.style.webkitTransform = "scale(1)";
          });
        }
      }, {
        key: "hide",
        value: function hide3() {
          var _this = this;
          var hide4 = function hide5() {
            _this.domElement.style.display = "none";
            _this.backgroundElement.style.display = "none";
            dom.unbind(_this.domElement, "webkitTransitionEnd", hide5);
            dom.unbind(_this.domElement, "transitionend", hide5);
            dom.unbind(_this.domElement, "oTransitionEnd", hide5);
          };
          dom.bind(this.domElement, "webkitTransitionEnd", hide4);
          dom.bind(this.domElement, "transitionend", hide4);
          dom.bind(this.domElement, "oTransitionEnd", hide4);
          this.backgroundElement.style.opacity = 0;
          this.domElement.style.opacity = 0;
          this.domElement.style.webkitTransform = "scale(1.1)";
        }
      }, {
        key: "layout",
        value: function layout() {
          this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + "px";
          this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + "px";
        }
      }]);
      return CenteredDiv2;
    }();
    var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
    css.inject(styleSheet);
    var CSS_NAMESPACE = "dg";
    var HIDE_KEY_CODE = 72;
    var CLOSE_BUTTON_HEIGHT = 20;
    var DEFAULT_DEFAULT_PRESET_NAME = "Default";
    var SUPPORTS_LOCAL_STORAGE = function() {
      try {
        return !!window.localStorage;
      } catch (e) {
        return false;
      }
    }();
    var SAVE_DIALOGUE = void 0;
    var autoPlaceVirgin = true;
    var autoPlaceContainer = void 0;
    var hide = false;
    var hideableGuis = [];
    var GUI = function GUI2(pars) {
      var _this = this;
      var params = pars || {};
      this.domElement = document.createElement("div");
      this.__ul = document.createElement("ul");
      this.domElement.appendChild(this.__ul);
      dom.addClass(this.domElement, CSS_NAMESPACE);
      this.__folders = {};
      this.__controllers = [];
      this.__rememberedObjects = [];
      this.__rememberedObjectIndecesToControllers = [];
      this.__listening = [];
      params = Common.defaults(params, {
        closeOnTop: false,
        autoPlace: true,
        width: GUI2.DEFAULT_WIDTH
      });
      params = Common.defaults(params, {
        resizable: params.autoPlace,
        hideable: params.autoPlace
      });
      if (!Common.isUndefined(params.load)) {
        if (params.preset) {
          params.load.preset = params.preset;
        }
      } else {
        params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
      }
      if (Common.isUndefined(params.parent) && params.hideable) {
        hideableGuis.push(this);
      }
      params.resizable = Common.isUndefined(params.parent) && params.resizable;
      if (params.autoPlace && Common.isUndefined(params.scrollable)) {
        params.scrollable = true;
      }
      var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, "isLocal")) === "true";
      var saveToLocalStorage = void 0;
      var titleRow = void 0;
      Object.defineProperties(this, {
        parent: {
          get: function get$$13() {
            return params.parent;
          }
        },
        scrollable: {
          get: function get$$13() {
            return params.scrollable;
          }
        },
        autoPlace: {
          get: function get$$13() {
            return params.autoPlace;
          }
        },
        closeOnTop: {
          get: function get$$13() {
            return params.closeOnTop;
          }
        },
        preset: {
          get: function get$$13() {
            if (_this.parent) {
              return _this.getRoot().preset;
            }
            return params.load.preset;
          },
          set: function set$$13(v) {
            if (_this.parent) {
              _this.getRoot().preset = v;
            } else {
              params.load.preset = v;
            }
            setPresetSelectIndex(this);
            _this.revert();
          }
        },
        width: {
          get: function get$$13() {
            return params.width;
          },
          set: function set$$13(v) {
            params.width = v;
            setWidth(_this, v);
          }
        },
        name: {
          get: function get$$13() {
            return params.name;
          },
          set: function set$$13(v) {
            params.name = v;
            if (titleRow) {
              titleRow.innerHTML = params.name;
            }
          }
        },
        closed: {
          get: function get$$13() {
            return params.closed;
          },
          set: function set$$13(v) {
            params.closed = v;
            if (params.closed) {
              dom.addClass(_this.__ul, GUI2.CLASS_CLOSED);
            } else {
              dom.removeClass(_this.__ul, GUI2.CLASS_CLOSED);
            }
            this.onResize();
            if (_this.__closeButton) {
              _this.__closeButton.innerHTML = v ? GUI2.TEXT_OPEN : GUI2.TEXT_CLOSED;
            }
          }
        },
        load: {
          get: function get$$13() {
            return params.load;
          }
        },
        useLocalStorage: {
          get: function get$$13() {
            return useLocalStorage;
          },
          set: function set$$13(bool) {
            if (SUPPORTS_LOCAL_STORAGE) {
              useLocalStorage = bool;
              if (bool) {
                dom.bind(window, "unload", saveToLocalStorage);
              } else {
                dom.unbind(window, "unload", saveToLocalStorage);
              }
              localStorage.setItem(getLocalStorageHash(_this, "isLocal"), bool);
            }
          }
        }
      });
      if (Common.isUndefined(params.parent)) {
        this.closed = params.closed || false;
        dom.addClass(this.domElement, GUI2.CLASS_MAIN);
        dom.makeSelectable(this.domElement, false);
        if (SUPPORTS_LOCAL_STORAGE) {
          if (useLocalStorage) {
            _this.useLocalStorage = true;
            var savedGui = localStorage.getItem(getLocalStorageHash(this, "gui"));
            if (savedGui) {
              params.load = JSON.parse(savedGui);
            }
          }
        }
        this.__closeButton = document.createElement("div");
        this.__closeButton.innerHTML = GUI2.TEXT_CLOSED;
        dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BUTTON);
        if (params.closeOnTop) {
          dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_TOP);
          this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
        } else {
          dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BOTTOM);
          this.domElement.appendChild(this.__closeButton);
        }
        dom.bind(this.__closeButton, "click", function() {
          _this.closed = !_this.closed;
        });
      } else {
        if (params.closed === void 0) {
          params.closed = true;
        }
        var titleRowName = document.createTextNode(params.name);
        dom.addClass(titleRowName, "controller-name");
        titleRow = addRow(_this, titleRowName);
        var onClickTitle = function onClickTitle2(e) {
          e.preventDefault();
          _this.closed = !_this.closed;
          return false;
        };
        dom.addClass(this.__ul, GUI2.CLASS_CLOSED);
        dom.addClass(titleRow, "title");
        dom.bind(titleRow, "click", onClickTitle);
        if (!params.closed) {
          this.closed = false;
        }
      }
      if (params.autoPlace) {
        if (Common.isUndefined(params.parent)) {
          if (autoPlaceVirgin) {
            autoPlaceContainer = document.createElement("div");
            dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
            dom.addClass(autoPlaceContainer, GUI2.CLASS_AUTO_PLACE_CONTAINER);
            document.body.appendChild(autoPlaceContainer);
            autoPlaceVirgin = false;
          }
          autoPlaceContainer.appendChild(this.domElement);
          dom.addClass(this.domElement, GUI2.CLASS_AUTO_PLACE);
        }
        if (!this.parent) {
          setWidth(_this, params.width);
        }
      }
      this.__resizeHandler = function() {
        _this.onResizeDebounced();
      };
      dom.bind(window, "resize", this.__resizeHandler);
      dom.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler);
      dom.bind(this.__ul, "transitionend", this.__resizeHandler);
      dom.bind(this.__ul, "oTransitionEnd", this.__resizeHandler);
      this.onResize();
      if (params.resizable) {
        addResizeHandle(this);
      }
      saveToLocalStorage = function saveToLocalStorage2() {
        if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, "isLocal")) === "true") {
          localStorage.setItem(getLocalStorageHash(_this, "gui"), JSON.stringify(_this.getSaveObject()));
        }
      };
      this.saveToLocalStorageIfPossible = saveToLocalStorage;
      function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        Common.defer(function() {
          root.width -= 1;
        });
      }
      if (!params.parent) {
        resetWidth();
      }
    };
    GUI.toggleHide = function() {
      hide = !hide;
      Common.each(hideableGuis, function(gui2) {
        gui2.domElement.style.display = hide ? "none" : "";
      });
    };
    GUI.CLASS_AUTO_PLACE = "a";
    GUI.CLASS_AUTO_PLACE_CONTAINER = "ac";
    GUI.CLASS_MAIN = "main";
    GUI.CLASS_CONTROLLER_ROW = "cr";
    GUI.CLASS_TOO_TALL = "taller-than-window";
    GUI.CLASS_CLOSED = "closed";
    GUI.CLASS_CLOSE_BUTTON = "close-button";
    GUI.CLASS_CLOSE_TOP = "close-top";
    GUI.CLASS_CLOSE_BOTTOM = "close-bottom";
    GUI.CLASS_DRAG = "drag";
    GUI.DEFAULT_WIDTH = 245;
    GUI.TEXT_CLOSED = "Close Controls";
    GUI.TEXT_OPEN = "Open Controls";
    GUI._keydownHandler = function(e) {
      if (document.activeElement.type !== "text" && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
        GUI.toggleHide();
      }
    };
    dom.bind(window, "keydown", GUI._keydownHandler, false);
    Common.extend(GUI.prototype, {
      add: function add3(object, property) {
        return _add(this, object, property, {
          factoryArgs: Array.prototype.slice.call(arguments, 2)
        });
      },
      addColor: function addColor(object, property) {
        return _add(this, object, property, {
          color: true
        });
      },
      remove: function remove(controller) {
        this.__ul.removeChild(controller.__li);
        this.__controllers.splice(this.__controllers.indexOf(controller), 1);
        var _this = this;
        Common.defer(function() {
          _this.onResize();
        });
      },
      destroy: function destroy() {
        if (this.parent) {
          throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
        }
        if (this.autoPlace) {
          autoPlaceContainer.removeChild(this.domElement);
        }
        var _this = this;
        Common.each(this.__folders, function(subfolder) {
          _this.removeFolder(subfolder);
        });
        dom.unbind(window, "keydown", GUI._keydownHandler, false);
        removeListeners(this);
      },
      addFolder: function addFolder(name) {
        if (this.__folders[name] !== void 0) {
          throw new Error('You already have a folder in this GUI by the name "' + name + '"');
        }
        var newGuiParams = { name, parent: this };
        newGuiParams.autoPlace = this.autoPlace;
        if (this.load && this.load.folders && this.load.folders[name]) {
          newGuiParams.closed = this.load.folders[name].closed;
          newGuiParams.load = this.load.folders[name];
        }
        var gui2 = new GUI(newGuiParams);
        this.__folders[name] = gui2;
        var li = addRow(this, gui2.domElement);
        dom.addClass(li, "folder");
        return gui2;
      },
      removeFolder: function removeFolder(folder) {
        this.__ul.removeChild(folder.domElement.parentElement);
        delete this.__folders[folder.name];
        if (this.load && this.load.folders && this.load.folders[folder.name]) {
          delete this.load.folders[folder.name];
        }
        removeListeners(folder);
        var _this = this;
        Common.each(folder.__folders, function(subfolder) {
          folder.removeFolder(subfolder);
        });
        Common.defer(function() {
          _this.onResize();
        });
      },
      open: function open() {
        this.closed = false;
      },
      close: function close() {
        this.closed = true;
      },
      hide: function hide2() {
        this.domElement.style.display = "none";
      },
      show: function show() {
        this.domElement.style.display = "";
      },
      onResize: function onResize() {
        var root = this.getRoot();
        if (root.scrollable) {
          var top = dom.getOffset(root.__ul).top;
          var h = 0;
          Common.each(root.__ul.childNodes, function(node) {
            if (!(root.autoPlace && node === root.__save_row)) {
              h += dom.getHeight(node);
            }
          });
          if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
            dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
            root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + "px";
          } else {
            dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
            root.__ul.style.height = "auto";
          }
        }
        if (root.__resize_handle) {
          Common.defer(function() {
            root.__resize_handle.style.height = root.__ul.offsetHeight + "px";
          });
        }
        if (root.__closeButton) {
          root.__closeButton.style.width = root.width + "px";
        }
      },
      onResizeDebounced: Common.debounce(function() {
        this.onResize();
      }, 50),
      remember: function remember() {
        if (Common.isUndefined(SAVE_DIALOGUE)) {
          SAVE_DIALOGUE = new CenteredDiv();
          SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
        }
        if (this.parent) {
          throw new Error("You can only call remember on a top level GUI.");
        }
        var _this = this;
        Common.each(Array.prototype.slice.call(arguments), function(object) {
          if (_this.__rememberedObjects.length === 0) {
            addSaveMenu(_this);
          }
          if (_this.__rememberedObjects.indexOf(object) === -1) {
            _this.__rememberedObjects.push(object);
          }
        });
        if (this.autoPlace) {
          setWidth(this, this.width);
        }
      },
      getRoot: function getRoot() {
        var gui2 = this;
        while (gui2.parent) {
          gui2 = gui2.parent;
        }
        return gui2;
      },
      getSaveObject: function getSaveObject() {
        var toReturn2 = this.load;
        toReturn2.closed = this.closed;
        if (this.__rememberedObjects.length > 0) {
          toReturn2.preset = this.preset;
          if (!toReturn2.remembered) {
            toReturn2.remembered = {};
          }
          toReturn2.remembered[this.preset] = getCurrentPreset(this);
        }
        toReturn2.folders = {};
        Common.each(this.__folders, function(element, key) {
          toReturn2.folders[key] = element.getSaveObject();
        });
        return toReturn2;
      },
      save: function save() {
        if (!this.load.remembered) {
          this.load.remembered = {};
        }
        this.load.remembered[this.preset] = getCurrentPreset(this);
        markPresetModified(this, false);
        this.saveToLocalStorageIfPossible();
      },
      saveAs: function saveAs(presetName) {
        if (!this.load.remembered) {
          this.load.remembered = {};
          this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
        }
        this.load.remembered[presetName] = getCurrentPreset(this);
        this.preset = presetName;
        addPresetOption(this, presetName, true);
        this.saveToLocalStorageIfPossible();
      },
      revert: function revert(gui2) {
        Common.each(this.__controllers, function(controller) {
          if (!this.getRoot().load.remembered) {
            controller.setValue(controller.initialValue);
          } else {
            recallSavedValue(gui2 || this.getRoot(), controller);
          }
          if (controller.__onFinishChange) {
            controller.__onFinishChange.call(controller, controller.getValue());
          }
        }, this);
        Common.each(this.__folders, function(folder) {
          folder.revert(folder);
        });
        if (!gui2) {
          markPresetModified(this.getRoot(), false);
        }
      },
      listen: function listen(controller) {
        var init = this.__listening.length === 0;
        this.__listening.push(controller);
        if (init) {
          updateDisplays(this.__listening);
        }
      },
      updateDisplay: function updateDisplay() {
        Common.each(this.__controllers, function(controller) {
          controller.updateDisplay();
        });
        Common.each(this.__folders, function(folder) {
          folder.updateDisplay();
        });
      }
    });
    function addRow(gui2, newDom, liBefore) {
      var li = document.createElement("li");
      if (newDom) {
        li.appendChild(newDom);
      }
      if (liBefore) {
        gui2.__ul.insertBefore(li, liBefore);
      } else {
        gui2.__ul.appendChild(li);
      }
      gui2.onResize();
      return li;
    }
    function removeListeners(gui2) {
      dom.unbind(window, "resize", gui2.__resizeHandler);
      if (gui2.saveToLocalStorageIfPossible) {
        dom.unbind(window, "unload", gui2.saveToLocalStorageIfPossible);
      }
    }
    function markPresetModified(gui2, modified) {
      var opt = gui2.__preset_select[gui2.__preset_select.selectedIndex];
      if (modified) {
        opt.innerHTML = opt.value + "*";
      } else {
        opt.innerHTML = opt.value;
      }
    }
    function augmentController(gui2, li, controller) {
      controller.__li = li;
      controller.__gui = gui2;
      Common.extend(controller, {
        options: function options(_options) {
          if (arguments.length > 1) {
            var nextSibling = controller.__li.nextElementSibling;
            controller.remove();
            return _add(gui2, controller.object, controller.property, {
              before: nextSibling,
              factoryArgs: [Common.toArray(arguments)]
            });
          }
          if (Common.isArray(_options) || Common.isObject(_options)) {
            var _nextSibling = controller.__li.nextElementSibling;
            controller.remove();
            return _add(gui2, controller.object, controller.property, {
              before: _nextSibling,
              factoryArgs: [_options]
            });
          }
        },
        name: function name(_name) {
          controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
          return controller;
        },
        listen: function listen2() {
          controller.__gui.listen(controller);
          return controller;
        },
        remove: function remove2() {
          controller.__gui.remove(controller);
          return controller;
        }
      });
      if (controller instanceof NumberControllerSlider) {
        var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
        Common.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(method) {
          var pc = controller[method];
          var pb = box[method];
          controller[method] = box[method] = function() {
            var args = Array.prototype.slice.call(arguments);
            pb.apply(box, args);
            return pc.apply(controller, args);
          };
        });
        dom.addClass(li, "has-slider");
        controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
      } else if (controller instanceof NumberControllerBox) {
        var r = function r2(returned) {
          if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
            var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
            var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
            controller.remove();
            var newController = _add(gui2, controller.object, controller.property, {
              before: controller.__li.nextElementSibling,
              factoryArgs: [controller.__min, controller.__max, controller.__step]
            });
            newController.name(oldName);
            if (wasListening)
              newController.listen();
            return newController;
          }
          return returned;
        };
        controller.min = Common.compose(r, controller.min);
        controller.max = Common.compose(r, controller.max);
      } else if (controller instanceof BooleanController) {
        dom.bind(li, "click", function() {
          dom.fakeEvent(controller.__checkbox, "click");
        });
        dom.bind(controller.__checkbox, "click", function(e) {
          e.stopPropagation();
        });
      } else if (controller instanceof FunctionController) {
        dom.bind(li, "click", function() {
          dom.fakeEvent(controller.__button, "click");
        });
        dom.bind(li, "mouseover", function() {
          dom.addClass(controller.__button, "hover");
        });
        dom.bind(li, "mouseout", function() {
          dom.removeClass(controller.__button, "hover");
        });
      } else if (controller instanceof ColorController) {
        dom.addClass(li, "color");
        controller.updateDisplay = Common.compose(function(val) {
          li.style.borderLeftColor = controller.__color.toString();
          return val;
        }, controller.updateDisplay);
        controller.updateDisplay();
      }
      controller.setValue = Common.compose(function(val) {
        if (gui2.getRoot().__preset_select && controller.isModified()) {
          markPresetModified(gui2.getRoot(), true);
        }
        return val;
      }, controller.setValue);
    }
    function recallSavedValue(gui2, controller) {
      var root = gui2.getRoot();
      var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
      if (matchedIndex !== -1) {
        var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
        if (controllerMap === void 0) {
          controllerMap = {};
          root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
        }
        controllerMap[controller.property] = controller;
        if (root.load && root.load.remembered) {
          var presetMap = root.load.remembered;
          var preset = void 0;
          if (presetMap[gui2.preset]) {
            preset = presetMap[gui2.preset];
          } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
            preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
          } else {
            return;
          }
          if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== void 0) {
            var value = preset[matchedIndex][controller.property];
            controller.initialValue = value;
            controller.setValue(value);
          }
        }
      }
    }
    function _add(gui2, object, property, params) {
      if (object[property] === void 0) {
        throw new Error('Object "' + object + '" has no property "' + property + '"');
      }
      var controller = void 0;
      if (params.color) {
        controller = new ColorController(object, property);
      } else {
        var factoryArgs = [object, property].concat(params.factoryArgs);
        controller = ControllerFactory.apply(gui2, factoryArgs);
      }
      if (params.before instanceof Controller) {
        params.before = params.before.__li;
      }
      recallSavedValue(gui2, controller);
      dom.addClass(controller.domElement, "c");
      var name = document.createElement("span");
      dom.addClass(name, "property-name");
      name.innerHTML = controller.property;
      var container = document.createElement("div");
      container.appendChild(name);
      container.appendChild(controller.domElement);
      var li = addRow(gui2, container, params.before);
      dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
      if (controller instanceof ColorController) {
        dom.addClass(li, "color");
      } else {
        dom.addClass(li, _typeof(controller.getValue()));
      }
      augmentController(gui2, li, controller);
      gui2.__controllers.push(controller);
      return controller;
    }
    function getLocalStorageHash(gui2, key) {
      return document.location.href + "." + key;
    }
    function addPresetOption(gui2, name, setSelected) {
      var opt = document.createElement("option");
      opt.innerHTML = name;
      opt.value = name;
      gui2.__preset_select.appendChild(opt);
      if (setSelected) {
        gui2.__preset_select.selectedIndex = gui2.__preset_select.length - 1;
      }
    }
    function showHideExplain(gui2, explain) {
      explain.style.display = gui2.useLocalStorage ? "block" : "none";
    }
    function addSaveMenu(gui2) {
      var div2 = gui2.__save_row = document.createElement("li");
      dom.addClass(gui2.domElement, "has-save");
      gui2.__ul.insertBefore(div2, gui2.__ul.firstChild);
      dom.addClass(div2, "save-row");
      var gears = document.createElement("span");
      gears.innerHTML = "&nbsp;";
      dom.addClass(gears, "button gears");
      var button = document.createElement("span");
      button.innerHTML = "Save";
      dom.addClass(button, "button");
      dom.addClass(button, "save");
      var button2 = document.createElement("span");
      button2.innerHTML = "New";
      dom.addClass(button2, "button");
      dom.addClass(button2, "save-as");
      var button3 = document.createElement("span");
      button3.innerHTML = "Revert";
      dom.addClass(button3, "button");
      dom.addClass(button3, "revert");
      var select2 = gui2.__preset_select = document.createElement("select");
      if (gui2.load && gui2.load.remembered) {
        Common.each(gui2.load.remembered, function(value, key) {
          addPresetOption(gui2, key, key === gui2.preset);
        });
      } else {
        addPresetOption(gui2, DEFAULT_DEFAULT_PRESET_NAME, false);
      }
      dom.bind(select2, "change", function() {
        for (var index2 = 0; index2 < gui2.__preset_select.length; index2++) {
          gui2.__preset_select[index2].innerHTML = gui2.__preset_select[index2].value;
        }
        gui2.preset = this.value;
      });
      div2.appendChild(select2);
      div2.appendChild(gears);
      div2.appendChild(button);
      div2.appendChild(button2);
      div2.appendChild(button3);
      if (SUPPORTS_LOCAL_STORAGE) {
        var explain = document.getElementById("dg-local-explain");
        var localStorageCheckBox = document.getElementById("dg-local-storage");
        var saveLocally = document.getElementById("dg-save-locally");
        saveLocally.style.display = "block";
        if (localStorage.getItem(getLocalStorageHash(gui2, "isLocal")) === "true") {
          localStorageCheckBox.setAttribute("checked", "checked");
        }
        showHideExplain(gui2, explain);
        dom.bind(localStorageCheckBox, "change", function() {
          gui2.useLocalStorage = !gui2.useLocalStorage;
          showHideExplain(gui2, explain);
        });
      }
      var newConstructorTextArea = document.getElementById("dg-new-constructor");
      dom.bind(newConstructorTextArea, "keydown", function(e) {
        if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
          SAVE_DIALOGUE.hide();
        }
      });
      dom.bind(gears, "click", function() {
        newConstructorTextArea.innerHTML = JSON.stringify(gui2.getSaveObject(), void 0, 2);
        SAVE_DIALOGUE.show();
        newConstructorTextArea.focus();
        newConstructorTextArea.select();
      });
      dom.bind(button, "click", function() {
        gui2.save();
      });
      dom.bind(button2, "click", function() {
        var presetName = prompt("Enter a new preset name.");
        if (presetName) {
          gui2.saveAs(presetName);
        }
      });
      dom.bind(button3, "click", function() {
        gui2.revert();
      });
    }
    function addResizeHandle(gui2) {
      var pmouseX = void 0;
      gui2.__resize_handle = document.createElement("div");
      Common.extend(gui2.__resize_handle.style, {
        width: "6px",
        marginLeft: "-3px",
        height: "200px",
        cursor: "ew-resize",
        position: "absolute"
      });
      function drag(e) {
        e.preventDefault();
        gui2.width += pmouseX - e.clientX;
        gui2.onResize();
        pmouseX = e.clientX;
        return false;
      }
      function dragStop() {
        dom.removeClass(gui2.__closeButton, GUI.CLASS_DRAG);
        dom.unbind(window, "mousemove", drag);
        dom.unbind(window, "mouseup", dragStop);
      }
      function dragStart(e) {
        e.preventDefault();
        pmouseX = e.clientX;
        dom.addClass(gui2.__closeButton, GUI.CLASS_DRAG);
        dom.bind(window, "mousemove", drag);
        dom.bind(window, "mouseup", dragStop);
        return false;
      }
      dom.bind(gui2.__resize_handle, "mousedown", dragStart);
      dom.bind(gui2.__closeButton, "mousedown", dragStart);
      gui2.domElement.insertBefore(gui2.__resize_handle, gui2.domElement.firstElementChild);
    }
    function setWidth(gui2, w) {
      gui2.domElement.style.width = w + "px";
      if (gui2.__save_row && gui2.autoPlace) {
        gui2.__save_row.style.width = w + "px";
      }
      if (gui2.__closeButton) {
        gui2.__closeButton.style.width = w + "px";
      }
    }
    function getCurrentPreset(gui2, useInitialValues) {
      var toReturn2 = {};
      Common.each(gui2.__rememberedObjects, function(val, index2) {
        var savedValues = {};
        var controllerMap = gui2.__rememberedObjectIndecesToControllers[index2];
        Common.each(controllerMap, function(controller, property) {
          savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
        });
        toReturn2[index2] = savedValues;
      });
      return toReturn2;
    }
    function setPresetSelectIndex(gui2) {
      for (var index2 = 0; index2 < gui2.__preset_select.length; index2++) {
        if (gui2.__preset_select[index2].value === gui2.preset) {
          gui2.__preset_select.selectedIndex = index2;
        }
      }
    }
    function updateDisplays(controllerArray) {
      if (controllerArray.length !== 0) {
        requestAnimationFrame$1.call(window, function() {
          updateDisplays(controllerArray);
        });
      }
      Common.each(controllerArray, function(c) {
        c.updateDisplay();
      });
    }
    var color = {
      Color,
      math: ColorMath,
      interpret
    };
    var controllers = {
      Controller,
      BooleanController,
      OptionController,
      StringController,
      NumberController,
      NumberControllerBox,
      NumberControllerSlider,
      FunctionController,
      ColorController
    };
    var dom$1 = { dom };
    var gui = { GUI };
    var GUI$1 = GUI;
    var index = {
      color,
      controllers,
      dom: dom$1,
      gui,
      GUI: GUI$1
    };
    var dat_gui_module_default = index;
  
    // index.js
    var import_stats = __toModule(require_stats_min());
  
    // node_modules/@tensorflow-models/posenet/dist/posenet.esm.js
    var import_tfjs_core249 = __toModule(require_tf_core_node());
    var import_tfjs_converter = __toModule(require_tf_converter_node());
    var extendStatics = function(e, t) {
      return (extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t2) {
        e2.__proto__ = t2;
      } || function(e2, t2) {
        for (var n in t2)
          t2.hasOwnProperty(n) && (e2[n] = t2[n]);
      })(e, t);
    };
    function __extends(e, t) {
      function n() {
        this.constructor = e;
      }
      extendStatics(e, t), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
    }
    var __assign = function() {
      return (__assign = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
          for (var o in t = arguments[n])
            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e;
      }).apply(this, arguments);
    };
    function __awaiter(e, t, n, r) {
      return new (n || (n = Promise))(function(o, i) {
        function s(e2) {
          try {
            a(r.next(e2));
          } catch (e3) {
            i(e3);
          }
        }
        function u(e2) {
          try {
            a(r.throw(e2));
          } catch (e3) {
            i(e3);
          }
        }
        function a(e2) {
          e2.done ? o(e2.value) : new n(function(t2) {
            t2(e2.value);
          }).then(s, u);
        }
        a((r = r.apply(e, t || [])).next());
      });
    }
    function __generator(e, t) {
      var n, r, o, i, s = { label: 0, sent: function() {
        if (1 & o[0])
          throw o[1];
        return o[1];
      }, trys: [], ops: [] };
      return i = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
        return this;
      }), i;
      function u(i2) {
        return function(u2) {
          return function(i3) {
            if (n)
              throw new TypeError("Generator is already executing.");
            for (; s; )
              try {
                if (n = 1, r && (o = 2 & i3[0] ? r.return : i3[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i3[1])).done)
                  return o;
                switch (r = 0, o && (i3 = [2 & i3[0], o.value]), i3[0]) {
                  case 0:
                  case 1:
                    o = i3;
                    break;
                  case 4:
                    return s.label++, { value: i3[1], done: false };
                  case 5:
                    s.label++, r = i3[1], i3 = [0];
                    continue;
                  case 7:
                    i3 = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (i3[0] === 6 || i3[0] === 2)) {
                      s = 0;
                      continue;
                    }
                    if (i3[0] === 3 && (!o || i3[1] > o[0] && i3[1] < o[3])) {
                      s.label = i3[1];
                      break;
                    }
                    if (i3[0] === 6 && s.label < o[1]) {
                      s.label = o[1], o = i3;
                      break;
                    }
                    if (o && s.label < o[2]) {
                      s.label = o[2], s.ops.push(i3);
                      break;
                    }
                    o[2] && s.ops.pop(), s.trys.pop();
                    continue;
                }
                i3 = t.call(e, s);
              } catch (e2) {
                i3 = [6, e2], r = 0;
              } finally {
                n = o = 0;
              }
            if (5 & i3[0])
              throw i3[1];
            return { value: i3[0] ? i3[1] : void 0, done: true };
          }([i2, u2]);
        };
      }
    }
    var BaseModel = function() {
      function e(e2, t) {
        this.model = e2, this.outputStride = t;
        var n = this.model.inputs[0].shape;
        import_tfjs_core249.util.assert(n[1] === -1 && n[2] === -1, function() {
          return "Input shape [" + n[1] + ", " + n[2] + "] must both be equal to or -1";
        });
      }
      return e.prototype.predict = function(e2) {
        var t = this;
        return (0, import_tfjs_core249.tidy)(function() {
          var n = t.preprocessInput((0, import_tfjs_core249.cast)(e2, "float32")), r = (0, import_tfjs_core249.expandDims)(n, 0), o = t.model.predict(r).map(function(e3) {
            return (0, import_tfjs_core249.squeeze)(e3, [0]);
          }), i = t.nameOutputResults(o);
          return { heatmapScores: (0, import_tfjs_core249.sigmoid)(i.heatmap), offsets: i.offsets, displacementFwd: i.displacementFwd, displacementBwd: i.displacementBwd };
        });
      }, e.prototype.dispose = function() {
        this.model.dispose();
      }, e;
    }();
    var MobileNet = function(e) {
      function t() {
        return e !== null && e.apply(this, arguments) || this;
      }
      return __extends(t, e), t.prototype.preprocessInput = function(e2) {
        return (0, import_tfjs_core249.tidy)(function() {
          return (0, import_tfjs_core249.sub)((0, import_tfjs_core249.div)(e2, 127.5), 1);
        });
      }, t.prototype.nameOutputResults = function(e2) {
        return { offsets: e2[0], heatmap: e2[1], displacementFwd: e2[2], displacementBwd: e2[3] };
      }, t;
    }(BaseModel);
    function half(e) {
      return Math.floor(e / 2);
    }
    var MaxHeap = function() {
      function e(e2, t) {
        this.priorityQueue = new Array(e2), this.numberOfElements = -1, this.getElementValue = t;
      }
      return e.prototype.enqueue = function(e2) {
        this.priorityQueue[++this.numberOfElements] = e2, this.swim(this.numberOfElements);
      }, e.prototype.dequeue = function() {
        var e2 = this.priorityQueue[0];
        return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e2;
      }, e.prototype.empty = function() {
        return this.numberOfElements === -1;
      }, e.prototype.size = function() {
        return this.numberOfElements + 1;
      }, e.prototype.all = function() {
        return this.priorityQueue.slice(0, this.numberOfElements + 1);
      }, e.prototype.max = function() {
        return this.priorityQueue[0];
      }, e.prototype.swim = function(e2) {
        for (; e2 > 0 && this.less(half(e2), e2); )
          this.exchange(e2, half(e2)), e2 = half(e2);
      }, e.prototype.sink = function(e2) {
        for (; 2 * e2 <= this.numberOfElements; ) {
          var t = 2 * e2;
          if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e2, t))
            break;
          this.exchange(e2, t), e2 = t;
        }
      }, e.prototype.getValueAt = function(e2) {
        return this.getElementValue(this.priorityQueue[e2]);
      }, e.prototype.less = function(e2, t) {
        return this.getValueAt(e2) < this.getValueAt(t);
      }, e.prototype.exchange = function(e2, t) {
        var n = this.priorityQueue[e2];
        this.priorityQueue[e2] = this.priorityQueue[t], this.priorityQueue[t] = n;
      }, e;
    }();
    function scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {
      for (var s = i.shape, u = s[0], a = s[1], l = true, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), d = p; d < c; ++d) {
        for (var f = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = f; m < h; ++m)
          if (i.get(d, m, e) > t) {
            l = false;
            break;
          }
        if (!l)
          break;
      }
      return l;
    }
    function buildPartWithScoreQueue(e, t, n) {
      for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function(e2) {
        return e2.score;
      }), a = 0; a < o; ++a)
        for (var l = 0; l < i; ++l)
          for (var p = 0; p < s; ++p) {
            var c = n.get(a, l, p);
            c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({ score: c, part: { heatmapY: a, heatmapX: l, id: p } });
          }
      return u;
    }
    var partNames = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"];
    var NUM_KEYPOINTS = partNames.length;
    var partIds = partNames.reduce(function(e, t, n) {
      return e[t] = n, e;
    }, {});
    var connectedPartNames = [["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]];
    var poseChain = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]];
    var connectedPartIndices = connectedPartNames.map(function(e) {
      var t = e[0], n = e[1];
      return [partIds[t], partIds[n]];
    });
    function getOffsetPoint(e, t, n, r) {
      return { y: r.get(e, t, n), x: r.get(e, t, n + NUM_KEYPOINTS) };
    }
    function getImageCoords(e, t, n) {
      var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n), o = r.y, i = r.x;
      return { x: e.heatmapX * t + i, y: e.heatmapY * t + o };
    }
    function clamp2(e, t, n) {
      return e < t ? t : e > n ? n : e;
    }
    function squaredDistance(e, t, n, r) {
      var o = n - e, i = r - t;
      return o * o + i * i;
    }
    function addVectors(e, t) {
      return { x: e.x + t.x, y: e.y + t.y };
    }
    var parentChildrenTuples = poseChain.map(function(e) {
      var t = e[0], n = e[1];
      return [partIds[t], partIds[n]];
    });
    var parentToChildEdges = parentChildrenTuples.map(function(e) {
      return e[1];
    });
    var childToParentEdges = parentChildrenTuples.map(function(e) {
      return e[0];
    });
    function getDisplacement(e, t, n) {
      var r = n.shape[2] / 2;
      return { y: n.get(t.y, t.x, e), x: n.get(t.y, t.x, r + e) };
    }
    function getStridedIndexNearPoint(e, t, n, r) {
      return { y: clamp2(Math.round(e.y / t), 0, n - 1), x: clamp2(Math.round(e.x / t), 0, r - 1) };
    }
    function traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {
      u === void 0 && (u = 2);
      for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), d = addVectors(t.position, c), f = 0; f < u; f++) {
        var h = getStridedIndexNearPoint(d, i, l, p), m = getOffsetPoint(h.y, h.x, n, o);
        d = addVectors({ x: h.x * i, y: h.y * i }, { x: m.x, y: m.y });
      }
      var g = getStridedIndexNearPoint(d, i, l, p), _ = r.get(g.y, g.x, n);
      return { position: d, part: partNames[n], score: _ };
    }
    function decodePose(e, t, n, r, o, i) {
      var s = t.shape[2], u = parentToChildEdges.length, a = new Array(s), l = e.part, p = e.score, c = getImageCoords(l, r, n);
      a[l.id] = { score: p, part: partNames[l.id], position: c };
      for (var d = u - 1; d >= 0; --d) {
        var f = parentToChildEdges[d], h = childToParentEdges[d];
        a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, i));
      }
      for (d = 0; d < u; ++d) {
        f = childToParentEdges[d], h = parentToChildEdges[d];
        a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, o));
      }
      return a;
    }
    function withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {
      var o = n.x, i = n.y;
      return e.some(function(e2) {
        var n2 = e2.keypoints[r].position;
        return squaredDistance(i, o, n2.y, n2.x) <= t;
      });
    }
    function getInstanceScore(e, t, n) {
      return n.reduce(function(n2, r, o) {
        var i = r.position, s = r.score;
        return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n2 += s), n2;
      }, 0) / n.length;
    }
    var kLocalMaximumRadius = 1;
    function decodeMultiplePoses(e, t, n, r, o, i, s, u) {
      s === void 0 && (s = 0.5), u === void 0 && (u = 20);
      for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty(); ) {
        var c = l.dequeue();
        if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {
          var d = decodePose(c, e, t, o, n, r), f = getInstanceScore(a, p, d);
          a.push({ keypoints: d, score: f });
        }
      }
      return a;
    }
    function mod2(e, t) {
      return (0, import_tfjs_core249.tidy)(function() {
        var n = (0, import_tfjs_core249.div)(e, (0, import_tfjs_core249.scalar)(t, "int32"));
        return (0, import_tfjs_core249.sub)(e, (0, import_tfjs_core249.mul)(n, (0, import_tfjs_core249.scalar)(t, "int32")));
      });
    }
    function argmax2d(e) {
      var t = e.shape, n = t[0], r = t[1], o = t[2];
      return (0, import_tfjs_core249.tidy)(function() {
        var t2 = (0, import_tfjs_core249.reshape)(e, [n * r, o]), i = (0, import_tfjs_core249.argMax)(t2, 0), s = (0, import_tfjs_core249.expandDims)((0, import_tfjs_core249.div)(i, (0, import_tfjs_core249.scalar)(r, "int32")), 1), u = (0, import_tfjs_core249.expandDims)(mod2(i, r), 1);
        return (0, import_tfjs_core249.concat)([s, u], 1);
      });
    }
    function getPointsConfidence(e, t) {
      for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {
        var i = t.get(o, 0), s = t.get(o, 1);
        r[o] = e.get(i, s, o);
      }
      return r;
    }
    function getOffsetPoint$1(e, t, n, r) {
      return { y: r.get(e, t, n), x: r.get(e, t, n + NUM_KEYPOINTS) };
    }
    function getOffsetVectors(e, t) {
      for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {
        var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t), i = o.x, s = o.y;
        n.push(s), n.push(i);
      }
      return (0, import_tfjs_core249.tensor2d)(n, [NUM_KEYPOINTS, 2]);
    }
    function getOffsetPoints(e, t, n) {
      return (0, import_tfjs_core249.tidy)(function() {
        var r = getOffsetVectors(e, n);
        return (0, import_tfjs_core249.add)((0, import_tfjs_core249.cast)((0, import_tfjs_core249.mul)(e.toTensor(), (0, import_tfjs_core249.scalar)(t, "int32")), "float32"), r);
      });
    }
    function decodeSinglePose(e, t, n) {
      return __awaiter(this, void 0, void 0, function() {
        var r, o, i, s, u, a, l, p, c, d;
        return __generator(this, function(f) {
          switch (f.label) {
            case 0:
              return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];
            case 1:
              return i = f.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];
            case 2:
              return p = f.sent(), c = Array.from(getPointsConfidence(s, a)), d = c.map(function(e2, t2) {
                return r += e2, { position: { y: p.get(t2, 0), x: p.get(t2, 1) }, part: partNames[t2], score: e2 };
              }), o.dispose(), l.dispose(), [2, { keypoints: d, score: r / d.length }];
          }
        });
      });
    }
    var imageNetMean = [-123.15, -115.9, -103.06];
    var ResNet = function(e) {
      function t() {
        return e !== null && e.apply(this, arguments) || this;
      }
      return __extends(t, e), t.prototype.preprocessInput = function(e2) {
        return (0, import_tfjs_core249.add)(e2, imageNetMean);
      }, t.prototype.nameOutputResults = function(e2) {
        var t2 = e2[0], n = e2[1];
        return { offsets: e2[2], heatmap: e2[3], displacementFwd: t2, displacementBwd: n };
      }, t;
    }(BaseModel);
    function eitherPointDoesntMeetConfidence(e, t, n) {
      return e < n || t < n;
    }
    function getAdjacentKeyPoints(e, t) {
      return connectedPartIndices.reduce(function(n, r) {
        var o = r[0], i = r[1];
        return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);
      }, []);
    }
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
    var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    function toTensorBuffers3D(e) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t) {
          return [2, Promise.all(e.map(function(e2) {
            return e2.buffer();
          }))];
        });
      });
    }
    function scalePose(e, t, n, r, o) {
      return r === void 0 && (r = 0), o === void 0 && (o = 0), { score: e.score, keypoints: e.keypoints.map(function(e2) {
        var i = e2.score, s = e2.part, u = e2.position;
        return { score: i, part: s, position: { x: u.x * n + o, y: u.y * t + r } };
      }) };
    }
    function scalePoses(e, t, n, r, o) {
      return r === void 0 && (r = 0), o === void 0 && (o = 0), n === 1 && t === 1 && r === 0 && o === 0 ? e : e.map(function(e2) {
        return scalePose(e2, t, n, r, o);
      });
    }
    function flipPoseHorizontal(e, t) {
      return { score: e.score, keypoints: e.keypoints.map(function(e2) {
        var n = e2.score, r = e2.part, o = e2.position;
        return { score: n, part: r, position: { x: t - 1 - o.x, y: o.y } };
      }) };
    }
    function flipPosesHorizontal(e, t) {
      return t <= 0 ? e : e.map(function(e2) {
        return flipPoseHorizontal(e2, t);
      });
    }
    var VALID_OUTPUT_STRIDES = [8, 16, 32];
    function assertValidOutputStride(e) {
      import_tfjs_core249.util.assert(typeof e == "number", function() {
        return "outputStride is not a number";
      }), import_tfjs_core249.util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function() {
        return "outputStride of " + e + " is invalid. It must be either 8, 16, or 32";
      });
    }
    function isValidInputResolution(e, t) {
      return (e - 1) % t == 0;
    }
    function assertValidResolution(e, t) {
      import_tfjs_core249.util.assert(typeof e[0] == "number" && typeof e[1] == "number", function() {
        return "both resolution values must be a number but had values " + e;
      }), import_tfjs_core249.util.assert(isValidInputResolution(e[0], t), function() {
        return "height of " + e[0] + " is invalid for output stride " + t + ".";
      }), import_tfjs_core249.util.assert(isValidInputResolution(e[1], t), function() {
        return "width of " + e[1] + " is invalid for output stride " + t + ".";
      });
    }
    function getInputTensorDimensions(e) {
      return e instanceof import_tfjs_core249.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];
    }
    function toInputTensor(e) {
      return e instanceof import_tfjs_core249.Tensor ? e : import_tfjs_core249.browser.fromPixels(e);
    }
    function padAndResizeTo(e, t) {
      var n = t[0], r = t[1], o = getInputTensorDimensions(e), i = o[0], s = o[1], u = r / n, a = [0, 0, 0, 0], l = a[0], p = a[1], c = a[2], d = a[3];
      return s / i < u ? (l = 0, p = 0, c = Math.round(0.5 * (u * i - s)), d = Math.round(0.5 * (u * i - s))) : (l = Math.round(0.5 * (1 / u * s - i)), p = Math.round(0.5 * (1 / u * s - i)), c = 0, d = 0), { resized: (0, import_tfjs_core249.tidy)(function() {
        var t2 = toInputTensor(e);
        return t2 = (0, import_tfjs_core249.pad3d)(t2, [[l, p], [c, d], [0, 0]]), import_tfjs_core249.image.resizeBilinear(t2, [n, r]);
      }), padding: { top: l, left: c, right: d, bottom: p } };
    }
    function scaleAndFlipPoses(e, t, n, r, o) {
      var i = t[0], s = t[1], u = n[0], a = n[1], l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);
      return o ? flipPosesHorizontal(l, s) : l;
    }
    var SINGLE_PERSON_INFERENCE_CONFIG = { flipHorizontal: false };
    var MULTI_PERSON_INFERENCE_CONFIG = { flipHorizontal: false, maxDetections: 5, scoreThreshold: 0.5, nmsRadius: 20 };
    function validateMultiPersonInputConfig(e) {
      var t = e.maxDetections, n = e.scoreThreshold, r = e.nmsRadius;
      if (t <= 0)
        throw new Error("Invalid maxDetections " + t + ". Should be > 0");
      if (n < 0 || n > 1)
        throw new Error("Invalid scoreThreshold " + n + ". Should be in range [0.0, 1.0]");
      if (r <= 0)
        throw new Error("Invalid nmsRadius " + r + ".");
    }
    var PoseNet = function() {
      function e(e2, t) {
        assertValidOutputStride(e2.outputStride), assertValidResolution(t, e2.outputStride), this.baseModel = e2, this.inputResolution = t;
      }
      return e.prototype.estimateMultiplePoses = function(e2, t) {
        return t === void 0 && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
          var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _, I, v, y, E, b;
          return __generator(this, function(N) {
            switch (N.label) {
              case 0:
                return n = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e2), s = i[0], u = i[1], a = padAndResizeTo(e2, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([d, f, h, m])];
              case 1:
                return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];
              case 2:
                return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];
            }
          });
        });
      }, e.prototype.estimateSinglePose = function(e2, t) {
        return t === void 0 && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
          var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _;
          return __generator(this, function(I) {
            switch (I.label) {
              case 0:
                return n = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e2), s = i[0], u = i[1], a = padAndResizeTo(e2, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(d, f, r)];
              case 1:
                return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];
            }
          });
        });
      }, e.prototype.estimatePoses = function(e2, t) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(n) {
            switch (n.label) {
              case 0:
                return t.decodingMethod !== "single-person" ? [3, 2] : [4, this.estimateSinglePose(e2, t)];
              case 1:
                return [2, [n.sent()]];
              case 2:
                return [2, this.estimateMultiplePoses(e2, t)];
            }
          });
        });
      }, e.prototype.dispose = function() {
        this.baseModel.dispose();
      }, e;
    }();
  
    // demo_util.js
    var COLOR = "aqua";
    var LINE_WIDTH = 2;
    var TRY_RESNET_BUTTON_NAME = "tryResNetButton";
    var TRY_RESNET_BUTTON_TEXT = "[New] Try ResNet50";
    var TRY_RESNET_BUTTON_TEXT_CSS = "width:100%;text-decoration:underline;";
    var TRY_RESNET_BUTTON_BACKGROUND_CSS = "background:#e61d5f;";
    function setDatGuiPropertyCss(propertyText, liCssString, spanCssString = "") {
      var spans = document.getElementsByClassName("property-name");
      for (var i = 0; i < spans.length; i++) {
        var text = spans[i].textContent || spans[i].innerText;
        if (text == propertyText) {
          spans[i].parentNode.parentNode.style = liCssString;
          if (spanCssString !== "") {
            spans[i].style = spanCssString;
          }
        }
      }
    }
    function updateTryResNetButtonDatGuiCss() {
      setDatGuiPropertyCss(TRY_RESNET_BUTTON_TEXT, TRY_RESNET_BUTTON_BACKGROUND_CSS, TRY_RESNET_BUTTON_TEXT_CSS);
    }
    function toggleLoadingUI(showLoadingUI, loadingDivId = "loading", mainDivId = "main") {
      if (showLoadingUI) {
        document.getElementById(loadingDivId).style.display = "block";
        document.getElementById(mainDivId).style.display = "none";
      } else {
        document.getElementById(loadingDivId).style.display = "none";
        document.getElementById(mainDivId).style.display = "block";
      }
    }
    function drawPoint(ctx, y, x, r, color2) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI);
      ctx.fillStyle = color2;
      ctx.fill();
    }
    function drawSegment([ay, ax], [by, bx], color2, scale, ctx) {
      ctx.beginPath();
      ctx.moveTo(ax * scale, ay * scale);
      ctx.lineTo(bx * scale, by * scale);
      ctx.lineWidth = LINE_WIDTH;
      ctx.strokeStyle = color2;
      ctx.stroke();
    }
    function drawSkeleton(keypoints, minConfidence, ctx, scale = 1) {
      const adjacentKeyPoints = getAdjacentKeyPoints(keypoints, minConfidence);
      function toTuple({ y, x }) {
        return [y, x];
      }
      adjacentKeyPoints.forEach((keypoints2) => {
        drawSegment(toTuple(keypoints2[0].position), toTuple(keypoints2[1].position), COLOR, scale, ctx);
      });
    }
    function drawKeypoints(keypoints, minConfidence, ctx, scale = 1) {
      for (let i = 0; i < keypoints.length; i++) {
        const keypoint = keypoints[i];
        if (keypoint.score < minConfidence) {
          continue;
        }
        const { y, x } = keypoint.position;
        drawPoint(ctx, y * scale, x * scale, 3, COLOR);
      }
    }
  
    // part_color_scales.js
    var part_color_scales_exports = {};
    __export(part_color_scales_exports, {
      rainbow: () => rainbow,
      spectral: () => spectral,
      warm: () => warm
    });
    var rainbow = [
      [110, 64, 170],
      [143, 61, 178],
      [178, 60, 178],
      [210, 62, 167],
      [238, 67, 149],
      [255, 78, 125],
      [255, 94, 99],
      [255, 115, 75],
      [255, 140, 56],
      [239, 167, 47],
      [217, 194, 49],
      [194, 219, 64],
      [175, 240, 91],
      [135, 245, 87],
      [96, 247, 96],
      [64, 243, 115],
      [40, 234, 141],
      [28, 219, 169],
      [26, 199, 194],
      [33, 176, 213],
      [47, 150, 224],
      [65, 125, 224],
      [84, 101, 214],
      [99, 81, 195]
    ];
    var warm = [
      [110, 64, 170],
      [106, 72, 183],
      [100, 81, 196],
      [92, 91, 206],
      [84, 101, 214],
      [75, 113, 221],
      [66, 125, 224],
      [56, 138, 226],
      [48, 150, 224],
      [40, 163, 220],
      [33, 176, 214],
      [29, 188, 205],
      [26, 199, 194],
      [26, 210, 182],
      [28, 219, 169],
      [33, 227, 155],
      [41, 234, 141],
      [51, 240, 128],
      [64, 243, 116],
      [79, 246, 105],
      [96, 247, 97],
      [115, 246, 91],
      [134, 245, 88],
      [155, 243, 88]
    ];
    var spectral = [
      [158, 1, 66],
      [181, 26, 71],
      [202, 50, 74],
      [219, 73, 74],
      [232, 94, 73],
      [242, 117, 75],
      [248, 142, 83],
      [251, 167, 96],
      [253, 190, 112],
      [254, 210, 129],
      [254, 227, 149],
      [254, 240, 166],
      [251, 248, 176],
      [243, 249, 172],
      [231, 245, 163],
      [213, 238, 159],
      [190, 229, 160],
      [164, 218, 163],
      [137, 207, 165],
      [110, 192, 168],
      [86, 173, 174],
      [70, 150, 179],
      [67, 127, 180],
      [77, 103, 173]
    ];
  
    // index.js
    var stats = new import_stats.default();
    var state = {
      video: null,
      stream: null,
      net: null,
      videoConstraints: {},
      changingArchitecture: false,
      changingMultiplier: false,
      changingStride: false,
      changingResolution: false,
      changingQuantBytes: false
    };
    function isAndroid() {
      return /Android/i.test(navigator.userAgent);
    }
    function isiOS() {
      return /iPhone|iPad|iPod/i.test(navigator.userAgent);
    }
    function isMobile2() {
      return isAndroid() || isiOS();
    }
    function getVideoInputs() {
      return __async(this, null, function* () {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          console.log("enumerateDevices() not supported.");
          return [];
        }
        const devices = yield navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter((device) => device.kind === "videoinput");
        return videoDevices;
      });
    }
    function stopExistingVideoCapture() {
      if (state.video && state.video.srcObject) {
        state.video.srcObject.getTracks().forEach((track) => {
          track.stop();
        });
        state.video.srcObject = null;
      }
    }
    function getDeviceIdForLabel(cameraLabel) {
      return __async(this, null, function* () {
        const videoInputs = yield getVideoInputs();
        for (let i = 0; i < videoInputs.length; i++) {
          const videoInput = videoInputs[i];
          if (videoInput.label === cameraLabel) {
            return videoInput.deviceId;
          }
        }
        return null;
      });
    }
    function getFacingMode(cameraLabel) {
      if (!cameraLabel) {
        return "user";
      }
      if (cameraLabel.toLowerCase().includes("back")) {
        return "environment";
      } else {
        return "user";
      }
    }
    function getConstraints(cameraLabel) {
      return __async(this, null, function* () {
        let deviceId;
        let facingMode;
        if (cameraLabel) {
          deviceId = yield getDeviceIdForLabel(cameraLabel);
          facingMode = isMobile2() ? getFacingMode(cameraLabel) : null;
        }
        ;
        return { deviceId, facingMode };
      });
    }
    function setupCamera(cameraLabel) {
      return __async(this, null, function* () {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");
        }
        const videoElement = document.getElementById("video");
        stopExistingVideoCapture();
        const videoConstraints = yield getConstraints(cameraLabel);
        const stream = yield navigator.mediaDevices.getUserMedia({ "audio": false, "video": videoConstraints });
        videoElement.srcObject = stream;
        return new Promise((resolve) => {
          videoElement.onloadedmetadata = () => {
            videoElement.width = videoElement.videoWidth;
            videoElement.height = videoElement.videoHeight;
            resolve(videoElement);
          };
        });
      });
    }
    function loadVideo(cameraLabel) {
      return __async(this, null, function* () {
        try {
          state.video = yield setupCamera(cameraLabel);
        } catch (e) {
          let info = document.getElementById("info");
          info.textContent = "this browser does not support video capture,or this device does not have a camera";
          info.style.display = "block";
          throw e;
        }
        state.video.play();
      });
    }
    var defaultQuantBytes = 2;
    var defaultMobileNetMultiplier = isMobile2() ? 0.5 : 0.75;
    var defaultMobileNetStride = 16;
    var defaultMobileNetInternalResolution = "medium";
    var defaultResNetMultiplier = 1;
    var defaultResNetStride = 16;
    var defaultResNetInternalResolution = "low";
    var guiState = {
      algorithm: "multi-person-instance",
      estimate: "partmap",
      camera: null,
      flipHorizontal: true,
      input: {
        architecture: "MobileNetV1",
        outputStride: 16,
        internalResolution: "low",
        multiplier: 0.5,
        quantBytes: 2
      },
      multiPersonDecoding: {
        maxDetections: 5,
        scoreThreshold: 0.3,
        nmsRadius: 20,
        numKeypointForMatching: 17,
        refineSteps: 10
      },
      segmentation: {
        segmentationThreshold: 0.7,
        effect: "mask",
        maskBackground: true,
        opacity: 0.7,
        backgroundBlurAmount: 3,
        maskBlurAmount: 0,
        edgeBlurAmount: 3
      },
      partMap: {
        colorScale: "rainbow",
        effect: "partMap",
        segmentationThreshold: 0.5,
        opacity: 0.9,
        blurBodyPartAmount: 3,
        bodyPartEdgeBlurAmount: 3
      },
      showFps: !isMobile2()
    };
    function toCameraOptions(cameras) {
      const result2 = { default: null };
      cameras.forEach((camera) => {
        result2[camera.label] = camera.label;
      });
      return result2;
    }
    function setupGui(cameras) {
      const gui2 = new dat_gui_module_default.GUI({ width: 300 });
      let architectureController = null;
      guiState[TRY_RESNET_BUTTON_NAME] = function() {
        architectureController.setValue("ResNet50");
      };
      gui2.add(guiState, TRY_RESNET_BUTTON_NAME).name(TRY_RESNET_BUTTON_TEXT);
      updateTryResNetButtonDatGuiCss();
      gui2.add(guiState, "camera", toCameraOptions(cameras)).onChange(function(cameraLabel) {
        return __async(this, null, function* () {
          state.changingCamera = true;
          yield loadVideo(cameraLabel);
          state.changingCamera = false;
        });
      });
      gui2.add(guiState, "flipHorizontal");
      const algorithmController = gui2.add(guiState, "algorithm", ["person", "multi-person-instance"]);
      let input = gui2.addFolder("Input");
      let outputStrideController = null;
      function updateGuiOutputStride(outputStride, outputStrideArray) {
        if (outputStrideController) {
          outputStrideController.remove();
        }
        guiState.input.outputStride = outputStride;
        outputStrideController = input.add(guiState.input, "outputStride", outputStrideArray);
        outputStrideController.onChange(function(outputStride2) {
          state.changingStride = true;
          guiState.input.outputStride = +outputStride2;
        });
      }
      let internalResolutionController = null;
      function updateGuiInternalResolution(internalResolution, internalResolutionArray) {
        if (internalResolutionController) {
          internalResolutionController.remove();
        }
        guiState.input.internalResolution = internalResolution;
        internalResolutionController = input.add(guiState.input, "internalResolution", internalResolutionArray);
        internalResolutionController.onChange(function(internalResolution2) {
          guiState.input.internalResolution = internalResolution2;
        });
      }
      let multiplierController = null;
      function updateGuiMultiplier(multiplier, multiplierArray) {
        if (multiplierController) {
          multiplierController.remove();
        }
        guiState.input.multiplier = multiplier;
        multiplierController = input.add(guiState.input, "multiplier", multiplierArray);
        multiplierController.onChange(function(multiplier2) {
          state.changingMultiplier = true;
          guiState.input.multiplier = +multiplier2;
        });
      }
      let quantBytesController = null;
      function updateGuiQuantBytes(quantBytes, quantBytesArray) {
        if (quantBytesController) {
          quantBytesController.remove();
        }
        guiState.quantBytes = +quantBytes;
        guiState.input.quantBytes = +quantBytes;
        quantBytesController = input.add(guiState.input, "quantBytes", quantBytesArray);
        quantBytesController.onChange(function(quantBytes2) {
          state.changingQuantBytes = true;
          guiState.input.quantBytes = +quantBytes2;
        });
      }
      function updateGuiInputSection() {
        if (guiState.input.architecture === "MobileNetV1") {
          updateGuiInternalResolution(defaultMobileNetInternalResolution, ["low", "medium", "high", "full"]);
          updateGuiOutputStride(defaultMobileNetStride, [8, 16]);
          updateGuiMultiplier(defaultMobileNetMultiplier, [0.5, 0.75, 1]);
        } else {
          updateGuiInternalResolution(defaultResNetInternalResolution, ["low", "medium", "high", "full"]);
          updateGuiOutputStride(defaultResNetStride, [32, 16]);
          updateGuiMultiplier(defaultResNetMultiplier, [1]);
        }
        updateGuiQuantBytes(defaultQuantBytes, [1, 2, 4]);
      }
      architectureController = input.add(guiState.input, "architecture", ["ResNet50", "MobileNetV1"]);
      guiState.architecture = guiState.input.architecture;
      architectureController.onChange(function(architecture) {
        state.changingArchitecture = true;
        guiState.input.architecture = architecture;
        updateGuiInputSection();
      });
      updateGuiInputSection();
      input.open();
      const estimateController = gui2.add(guiState, "estimate", ["segmentation", "partmap"]);
      let segmentation = gui2.addFolder("Segmentation");
      segmentation.add(guiState.segmentation, "segmentationThreshold", 0, 1);
      const segmentationEffectController = segmentation.add(guiState.segmentation, "effect", ["mask", "bokeh"]);
      let multiPersonDecoding = gui2.addFolder("MultiPersonDecoding");
      multiPersonDecoding.add(guiState.multiPersonDecoding, "maxDetections", 0, 20, 1);
      multiPersonDecoding.add(guiState.multiPersonDecoding, "scoreThreshold", 0, 1);
      multiPersonDecoding.add(guiState.multiPersonDecoding, "nmsRadius", 0, 30, 1);
      multiPersonDecoding.add(guiState.multiPersonDecoding, "numKeypointForMatching", 1, 17, 1);
      multiPersonDecoding.add(guiState.multiPersonDecoding, "refineSteps", 1, 10, 1);
      multiPersonDecoding.open();
      algorithmController.onChange(function(value) {
        switch (guiState.algorithm) {
          case "single-person":
            multiPersonDecoding.close();
            singlePersonDecoding.open();
            break;
          case "multi-person":
            singlePersonDecoding.close();
            multiPersonDecoding.open();
            break;
        }
      });
      let darknessLevel;
      let bokehBlurAmount;
      let edgeBlurAmount;
      let maskBlurAmount;
      let maskBackground;
      segmentationEffectController.onChange(function(effectType) {
        if (effectType === "mask") {
          if (bokehBlurAmount) {
            bokehBlurAmount.remove();
          }
          if (edgeBlurAmount) {
            edgeBlurAmount.remove();
          }
          darknessLevel = segmentation.add(guiState.segmentation, "opacity", 0, 1);
          maskBlurAmount = segmentation.add(guiState.segmentation, "maskBlurAmount").min(0).max(20).step(1);
          maskBackground = segmentation.add(guiState.segmentation, "maskBackground");
        } else if (effectType === "bokeh") {
          if (darknessLevel) {
            darknessLevel.remove();
          }
          if (maskBlurAmount) {
            maskBlurAmount.remove();
          }
          if (maskBackground) {
            maskBackground.remove();
          }
          bokehBlurAmount = segmentation.add(guiState.segmentation, "backgroundBlurAmount").min(1).max(20).step(1);
          edgeBlurAmount = segmentation.add(guiState.segmentation, "edgeBlurAmount").min(0).max(20).step(1);
        }
      });
      segmentationEffectController.setValue(guiState.segmentation.effect);
      let partMap = gui2.addFolder("Part Map");
      partMap.add(guiState.partMap, "segmentationThreshold", 0, 1);
      partMap.add(guiState.partMap, "effect", ["partMap", "pixelation", "blurBodyPart"]);
      partMap.add(guiState.partMap, "opacity", 0, 1);
      partMap.add(guiState.partMap, "colorScale", Object.keys(part_color_scales_exports)).onChange((colorScale) => {
        setShownPartColorScales(colorScale);
      });
      setShownPartColorScales(guiState.partMap.colorScale);
      partMap.add(guiState.partMap, "blurBodyPartAmount").min(1).max(20).step(1);
      partMap.add(guiState.partMap, "bodyPartEdgeBlurAmount").min(1).max(20).step(1);
      partMap.open();
      estimateController.onChange(function(estimationType) {
        if (estimationType === "segmentation") {
          segmentation.open();
          partMap.close();
          document.getElementById("colors").style.display = "none";
        } else {
          segmentation.close();
          partMap.open();
          document.getElementById("colors").style.display = "inline-block";
        }
      });
      gui2.add(guiState, "showFps").onChange((showFps) => {
        if (showFps) {
          document.body.appendChild(stats.dom);
        } else {
          document.body.removeChild(stats.dom);
        }
      });
    }
    function setShownPartColorScales(colorScale) {
      const colors = document.getElementById("colors");
      colors.innerHTML = "";
      const partColors = part_color_scales_exports[colorScale];
      const partNames2 = bodyPix.PART_CHANNELS;
      for (let i = 0; i < partColors.length; i++) {
        const partColor = partColors[i];
        const child = document.createElement("li");
        child.innerHTML = `
          <div class='color' style='background-color:rgb(${partColor[0]},${partColor[1]},${partColor[2]})' ></div>
          ${partNames2[i]}`;
        colors.appendChild(child);
      }
    }
    function setupFPS() {
      stats.showPanel(0);
      if (guiState.showFps) {
        document.body.appendChild(stats.dom);
      }
    }
    function estimateSegmentation() {
      return __async(this, null, function* () {
        let multiPersonSegmentation = null;
        switch (guiState.algorithm) {
          case "multi-person-instance":
            return yield state.net.segmentMultiPerson(state.video, {
              internalResolution: guiState.input.internalResolution,
              segmentationThreshold: guiState.segmentation.segmentationThreshold,
              maxDetections: guiState.multiPersonDecoding.maxDetections,
              scoreThreshold: guiState.multiPersonDecoding.scoreThreshold,
              nmsRadius: guiState.multiPersonDecoding.nmsRadius,
              numKeypointForMatching: guiState.multiPersonDecoding.numKeypointForMatching,
              refineSteps: guiState.multiPersonDecoding.refineSteps
            });
          case "person":
            return yield state.net.segmentPerson(state.video, {
              internalResolution: guiState.input.internalResolution,
              segmentationThreshold: guiState.segmentation.segmentationThreshold,
              maxDetections: guiState.multiPersonDecoding.maxDetections,
              scoreThreshold: guiState.multiPersonDecoding.scoreThreshold,
              nmsRadius: guiState.multiPersonDecoding.nmsRadius
            });
          default:
            break;
        }
        ;
        return multiPersonSegmentation;
      });
    }
    function estimatePartSegmentation() {
      return __async(this, null, function* () {
        switch (guiState.algorithm) {
          case "multi-person-instance":
            return yield state.net.segmentMultiPersonParts(state.video, {
              internalResolution: guiState.input.internalResolution,
              segmentationThreshold: guiState.segmentation.segmentationThreshold,
              maxDetections: guiState.multiPersonDecoding.maxDetections,
              scoreThreshold: guiState.multiPersonDecoding.scoreThreshold,
              nmsRadius: guiState.multiPersonDecoding.nmsRadius,
              numKeypointForMatching: guiState.multiPersonDecoding.numKeypointForMatching,
              refineSteps: guiState.multiPersonDecoding.refineSteps
            });
          case "person":
            return yield state.net.segmentPersonParts(state.video, {
              internalResolution: guiState.input.internalResolution,
              segmentationThreshold: guiState.segmentation.segmentationThreshold,
              maxDetections: guiState.multiPersonDecoding.maxDetections,
              scoreThreshold: guiState.multiPersonDecoding.scoreThreshold,
              nmsRadius: guiState.multiPersonDecoding.nmsRadius
            });
          default:
            break;
        }
        ;
        return multiPersonPartSegmentation;
      });
    }
    function drawPoses(personOrPersonPartSegmentation, flipHorizontally, ctx) {
      if (Array.isArray(personOrPersonPartSegmentation)) {
        personOrPersonPartSegmentation.forEach((personSegmentation) => {
          let pose = personSegmentation.pose;
          if (flipHorizontally) {
            pose = bodyPix.flipPoseHorizontal(pose, personSegmentation.width);
          }
          drawKeypoints(pose.keypoints, 0.1, ctx);
          drawSkeleton(pose.keypoints, 0.1, ctx);
        });
      } else {
        personOrPersonPartSegmentation.allPoses.forEach((pose) => {
          if (flipHorizontally) {
            pose = bodyPix.flipPoseHorizontal(pose, personOrPersonPartSegmentation.width);
          }
          drawKeypoints(pose.keypoints, 0.1, ctx);
          drawSkeleton(pose.keypoints, 0.1, ctx);
        });
      }
    }
    function loadBodyPix() {
      return __async(this, null, function* () {
        toggleLoadingUI(true);
        state.net = yield bodyPix.load({
          architecture: guiState.input.architecture,
          outputStride: guiState.input.outputStride,
          multiplier: guiState.input.multiplier,
          quantBytes: guiState.input.quantBytes
        });
        toggleLoadingUI(false);
      });
    }
    function segmentBodyInRealTime() {
      const canvas = document.getElementById("output");
      function bodySegmentationFrame() {
        return __async(this, null, function* () {
          if (state.changingArchitecture || state.changingMultiplier || state.changingCamera || state.changingStride || state.changingQuantBytes) {
            console.log("load model...");
            loadBodyPix();
            state.changingArchitecture = false;
            state.changingMultiplier = false;
            state.changingStride = false;
            state.changingQuantBytes = false;
          }
          stats.begin();
          const flipHorizontally = guiState.flipHorizontal;
          switch (guiState.estimate) {
            case "segmentation":
              const multiPersonSegmentation = yield estimateSegmentation();
              switch (guiState.segmentation.effect) {
                case "mask":
                  const ctx2 = canvas.getContext("2d");
                  const foregroundColor = { r: 255, g: 255, b: 255, a: 255 };
                  const backgroundColor = { r: 0, g: 0, b: 0, a: 255 };
                  const mask = bodyPix.toMask(multiPersonSegmentation, foregroundColor, backgroundColor, true);
                  bodyPix.drawMask(canvas, state.video, mask, guiState.segmentation.opacity, guiState.segmentation.maskBlurAmount, flipHorizontally);
                  drawPoses(multiPersonSegmentation, flipHorizontally, ctx2);
                  break;
                case "bokeh":
                  bodyPix.drawBokehEffect(canvas, state.video, multiPersonSegmentation, +guiState.segmentation.backgroundBlurAmount, guiState.segmentation.edgeBlurAmount, flipHorizontally);
                  break;
              }
              break;
            case "partmap":
              const ctx = canvas.getContext("2d");
              const multiPersonPartSegmentation2 = yield estimatePartSegmentation();
              const coloredPartImageData = bodyPix.toColoredPartMask(multiPersonPartSegmentation2, part_color_scales_exports[guiState.partMap.colorScale]);
              const maskBlurAmount = 0;
              switch (guiState.partMap.effect) {
                case "pixelation":
                  const pixelCellWidth = 10;
                  bodyPix.drawPixelatedMask(canvas, state.video, coloredPartImageData, guiState.partMap.opacity, maskBlurAmount, flipHorizontally, pixelCellWidth);
                  break;
                case "partMap":
                  bodyPix.drawMask(canvas, state.video, coloredPartImageData, guiState.opacity, maskBlurAmount, flipHorizontally);
                  break;
                case "blurBodyPart":
                  const blurBodyPartIds = [0, 1];
                  bodyPix.blurBodyPart(canvas, state.video, multiPersonPartSegmentation2, blurBodyPartIds, guiState.partMap.blurBodyPartAmount, guiState.partMap.edgeBlurAmount, flipHorizontally);
              }
              drawPoses(multiPersonPartSegmentation2, flipHorizontally, ctx);
              break;
            default:
              break;
          }
          stats.end();
          requestAnimationFrame(bodySegmentationFrame);
        });
      }
      bodySegmentationFrame();
    }
    function bindPage() {
      return __async(this, null, function* () {
        yield loadBodyPix();
        document.getElementById("loading").style.display = "none";
        document.getElementById("main").style.display = "inline-block";
        yield loadVideo(guiState.camera);
        let cameras = yield getVideoInputs();
        setupFPS();
        setupGui(cameras);
        segmentBodyInRealTime();
      });
    }
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    bindPage();
  })();
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /**
      * @license
      * Copyright 2021 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      */
  /**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2019 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2019 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2020 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an AS IS BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  /**
  * @license
  * Copyright 2018 Google LLC. All Rights Reserved.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  * =============================================================================
  */
  /** @license See the LICENSE file. */
  //# sourceMappingURL=index.js.map